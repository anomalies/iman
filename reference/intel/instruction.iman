aaa=ASCII Adjust After Addition
	forms
		[ (aaa), (), (), ( r(al) ), ( 32; 16 ), (), (37), (ASCII adjust AL after addition) ]

	description
		Adjusts the sum of two unpacked BCD values to create an unpacked BCD result. The AL register is the implied
		source and destination operand for this instruction. The AAA instruction is only useful when it follows an ADD
		instruction that adds (binary addition) two unpacked BCD values and stores a byte result in the AL register. The
		AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.
		If the addition produces a decimal carry, the AH register increments by 1, and the CF and AF flags are set. If there
		was no decimal carry, the CF and AF flags are cleared and the AH register is unchanged. In either case, bits 4
		through 7 of the AL register are set to 0.
		
		This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


aad=ASCII Adjust AX Before Division 
	forms
		[ (aad), (),     (), ( r(ax) ), ( 32; 16 ), (), (D5 0A), (ASCII adjust AX before division) ]
		[ (aad), ( i8 ), (), ( r(ax) ), ( 32; 16 ), (), (D5 ib), (Adjust AX before division to number base @0) ]

	description
		Adjusts two unpacked BCD digits (the least-significant digit in the AL register and the most-significant digit in the
		AH register) so that a division operation performed on the result will yield a correct unpacked BCD value. The AAD
		instruction is only useful when it precedes a DIV instruction that divides (binary division) the adjusted value in the
		AX register by an unpacked BCD value.
		
		The AAD instruction sets the value in the AL register to (AL + (10 * AH)), and then clears the AH register to 00H.
		The value in the AX register is then equal to the binary equivalent of the original unpacked two-digit (base 10)
		number in registers AH and AL.
		
		The generalized version of this instruction allows adjustment of two unpacked digits of any number base (see the
		"Operation" section below), by setting the imm8 byte to the selected number base (for example, 08H for octal, 0AH
		for decimal, or 0CH for base 12 numbers). The AAD mnemonic is interpreted by all assemblers to mean adjust
		ASCII (base 10) values. To adjust values in another number base, the instruction must be hand coded in machine
		code (D5 imm8).
		
		This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


aam=ASCII Adjust AX After Multiply 
	forms
		[ (aam), (),     (), ( r(ax) ), ( 32; 16 ), (), (D4 0A), (ASCII adjust AX after multiply) ]
		[ (aam), ( i8 ), (), ( r(ax) ), ( 32; 16 ), (), (D4 ib), (Adjust AX after multiply to number base imm8) ]

	description
		Adjusts the result of the multiplication of two unpacked BCD values to create a pair of unpacked (base 10) BCD
		values. The AX register is the implied source and destination operand for this instruction. The AAM instruction is
		only useful when it follows an MUL instruction that multiplies (binary multiplication) two unpacked BCD values and
		stores a word result in the AX register. The AAM instruction then adjusts the contents of the AX register to contain
		the correct 2-digit unpacked (base 10) BCD result.
		
		The generalized version of this instruction allows adjustment of the contents of the AX to create two unpacked
		digits of any number base (see the "Operation" section below). Here, the imm8 byte is set to the selected number
		base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAM mnemonic is interpreted
		by all assemblers to mean adjust to ASCII (base 10) values. To adjust to values in another number base, the
		instruction must be hand coded in machine code (D4 imm8).
		
		This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


aas=ASCII Adjust AL After Subtraction
	forms
		[ (aas), (), (), ( r(ax) ), ( 32; 16 ), (), (3F), (ASCII adjust AL after subtraction) ]

	description
		Adjusts the result of the subtraction of two unpacked BCD values to create a unpacked BCD result. The AL register
		is the implied source and destination operand for this instruction. The AAS instruction is only useful when it follows
		a SUB instruction that subtracts (binary subtraction) one unpacked BCD value from another and stores a byte
		result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-
		digit unpacked BCD result
		
		If the subtraction produced a decimal carry, the AH register decrements by 1, and the CF and AF flags are set. If no
		decimal carry occurred, the CF and AF flags are cleared, and the AH register is unchanged. In either case, the AL
		register is left with its top four bits set to 0.
		
		This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


adc=Add with Carry 
	forms
		[ (adc), ( r(al), i8 ),   (8),  (), ( 64; 32; 16 ), (), (14 ib), (Add with carry @1 to @0) ]
		[ (adc), ( r(ax), i16 ),  (16), (), ( 64; 32; 16 ), (), (15 iw), (Add with carry @1 to @0) ]
		[ (adc), ( r(eax), i32 ), (32), (), ( 64; 32; 16 ), (), (15 id), (Add with carry @1 to @0) ]
		[ (adc), ( r(rax), i32 ), (32), (), ( 64; ),        (), (REX.W + 15 id), (Add with carry @1, sign extended to 64-bits, to @0) ]
		[ (adc), ( v8, i8 ),      (8),  (), ( 64; 32; 16 ), (), (80 /2 ib), (Add with carry @1 to @0) ]
		[ (adc), ( v8, i8 ),      (8),  (), ( 64; ),        (), (REX + 80 /2 ib), (Add with carry @1 to @0) ]
		[ (adc), ( v16, i16 ),    (16), (), ( 64; 32; 16 ), (), (81 /2 iw), (Add with carry @1 to @0) ]
		[ (adc), ( v32, i32 ),    (32), (), ( 64; 32; 16 ), (), (81 /2 id), (Add with CF @1 to @0) ]
		[ (adc), ( v64, i32 ),    (64), (), ( 64; ),        (), (REX.W + 81 /2 id), (Add with CF @1 sign extended to 64-bits to @0) ]
		[ (adc), ( v16, i8 ),     (16), (), ( 64; 32; 16 ), (), (83 /2 ib), (Add with CF sign-extended @1 to @0) ]
		[ (adc), ( v32, i8 ),     (32), (), ( 64; 32; 16 ), (), (83 /2 ib), (Add with CF sign-extended @1 into @0) ]
		[ (adc), ( v64, i8 ),     (64), (), ( 64; ),        (), (REX.W + 83 /2 ib), (Add with CF sign-extended @1 into @0) ]
		[ (adc), ( v8, r8 ),      (8),  (), ( 64; 32; 16 ), (), (10 /r), (Add with carry byte register to @0) ]
		[ (adc), ( v8, r8 ),      (8),  (), ( 64; ),        (), (REX + 10 /r), (Add with carry byte register to r/m64) ]
		[ (adc), ( v16, r16 ),    (16), (), ( 64; 32; 16 ), (), (11 /r), (Add with carry @1 to @0) ]
		[ (adc), ( v32, r32 ),    (32), (), ( 64; 32; 16 ), (), (11 /r), (Add with CF @1 to @0) ]
		[ (adc), ( v64, r64 ),    (64), (), ( 64; ),        (), (REX.W + 11 /r), (Add with CF @1 to @0) ]
		[ (adc), ( r8, v8 ),      (8),  (), ( 64; 32; 16 ), (), (12 /r), (Add with carry @1 to byte register) ]
		[ (adc), ( r8, v8 ),      (8),  (), ( 64; ),        (), (REX + 12 /r), (Add with carry r/m64 to byte register) ]
		[ (adc), ( r16, v16 ),    (16), (), ( 64; 32; 16 ), (), (13 /r), (Add with carry @1 to @0) ]
		[ (adc), ( r32, v32 ),    (32), (), ( 64; 32; 16 ), (), (13 /r), (Add with CF @1 to @0) ]
		[ (adc), ( r64, v64 ),    (64), (), ( 64; ),        (), (REX.W + 13 /r), (Add with CF @1 to @0) ]

	description
		Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and
		stores the result in the destination operand. The destination operand can be a register or a memory location; the
		source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be
		used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate
		value is used as an operand, it is sign-extended to the length of the destination operand format.
		The ADC instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates
		the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result,
		respectively. The SF flag indicates the sign of the signed result.
		
		The ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is
		followed by an ADC instruction.
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
		the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


adcx=Unsigned Integer Addition of Two Operands with Carry Flag
	forms
		[ (adcx), ( r32, v32 ),   (32),  (), ( 64; 32; 16 ), (ADX), (66 0F 38 F6 /r),         (Unsigned addition of @0 with CF then adding @1 to that result, updating CF) ]
		[ (adcx), ( r64, v64 ),   (64),  (), ( 64; ),        (ADX), (REX.w + 66 0F 38 F6 /r), (Unsigned addition of @0 with CF then adding @1 to that result, updating CF) ]

	description
		Performs an unsigned addition of the destination operand (first operand), the source operand (second operand)
		and the carry-flag (CF) and stores the result in the destination operand. The destination operand is a general-
		purpose register, whereas the source operand can be a general-purpose register or memory location. The state of
		CF can represent a carry from a previous addition. The instruction sets the CF flag with the carry generated by the
		unsigned addition of the operands.
		
		The ADCX instruction is executed in the context of multi-precision addition, where we add a series of operands with
		a carry-chain. At the beginning of a chain of additions, we need to make sure the CF is in a desired initial state.
		Often, this initial state needs to be 0, which can be achieved with an instruction to zero the CF (e.g. XOR).
		This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.
		
		In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional
		registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64 bits. 
		ADCX executes normally either inside or outside a transaction region.
		
		Note: ADCX defines the OF flag differently than the ADD/ADC instructions

	exceptions

	flags

	operation

	meta


add=Add 
	forms
		[ (add), ( AL, i8 ),   (8),  (), ( 64; 32; 16 ), (), (04 ib), (Add @1 to @0) ]
		[ (add), ( AX, i16 ),  (16), (), ( 64; 32; 16 ), (), (05 iw), (Add @1 to @0) ]
		[ (add), ( EAX, i32 ), (32), (), ( 64; 32; 16 ), (), (05 id), (Add @1 to @0) ]
		[ (add), ( RAX, i32 ), (32), (), ( 64; ),        (), (REX.W + 05 id), (Add @1, sign-extended to 64-bits, to @0) ]
		[ (add), ( v8, i8 ),   (8),  (), ( 64; 32; 16 ), (), (80 /0 ib), (Add @1 to @0) ]
		[ (add), ( v8, i8 ),   (8),  (), ( 64; ),        (), (REX + 80 /0 ib), (Add sign-extended @1 to r/m64) ]
		[ (add), ( v16, i16 ), (16), (), ( 64; 32; 16 ), (), (81 /0 iw), (Add @1 to @0) ]
		[ (add), ( v32, i32 ), (32), (), ( 64; 32; 16 ), (), (81 /0 id), (Add @1 to @0) ]
		[ (add), ( v64, i32 ), (64), (), ( 64; ),        (), (REX.W + 81 /0 id), (Add @1, sign-extended to 64-bits, to @0) ]
		[ (add), ( v16, i8 ),  (16), (), ( 64; 32; 16 ), (), (83 /0 ib), (Add sign-extended @1 to @0) ]
		[ (add), ( v32, i8 ),  (32), (), ( 64; 32; 16 ), (), (83 /0 ib), (Add sign-extended @1 to @0) ]
		[ (add), ( v64, i8 ),  (64), (), ( 64; ),        (), (REX.W + 83 /0 ib), (Add sign-extended @1 to @0) ]
		[ (add), ( v8, r8 ),   (8),  (), ( 64; 32; 16 ), (), (00 /r), (Add @1 to @0) ]
		[ (add), ( v8, r8 ),   (8),  (), ( 64; ),        (), (REX + 00 /r), (Add @1 to @0) ]
		[ (add), ( v16, r16 ), (16), (), ( 64; 32; 16 ), (), (01 /r), (Add @1 to @0) ]
		[ (add), ( v32, r32 ), (32), (), ( 64; 32; 16 ), (), (01 /r), (Add @1 to @0) ]
		[ (add), ( v64, r64 ), (64), (), ( 64; ),        (), (REX.W + 01 /r), (Add @1 to @0) ]
		[ (add), ( r8, v8 ),   (8),  (), ( 64; 32; 16 ), (), (02 /r), (Add @1 to @0) ]
		[ (add), ( r8, v8 ),   (8),  (), ( 64; ),        (), (REX + 02 /r), (Add @1 to @0) ]
		[ (add), ( r16, v16 ), (16), (), ( 64; 32; 16 ), (), (03 /r), (Add @1 to @0) ]
		[ (add), ( r32, v32 ), (32), (), ( 64; 32; 16 ), (), (03 /r), (Add @1 to @0) ]
		[ (add), ( r64, v64 ), (64), (), ( 64; ),        (), (REX.W + 03 /r), (Add @1 to @0) ]

	description
		Adds the destination operand (first operand) and the source operand (second operand) and then stores the result
		in the destination operand. The destination operand can be a register or a memory location; the source operand
		can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one
		instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination
		operand format.
		
		The ADD instruction performs integer addition. It evaluates the result for both signed and unsigned integer oper-
		ands and sets the OF and CF flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The
		SF flag indicates the sign of the signed result.
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX a REX prefix in the form of REX.W promotes operation to 64 bits. 

	exceptions

	flags

	operation

	meta


addpd/vaddpd=Add Packed Double-Precision Floating-Point Values 
	forms

	description
		Performs a SIMD add of the two packed double-precision floating-point values from the source operand (second
		operand) and the destination operand (first operand), and stores the packed double-precision floating-point results
		in the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


addps/vaddps=Add Packed Single-Precision Floating-Point Values 
	forms

	description
		Performs a SIMD add of the four packed single-precision floating-point values from the source operand (second
		operand) and the destination operand (first operand), and stores the packed single-precision floating-point results
		in the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


addsd/vaddsd=Add Scalar Double-Precision Floating-Point Values 
	forms

	description
		Adds the low double-precision floating-point values from the source operand (second operand) and the destination
		operand (first operand), and stores the double-precision floating-point result in the destination operand.
		The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.
		VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


addss/vaddss=Add Scalar Single-Precision Floating-Point Values 
	forms

	description
		Adds the low single-precision floating-point values from the source operand (second operand) and the destination
		operand (first operand), and stores the single-precision floating-point result in the destination operand.
		The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:32) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


addsubpd/vaddsubpd=Packed Double-FP Add/Subtract 
	forms

	description
		Adds odd-numbered double-precision floating-point values of the first source operand (second operand) with the
		corresponding double-precision floating-point values from the second source operand (third operand); stores the
		result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered
		double-precision floating-point values from the second source operand from the corresponding double-precision
		floating values in the first source operand; stores the result into the even-numbered values of the destination
		operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination 
		is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


addsubps/vaddsubps=Packed Single-FP Add/Subtract 
	forms

	description
		Adds odd-numbered single-precision floating-point values of the first source operand (second operand) with the
		corresponding single-precision floating-point values from the second source operand (third operand); stores the
		result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered
		single-precision floating-point values from the second source operand from the corresponding single-precision
		floating values in the first source operand; stores the result into the even-numbered values of the destination
		operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified. See Figure 3-4.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


adox=Unsigned Integer Addition of Two Operands with Overflow Flag
	forms
		[ (adox), ( r32, v32 ),   (32),  (), ( 64; 32; 16 ), (ADX), (66 0F 38 F6 /r),         (Unsigned addition of @0 with OF then adding @1 to that result, updating OF) ]
		[ (adox), ( r64, v64 ),   (64),  (), ( 64; ),        (ADX), (REX.w + 66 0F 38 F6 /r), (Unsigned addition of @0 with OF then adding @1 to that result, updating OF) ]

	description
		Performs an unsigned addition of the destination operand (first operand), the source operand (second operand)
		and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a general-
		purpose register, whereas the source operand can be a general-purpose register or memory location. The state of
		OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the
		unsigned addition of the operands.
		
		The ADOX instruction is executed in the context of multi-precision addition, where we add a series of operands with
		a carry-chain. At the beginning of a chain of additions, we execute an instruction to zero the OF (e.g. XOR).
		This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit
		mode.
		
		In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to addi-
		tional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64-bits.
		ADOX executes normally either inside or outside a transaction region.
		
		Note: ADOX defines the CF and OF flags differently than the ADD/ADC instructions

	exceptions

	flags

	operation

	meta


aesdec/vaesdec=Perform One Round of an AES Decryption Flow 
	forms
		[ (aesdec),  ( r128, v128 ),         (128), (), ( 64; 32; ),  (AES),      (66 0F 38 DE /r),                (Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from @0 with a 128-bit round key from @1, storing the result in @0) ]
		[ (vaesdec), ( r128, r128, v128 ),   (128), (), ( 64; 32; ),  (AES; AVX), (VEX.NDS.128.66.0F38.WIG DE /r), (Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from @0 with a 128-bit round key from @2, storing the result in @0) ]

	description
		This instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, with the
		round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and
		store the result in the destination operand.
		Use the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDE-CLAST instruction.
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an
		XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-
		1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM
		register are zeroed.

	exceptions

	flags

	operation

	meta


aesdeclast/vaesdeclast=Perform Last Round of an AES Decryption Flow 
	forms
		[ (aesdeclast),  ( r128, v128 ),         (128), (), ( 64; 32; ),  (AES),      (66 0F 38 DF /r),                (Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from @0 with a 128-bit round key from @1, storing the result in @0) ]
		[ (vaesdeclast), ( r128, r128, v128 ),   (128), (), ( 64; 32; ),  (AES; AVX), (VEX.NDS.128.66.0F38.WIG DF /r), (Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from @1 with a 128-bit round key from @2; store the result in @0) ]

	description
		This instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, with the
		round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and
		store the result in the destination operand.
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an
		XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)
		of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM
		register are zeroed.

	exceptions

	flags

	operation

	meta


aesenc/vaesenc=Perform One Round of an AES Encryption Flow 
	forms
		[ (aesenc),  ( r128, v128 ),         (128), (), ( 64; 32; ),  (AES),      (66 0F 38 DC /r),                (Perform one round of an AES encryption flow, operating on a 128-bit data (state) from @0 with a 128-bit round key from @1, storing the reslt in @0) ]
		[ (vaesenc), ( r128, r128, v128 ),   (128), (), ( 64; 32; ),  (AES; AVX), (VEX.NDS.128.66.0F38.WIG DC /r), (Perform one round of an AES encryption flow, operating on a 128-bit data (state) from @0 with a 128-bit round key from @2, storing the reslt in @0) ]

	description
		This instruction performs a single round of an AES encryption flow using a round key from the second source
		operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand.
		Use the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENC-CLAST instruction.
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an
		XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-
		1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM
		register are zeroed.

	exceptions

	flags

	operation

	meta


aesenclast/vaesenclast=Perform Last Round of an AES Encryption Flow
	forms
		[ (aesenclast),  ( r128, v128 ),         (128), (), ( 64; 32; ),  (AES),      (66 0F 38 DD /r),                (Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from @0 with a 128-bit round key from @1, storing the result in @0) ]
		[ (vaesenclast), ( r128, r128, v128 ),   (128), (), ( 64; 32; ),  (AES; AVX), (VEX.NDS.128.66.0F38.WIG DD /r), (Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from @0 with a 128-bit round key from @2, storing the result in @0) ]

	description
		This instruction performs the last round of an AES encryption flow using a round key from the second source
		operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand.
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an
		XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-
		1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM
		register are zeroed.

	exceptions

	flags

	operation

	meta


aesimc/vaesimc=Perform the AES InvMixColumn Transformation
	forms
		[ (aesimc),  ( r128,  v128 ),   (128), (), ( 64; 32; ),  (AES),      (66 0F 38 DB /r),                (Perform the InvMixColumn transformation on a 128-bit round key from @1 and store the result in @0) ]
		[ (vaesimc), ( r128,  v128 ),   (128), (), ( 64; 32; ),  (AES; AVX), (VEX.NDS.128.66.0F38.WIG DB /r), (Perform the InvMixColumn transformation on a 128-bit round key from @1 and store the result in @0) ]

	description
		Perform the InvMixColumns transformation on the source operand and store the result in the destination operand.
		The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.
		Note: the AESIMC instruction should be applied to the expanded AES round keys (except for the first and last round
		key) in order to prepare them for decryption using the "Equivalent Inverse Cipher" (defined in FIPS 197).
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


aeskeygenassist/vaeskeygenassist=AES Round Key Generation Assist
	forms
		[ (aeskeygenassist),  ( r128,  v128, i8 ),    (128), (), ( 64; 32; ),  (AES),      (66 0F 38 DF /r),                (Assist in AES round key generation using an 8-bit Round Constant (RCON) specified in @2, operating on 128 bits of data specified in @1 and stores the result in @0) ]
		[ (vaeskeygenassist), ( r128,  v128, i8 ),    (128), (), ( 64; 32; ),  (AES; AVX), (VEX.NDS.128.66.0F38.WIG DF /r), (Assist in AES round key generation using an 8-bit Round Constant (RCON) specified in @2, operating on 128 bits of data specified in @1 and stores the result in @0) ]

	description
		Assist in expanding the AES cipher key, by computing steps towards generating a round key for encryption, using
		128-bit data specified in the source operand and an 8-bit round constant specified as an immediate, store the
		result in the destination operand.
		The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


and=Logical AND 
	forms
		[ (and), ( r(al), i8 ),   (8),  (), ( 64; 32; 16 ), (), (24 ib),            (@0 AND @1) ]
		[ (and), ( r(ax), i16 ),  (16), (), ( 64; 32; 16 ), (), (25 iw),            (@0 AND @1) ]
		[ (and), ( r(eax), i32 ), (32), (), ( 64; 32; 16 ), (), (25 id),            (@0 AND @1) ]
		[ (and), ( r(rax), i32 ), (32), (), ( 64; ),        (), (REX.W + 25 id),    (@0 AND @1 sign-extended to 64-bits) ]
		[ (and), ( v8, i8 ),      (8),  (), ( 64; 32; 16 ), (), (80 /4 ib),         (@0 AND @1) ]
		[ (and), ( v8, i8 ),      (8),  (), ( 64; ),        (), (REX + 80 /4 ib),   (@0 AND @1) ]
		[ (and), ( v16, i16 ),    (16), (), ( 64; 32; 16 ), (), (81 /4 iw),         (@0 AND @1) ]
		[ (and), ( v32, i32 ),    (32), (), ( 64; 32; 16 ), (), (81 /4 id),         (@0 AND @1) ]
		[ (and), ( v64, i32 ),    (64), (), ( 64; ),        (), (REX.W + 81 /4 id), (@0 AND @1 sign extended to 64-bits) ]
		[ (and), ( v16, i8 ),     (16), (), ( 64; 32; 16 ), (), (83 /4 ib),         (@0 AND @1 sign-extended) ]
		[ (and), ( v32, i8 ),     (32), (), ( 64; 32; 16 ), (), (83 /4 ib),         (@0 AND @1 sign-extended) ]
		[ (and), ( v64, i8 ),     (64), (), ( 64; ),        (), (REX.W + 83 /4 ib), (@0 AND @1 sign-extended) ]
		[ (and), ( v8, r8 ),      (8),  (), ( 64; 32; 16 ), (), (20 /r),            (@0 AND @0) ]
		[ (and), ( v64, r8 ),     (8),  (), ( 64; ),        (), (REX + 20 /r),      (@0 AND @1 sign-extended) ]
		[ (and), ( v16, r16 ),    (16), (), ( 64; 32; 16 ), (), (21 /r),            (@0 AND @1) ]
		[ (and), ( v32, r32 ),    (32), (), ( 64; 32; 16 ), (), (21 /r),            (@0 AND @1) ]
		[ (and), ( v64, r64 ),    (64), (), ( 64; ),        (), (REX.W + 21 /r),    (@0 AND r32) ]
		[ (and), ( r8, v8 ),      (8),  (), ( 64; 32; 16 ), (), (22 /r),            (@0 AND @1) ]
		[ (and), ( r64, v8 ),     (8),  (), ( 64; ),        (), (REX + 22 /r),      (@0 AND @1 sign-extend then store in @0) ]
		[ (and), ( r16, v16 ),    (16), (), ( 64; 32; 16 ), (), (23 /r),            (@0 AND @1) ]
		[ (and), ( r32, v32 ),    (32), (), ( 64; 32; 16 ), (), (23 /r),            (@0 AND @1) ]
		[ (and), ( r64, v64 ),    (64), (), ( 64; ),        (), (REX.W + 23 /r),    (@0 AND @1) ]

	description
		Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in
		the destination operand location. The source operand can be an immediate, a register, or a memory location; the
		destination operand can be a register or a memory location. (However, two memory operands cannot be used in
		one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1;
		otherwise, it is set to 0.
		
		This instruction can be used with a LOCK prefix to allow the it to be executed atomically.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


andn=Logical AND NOT
	forms

	description
		Performs a bitwise logical AND of inverted second operand (the first source operand) with the third operand (the
		second source operand). The result is stored in the first operand (destination operand).
		
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


andpd/vandpd=Bitwise Logical AND of Packed Double-Precision Floating-Point Values 
	forms

	description
		Performs a bitwise logical AND of the two packed double-precision floating-point values from the source operand
		(second operand) and the destination operand (first operand), and stores the result in the destination operand.
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


andps/vandps=Bitwise Logical AND of Packed Single-Precision Floating-Point Values 
	forms

	description
		Performs a bitwise logical AND of the four or eight packed single-precision floating-point values from the first
		source operand and the second source operand, and stores the result in the destination operand.
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


andnpd/vandnpd=Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values 
	forms

	description
		Performs a bitwise logical AND NOT of the two or four packed double-precision floating-point values from the first
		source operand and the second source operand, and stores the result in the destination operand.
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


andnps/vandnps=Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values 
	forms

	description
		Inverts the bits of the four packed single-precision floating-point values in the destination operand (first operand),
		performs a bitwise logical AND of the four packed single-precision floating-point values in the source operand
		(second operand) and the temporary inverted result, and stores the result in the destination operand.
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


arpl=Adjust RPL Field of Segment Selector 
	forms

	description
		Compares the RPL fields of two segment selectors. The first operand (the destination operand) contains one
		segment selector and the second operand (source operand) contains the other. (The RPL field is located in bits 0
		and 1 of each operand.) If the RPL field of the destination operand is less than the RPL field of the source operand,
		the ZF flag is set and the RPL field of the destination operand is increased to match that of the source operand.
		Otherwise, the ZF flag is cleared and no change is made to the destination operand. (The destination operand can
		be a word register or a memory location; the source operand must be a word register.)
		
		The ARPL instruction is provided for use by operating-system procedures (however, it can also be used by applica-
		tions). It is generally used to adjust the RPL of a segment selector that has been passed to the operating system
		by an application program to match the privilege level of the application program. Here the segment selector
		passed to the operating system is placed in the destination operand and segment selector for the application
		program's code segment is placed in the source operand. (The RPL field in the source operand represents the priv-
		ilege level of the application program.) Execution of the ARPL instruction then ensures that the RPL of the segment
		selector received by the operating system is no lower (does not have a higher privilege) than the privilege level of
		the application program (the segment selector for the application program's code segment can be read from the
		stack following a procedure call).
		
		This instruction executes as described in compatibility mode and legacy mode. It is not encodable in 64-bit mode.

	exceptions

	flags

	operation

	meta


blendpd/vblendpd=Blend Packed Double Precision Floating-Point Values
	forms

	description
		Double-precision floating-point values from the second source operand (third operand) are conditionally merged
		with values from the first source operand (second operand) and written to the destination operand (first operand).
		The immediate bits [3:0] determine whether the corresponding double-precision floating-point value in the desti-
		nation is copied from the second source or first source. If a bit in the mask, corresponding to a word, is "1", then
		the double-precision floating-point value in the second source operand is copied, else the value in the first source
		operand is copied.
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


bextr=Bit Field Extract 
	forms

	description
		Extracts contiguous bits from the first source operand (the second operand) using an index value and length value
		specified in the second source operand (the third operand). Bit 7:0 of the second source operand specifies the
		starting bit position of bit extraction. A START value exceeding the operand size will not extract any bits from the
		second source operand. Bit 15:8 of the second source operand specifies the maximum number of bits (LENGTH)
		beginning at the START position to extract. Only bit positions up to (OperandSize -1) of the first source operand are
		extracted. The extracted bits are written to the destination register, starting from the least significant bit. All higher
		order bits in the destination operand (starting at bit position LENGTH) are zeroed. The destination register is
		cleared if no bits are extracted.
		
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


blendps/vblendps=Blend Packed Single Precision Floating-Point Values
	forms

	description
		Packed single-precision floating-point values from the second source operand (third operand) are conditionally
		merged with values from the first source operand (second operand) and written to the destination operand (first
		operand). The immediate bits [7:0] determine whether the corresponding single precision floating-point value in
		the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is "1",
		then the single-precision floating-point value in the second source operand is copied, else the value in the first
		source operand is copied.
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: The first source operand an XMM register. The second source operand is an XMM register
		or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the
		corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


blendvpd/vblendvpd=Variable Blend Packed Double Precision Floating-Point Values
	forms

	description
		Conditionally copy each quadword data element of double-precision floating-point value from the second source
		operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits
		are the most significant bit in each quadword element of the mask register.
		
		Each quadword element of the destination operand is copied from:
		- the corresponding quadword element in the second source operand, If a mask bit is "1"; or
		- the corresponding quadword element in the first source operand, If a mask bit is "0"
		
		The register assignment of the implicit mask operand for BLENDVPD is defined to be the architectural register XMM0.
		128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (VLMAX-1:128)
		of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined
		to be the architectural register XMM0. An attempt to execute BLENDVPD with a VEX prefix will cause #UD.
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and
		encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
		ignored. The upper bits (VLMAX-1:128) of the corresponding YMM register (destination register) are zeroed.
		VEX.W must be 0, otherwise, the instruction will #UD.
		
		VEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source
		operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and
		encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
		ignored. VEX.W must be 0, otherwise, the instruction will #UD.
		
		VBLENDVPD permits the mask to be any XMM or YMM register. In contrast, BLENDVPD treats XMM0 implicitly as the
		mask and do not support non-destructive destination operation.

	exceptions

	flags

	operation

	meta


blendvps/vblendvps=Variable Blend Packed Single Precision Floating-Point Values 
	forms

	description
		Conditionally copy each dword data element of single-precision floating-point value from the second source
		operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits
		are the most significant bit in each dword element of the mask register.
		
		Each quadword element of the destination operand is copied from:
		- the corresponding dword element in the second source operand, If a mask bit is "1"; or
		- the corresponding dword element in the first source operand, If a mask bit is "0"
		
		The register assignment of the implicit mask operand for BLENDVPS is defined to be the architectural register XMM0.
		128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (VLMAX-1:128)
		of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined
		to be the architectural register XMM0. An attempt to execute BLENDVPS with a VEX prefix will cause #UD.
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and
		encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
		ignored. The upper bits (VLMAX-1:128) of the corresponding YMM register (destination register) are zeroed.
		VEX.W must be 0, otherwise, the instruction will #UD.
		
		VEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source
		operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and
		encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
		ignored. VEX.W must be 0, otherwise, the instruction will #UD.
		
		VBLENDVPS permits the mask to be any XMM or YMM register. In contrast, BLENDVPS treats XMM0 implicitly as the
		mask and do not support non-destructive destination operation.

	exceptions

	flags

	operation

	meta


blsi=Extract Lowest Set Isolated Bit 
	forms

	description
		Extracts the lowest set bit from the source operand and set the corresponding bit in the destination register. All
		other bits in the destination operand are zeroed. If no bits are set in the source operand, BLSI sets all the bits in
		the destination to 0 and sets ZF and CF.
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


blsmsk=Get Mask Up to Lowest Set Bit 
	forms

	description
		Sets all the lower bits of the destination operand to "1" up to and including lowest set bit (=1) in the source
		operand. If source operand is zero, BLSMSK sets all bits of the destination operand to 1 and also sets CF to 1.
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


blsr=Reset Lowest Set Bit 
	forms

	description
		Copies all bits from the source operand to the destination operand and resets (=0) the bit position in the destina-
		tion operand that corresponds to the lowest set bit of the source operand. If the source operand is zero BLSR sets CF.
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


bound=Check Array Index Against Bounds 
	forms

	description
		BOUND determines if the first operand (array index) is within the bounds of an array specified the second operand
		(bounds operand). The array index is a signed integer located in a register. The bounds operand is a memory loca-
		tion that contains a pair of signed doubleword-integers (when the operand-size attribute is 32) or a pair of signed
		word-integers (when the operand-size attribute is 16). The first doubleword (or word) is the lower bound of the
		array and the second doubleword (or word) is the upper bound of the array. The array index must be greater than
		or equal to the lower bound and less than or equal to the upper bound plus the operand size in bytes. If the index
		is not within bounds, a BOUND range exceeded exception (#BR) is signaled. When this exception is generated, the
		saved return instruction pointer points to the BOUND instruction.
		
		The bounds limit data structure (two words or doublewords containing the lower and upper limits of the array) is
		usually placed just before the array itself, making the limits addressable via a constant offset from the beginning of
		the array. Because the address of the array already will be present in a register, this practice avoids extra bus cycles
		to obtain the effective address of the array bounds.
		
		This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


bsf=Bit Scan Forward 
	forms

	description
		Searches the source operand (second operand) for the least significant set bit (1 bit). If a least significant 1 bit is
		found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a
		memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source
		operand. If the content of the source operand is 0, the content of the destination operand is undefined.
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


bsr=Bit Scan Reverse 
	forms

	description
		Searches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is
		found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a
		memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source
		operand. If the content source operand is 0, the content of the destination operand is undefined.
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


bswap=Byte Swap 
	forms

	description
		Reverses the byte order of a 32-bit or 64-bit (destination) register. This instruction is provided for converting little-
		endian values to big-endian format and vice versa. To swap bytes in a word value (16-bit register), use the XCHG
		instruction. When the BSWAP instruction references a 16-bit register, the result is undefined.
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
		the summary chart at the beginning of this section for encoding data and limits.
		
		The BSWAP instruction is not supported on IA-32 processors earlier than the Intel 486 processor family. For
		compatibility with this instruction, software should include functionally equivalent code for execution on Intel
		processors earlier than the Intel486 processor family.


	exceptions

	flags

	operation

	meta


bt=Bit Test 
	forms

	description
		Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by
		the bit offset (specified by the second operand) and stores the value of the bit in the CF flag. The bit base operand
		can be a register or a memory location; the bit offset operand can be a register or an immediate value:
		
		- If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset
		operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit mode).
		
		- If the bit base operand specifies a memory location, the operand represents the address of the byte in memory
		that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be
		referenced by the offset operand depends on the operand size.
		
		Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-
		tion with the displacement field of the memory operand. In this case, the low-order 3 or 5 bits (3 for 16-bit oper-
		ands, 5 for 32-bit operands) of the immediate bit offset are stored in the immediate bit offset field, and the high-
		order bits are shifted and combined with the byte displacement in the addressing mode by the assembler. The
		processor will ignore the high order bits if they are not zero.
		When accessing a bit in memory, the processor may access 4 bytes starting from the memory address for a 32-bit
		operand size, using by the following relationship:
		
		Effective Address + (4 * (BitOffset DIV 32))
		
		Or, it may access 2 bytes starting from the memory address for a 16-bit operand, using this relationship:
		
		Effective Address + (2 * (BitOffset DIV 16))
		
		It may do so even when only a single byte needs to be accessed to reach the given bit. When using this bit
		addressing mechanism, software should avoid referencing areas of memory close to address space holes. In partic-
		ular, it should avoid references to memory-mapped I/O registers. Instead, software should use the MOV instruc-
		tions to load from or store to these addresses, and use the register form of these instructions to manipulate the data.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit oper-
		ands.

	exceptions

	flags

	operation

	meta


btc=Bit Test and Complement 
	forms

	description
		Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by
		the bit offset operand (second operand), stores the value of the bit in the CF flag, and complements the selected
		bit in the bit string. The bit base operand can be a register or a memory location; the bit offset operand can be a
		register or an immediate value:
		
		- If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset
		operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit
		mode). This allows any bit position to be selected.
		
		- If the bit base operand specifies a memory location, the operand represents the address of the byte in memory
		that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be
		referenced by the offset operand depends on the operand size.
		
		Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-
		tion with the displacement field of the memory operand.
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


btr=Bit Test and Reset
	forms

	description
		Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by
		the bit offset operand (second operand), stores the value of the bit in the CF flag, and clears the selected bit in the
		bit string to 0. The bit base operand can be a register or a memory location; the bit offset operand can be a register
		or an immediate value:
		
		- If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset
		operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit
		mode). This allows any bit position to be selected.
		
		- If the bit base operand specifies a memory location, the operand represents the address of the byte in memory
		that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be
		referenced by the offset operand depends on the operand size.
		
		Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-
		tion with the displacement field of the memory operand.
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


bts=Bit Test and Set 
	forms

	description
		Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by
		the bit offset operand (second operand), stores the value of the bit in the CF flag, and sets the selected bit in the
		bit string to 1. The bit base operand can be a register or a memory location; the bit offset operand can be a register
		or an immediate value:
		
		- If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset
		operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit
		mode). This allows any bit position to be selected.
		
		- If the bit base operand specifies a memory location, the operand represents the address of the byte in memory
		that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be
		referenced by the offset operand depends on the operand size.
		
		Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-
		tion with the displacement field of the memory operand.
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
		the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


bzhi=Zero High Bits Starting with Specified Bit Position 
	forms

	description
		BZHI copies the bits of the first source operand (the second operand) into the destination operand (the first
		operand) and clears the higher bits in the destination according to the INDEX value specified by the second source
		operand (the third operand). The INDEX is specified by bits 7:0 of the second source operand. The INDEX value is
		saturated at the value of OperandSize -1. CF is set, if the number contained in the 8 low bits of the third operand
		is greater than OperandSize -1.

		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


call=Call Procedure 
	forms

	description
		Saves procedure linking information on the stack and branches to the called procedure specified using the target
		operand. The target operand specifies the address of the first instruction in the called procedure. The operand can
		be an immediate value, a general-purpose register, or a memory location.
		This instruction can be used to execute four types of calls:
		
		- Near Call: a call to a procedure in the current code segment (the segment currently pointed to by the CS
		register), sometimes referred to as an intra-segment call.
		- Far Call: a call to a procedure located in a different segment than the current code segment, sometimes
		referred to as an inter-segment call.
		- Inter-privilege-level far call: a far call to a procedure in a segment at a different privilege level 
		than that of the currently executing program or procedure.
		- Task switch: a call to a procedure located in a different task.
		
		The latter two call types (inter-privilege-level call and task switch) can only be executed in protected mode. See
		"Calling Procedures Using Call and RET" in Chapter 6 of the Intel 64 and IA-32 Architectures Software Devel-
		oper's Manual, Volume 1, for additional information on near, far, and inter-privilege-level calls. See Chapter 7,
		"Task Management," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, for infor-
		mation on performing task switches with the CALL instruction.
		
		~Near Call
			When executing a near call, the processor pushes the value of the EIP register (which contains the offset
			of the instruction following the CALL instruction) on the stack (for use later as a return-instruction pointer). The
			processor then branches to the address in the current code segment specified by the target operand. The target
			operand specifies either an absolute offset in the code segment (an offset from the base of the code segment) or a
			relative offset (a signed displacement relative to the current value of the instruction pointer in the EIP register; this
			value points to the instruction following the CALL instruction). The CS register is not changed on near calls.
			For a near call absolute, an absolute offset is specified indirectly in a general-purpose register or a memory location
			(r/m16, r/m32, or r/m64). The operand-size attribute determines the size of the target operand (16, 32 or 64 bits).
			When in 64-bit mode, the operand size for near call (and all near branches) is forced to 64-bits. Absolute offsets
			are loaded directly into the EIP(RIP) register. If the operand size attribute is 16, the upper two bytes of the EIP
			register are cleared, resulting in a maximum instruction pointer size of 16 bits. When accessing an absolute offset
			indirectly using the stack pointer [ESP] as the base register, the base value used is the value of the ESP before the
			instruction executes.
			
			A relative offset (rel16 or rel32) is generally specified as a label in assembly code. But at the machine code level, it
			is encoded as a signed, 16- or 32-bit immediate value. This value is added to the value in the EIP(RIP) register. In
			64-bit mode the relative offset is always a 32-bit immediate value which is sign extended to 64-bits before it is
			added to the value in the RIP register for the target calculation. As with absolute offsets, the operand-size attribute
			determines the size of the target operand (16, 32, or 64 bits). In 64-bit mode the target operand will always be 64-
			bits because the operand size is forced to 64-bits for near branches.
		
		~Far Calls in Real-Address or Virtual-8086 Mode
			When executing a far call in real- address or virtual-8086 mode, the processor pushes the current value of both 
			the CS and EIP registers on the stack for use as a return-instruction pointer. 
			The processor then performs a "far branch" to the code segment and offset specified with the target
			operand for the called procedure. The target operand specifies an absolute far address either directly with a pointer
			(ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). With the pointer method, the
			segment and offset of the called procedure is encoded in the instruction using a 4-byte (16-bit operand size) or 6-
			byte (32-bit operand size) far address immediate. With the indirect method, the target operand specifies a memory
			location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The operand-size
			attribute determines the size of the offset (16 or 32 bits) in the far address. The far address is loaded directly into
			the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.
		
		~Far Calls in Protected Mode
			When the processor is operating in protected mode, the CALL instruction can be used to perform the following types of far calls:
			
			- Far call to the same privilege level
			- Far call to a different privilege level (inter-privilege level call)
			- Task switch (far call to another task)
			
			In protected mode, the processor always uses the segment selector part of the far address to access the corre-
			sponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access
			rights determine the type of call operation to be performed.
			
			If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is
			performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming,
			a general-protection exception is generated.) A far call to the same privilege level in protected mode is very similar
			to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either
			directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The
			operand- size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment
			selector and its descriptor are loaded into CS register; the offset from the instruction is loaded into the EIP register.
			A call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same
			privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making
			calls between 16-bit and 32-bit code segments.
			
			When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed
			through a call gate. The segment selector specified by the target operand identifies the call gate. The target
			operand can specify the call gate segment selector either directly with a pointer (ptr16:16 or ptr16:32) or indirectly
			with a memory location (m16:16 or m16:32). The processor obtains the segment selector for the new code
			segment and the new instruction pointer (offset) from the call gate descriptor. (The offset from the target operand
			is ignored when a call gate is used.)
			
			On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The
			segment selector for the new stack segment is specified in the TSS for the currently running task. The branch to
			the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a
			segment at the same privilege level, no stack switch occurs.) On the new stack, the processor pushes the segment
			selector and stack pointer for the calling procedure's stack, an optional set of parameters from the calling proce-
			dures stack, and the segment selector and instruction pointer for the calling procedure's code segment. (A value in
			the call gate descriptor determines how many parameters to copy to the new stack.) Finally, the processor
			branches to the address of the procedure being called within the new code segment.
			Executing a task switch with the CALL instruction is similar to executing a call through a call gate. The target
			operand specifies the segment selector of the task gate for the new task activated by the switch (the offset in the
			target operand is ignored). The task gate in turn points to the TSS for the new task, which contains the segment
			selectors for the task's code and stack segments. Note that the TSS also contains the EIP value for the next instruc-
			tion that was to be executed before the calling task was suspended. This instruction pointer value is loaded into the
			EIP register to re-start the calling task.
			
			The CALL instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of
			the task gate. See Chapter 7, "Task Management," in the Intel 64 and IA-32 Architectures Software Developer's
			Manual, Volume 3A, for information on the mechanics of a task switch.
			
			When you execute at task switch with a CALL instruction, the nested task flag (NT) is set in the EFLAGS register
			and the new TSS's previous task link field is loaded with the old task's TSS selector. Code is expected to suspend
			this nested task by executing an IRET instruction which, because the NT flag is set, automatically uses the previous
			task link to return to the calling task. (See "Task Linking" in Chapter 7 of the Intel 64 and IA-32 Architectures
			Software Developer's Manual, Volume 3A, for information on nested tasks.) Switching tasks with the CALL instruc-
			tion differs in this regard from JMP instruction. JMP does not set the NT flag and therefore does not expect an IRET
			instruction to suspend the task.
		
		~Mixing 16-Bit and 32-Bit Calls
			When making far calls between 16-bit and 32-bit code segments, use a call gate. If
			the far call is from a 32-bit code segment to a 16-bit code segment, the call should be made from the first 64
			KBytes of the 32-bit code segment. This is because the operand-size attribute of the instruction is set to 16, so only
			a 16-bit return address offset can be saved. Also, the call should be made using a 16-bit call gate so that 16-bit
			values can be pushed on the stack. See Chapter 21, "Mixing 16-Bit and 32-Bit Code," in the Intel 64 and IA-32
			Architectures Software Developer's Manual, Volume 3B, for more information.
		
		~Far Calls in Compatibility Mode
			When the processor is operating in compatibility mode, the CALL instruction can be
			used to perform the following types of far calls:
			
			- Far call to the same privilege level, remaining in compatibility mode
			- Far call to the same privilege level, transitioning to 64-bit mode
			- Far call to a different privilege level (inter-privilege level call), transitioning to 64-bit mode
			
			Note that a CALL instruction can not be used to cause a task switch in compatibility mode since task switches are
			not supported in IA-32e mode.

			In compatibility mode, the processor always uses the segment selector part of the far address to access the corre-
			sponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate) and access rights determine
			the type of call operation to be performed.
			
			If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is
			performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming,
			a general-protection exception is generated.) A far call to the same privilege level in compatibility mode is very
			similar to one carried out in protected mode. The target operand specifies an absolute far address either directly
			with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The operand-size
			attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its
			descriptor are loaded into CS register and the offset from the instruction is loaded into the EIP register. The differ-
			ence is that 64-bit mode may be entered. This specified by the L bit in the new code segment descriptor.
			
			Note that a 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code
			segment at the same privilege level. However, using this mechanism requires that the target code segment
			descriptor have the L bit set, causing an entry to 64-bit mode.
			When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed
			through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target
			operand can specify the call gate segment selector either directly with a pointer (ptr16:16 or ptr16:32) or indirectly
			with a memory location (m16:16 or m16:32). The processor obtains the segment selector for the new code
			segment and the new instruction pointer (offset) from the 16-byte call gate descriptor. (The offset from the target
			operand is ignored when a call gate is used.)
			
			On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The
			segment selector for the new stack segment is set to NULL. The new stack pointer is specified in the TSS for the
			currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using
			a call gate to perform a far call to a segment at the same privilege level, an implicit stack switch occurs as a result
			of entering 64-bit mode. The SS selector is unchanged, but stack segment accesses use a segment base of 0x0, the
			limit is ignored, and the default stack size is 64-bits. The full value of RSP is used for the offset, of which the upper
			32-bits are undefined.) On the new stack, the processor pushes the segment selector and stack pointer for the
			calling procedure's stack and the segment selector and instruction pointer for the calling procedure's code
			segment. (Parameter copy is not supported in IA-32e mode.) Finally, the processor branches to the address of the
			procedure being called within the new code segment.
		
		~Near/(Far) Calls in 64-bit Mode
			When the processor is operating in 64-bit mode, the CALL instruction can be used to perform the following types of far calls:
			
			- Far call to the same privilege level, transitioning to compatibility mode
			- Far call to the same privilege level, remaining in 64-bit mode
			- Far call to a different privilege level (inter-privilege level call), remaining in 64-bit mode
			
			Note that in this mode the CALL instruction can not be used to cause a task switch in 64-bit mode since task
			switches are not supported in IA-32e mode.
			
			In 64-bit mode, the processor always uses the segment selector part of the far address to access the corresponding
			descriptor in the GDT or LDT. The descriptor type (code segment, call gate) and access rights determine the type of
			call operation to be performed.
			
			If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is
			performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming,
			a general-protection exception is generated.) A far call to the same privilege level in 64-bit mode is very similar to
			one carried out in compatibility mode. The target operand specifies an absolute far address indirectly with a
			memory location (m16:16, m16:32 or m16:64). The form of CALL with a direct specification of absolute far
			address is not defined in 64-bit mode. The operand-size attribute determines the size of the offset (16, 32, or 64
			bits) in the far address. The new code segment selector and its descriptor are loaded into the CS register; the offset
			from the instruction is loaded into the EIP register. The new code segment may specify entry either into compati-
			bility or 64-bit mode, based on the L bit value.
			
			A 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the
			same privilege level. However, using this mechanism requires that the target code segment descriptor have the L-bit set.
			When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed
			through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target
			operand can only specify the call gate segment selector indirectly with a memory location (m16:16, m16:32 or
			m16:64). The processor obtains the segment selector for the new code segment and the new instruction pointer
			(offset) from the 16-byte call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)
			On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The
			segment selector for the new stack segment is set to NULL. The new stack pointer is specified in the TSS for the
			currently running task. The branch to the new code segment occurs after the stack switch.
			
			Note that when using a call gate to perform a far call to a segment at the same privilege level, an implicit stack
			switch occurs as a result of entering 64-bit mode. The SS selector is unchanged, but stack segment accesses use a
			segment base of 0x0, the limit is ignored, and the default stack size is 64-bits. (The full value of RSP is used for the offset.) 
			On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure's
			stack and the segment selector and instruction pointer for the calling procedure's code segment. (Parameter copy
			is not supported in IA-32e mode.) Finally, the processor branches to the address of the procedure being called
			within the new code segment.

	exceptions

	flags

	operation

	meta


cbw=Convert Byte to Word
cwde=Convert Word to Doubleword
cdqe=Convert Doubleword to Quadword
	forms

	description
		Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction
		copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-
		word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.
		CBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attri-
		bute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the
		operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the
		operand-size attribute to determine the size of values to be converted.
		
		In 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes
		this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit 31)
		of the doubleword in the EAX register into the high 32 bits of RAX.

	exceptions

	flags

	operation

	meta


clac=Clear AC Flag in EFLAGS Register 
	forms

	description
		Clears the AC flag bit in EFLAGS register. This disables any alignment checking of user-mode data accesses. If the
		SMAP bit is set in the CR4 register, this disallows explicit supervisor-mode data accesses to user-mode pages.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute CLAC when CPL > 0 cause #UD.

	exceptions

	flags

	operation

	meta


clc=Clear Carry Flag 
	forms

	description
		Clears the CF flag in the EFLAGS register. Operation is the same in all modes.

	exceptions

	flags

	operation

	meta


cld=Clear Direction Flag 
	forms

	description
		Clears the DF flag in the EFLAGS register. When the DF flag is set to 0, string operations increment the index registers (ESI and/or EDI). 
		Operation is the same in all modes.

	exceptions

	flags

	operation

	meta


clflush=Flush Cache Line 
	forms

	description
		Invalidates the cache line that contains the linear address specified with the source operand from all levels of the
		processor cache hierarchy (data and instruction). The invalidation is broadcast throughout the cache coherence
		domain. If, at any level of the cache hierarchy, the line is inconsistent with memory (dirty) it is written to memory
		before invalidation. The source operand is a byte memory location.
		
		The availability of CLFLUSH is indicated by the presence of the CPUID feature flag CLFSH (bit 19 of the EDX register,
		see "CPUID-CPU Identification" in this chapter). The aligned cache line size affected is also indicated with the
		CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).
		The memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It
		should be noted that processors are free to speculatively fetch and cache data from system memory regions
		assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh
		instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative
		fetching can occur at any time and is not tied to instruction execution, the CLFLUSH instruction is not ordered with
		respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be specula-
		tively loaded into a cache line just before, during, or after the execution of a CLFLUSH instruction that references
		the cache line).
		
		CLFLUSH is only ordered by the MFENCE instruction. It is not guaranteed to be ordered by any other fencing or seri-
		alizing instructions or by another CLFLUSH instruction. For example, software can use an MFENCE instruction to
		ensure that previous stores are included in the write-back.
		
		The CLFLUSH instruction can be used at all privilege levels and is subject to all permission checking and faults asso-
		ciated with a byte load (and in addition, a CLFLUSH instruction is allowed to flush a linear address in an execute-only segment). 
		Like a load, the CLFLUSH instruction sets the A bit but not the D bit in the page tables.
		The CLFLUSH instruction was introduced with the SSE2 extensions; however, because it has its own CPUID feature
		flag, it can be implemented in IA-32 processors that do not include the SSE2 extensions. Also, detecting the presence 
		of the SSE2 extensions with the CPUID instruction does not guarantee that the CLFLUSH instruction is implemented in the processor.
		
		CLFLUSH operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


cli=Clear Interrupt Flag 
	forms

	description
		If protected-mode virtual interrupts are not enabled, CLI clears the IF flag in the EFLAGS register. No other flags
		are affected. Clearing the IF flag causes the processor to ignore maskable external interrupts. The IF flag and the
		CLI and STI instruction have no affect on the generation of exceptions and NMI interrupts.
		
		When protected-mode virtual interrupts are enabled, CPL is 3, and IOPL is less than 3; CLI clears the VIF flag in the
		EFLAGS register, leaving IF unaffected. Table 3-6 indicates the action of the CLI instruction depending on the
		processor operating mode and the CPL/IOPL of the running program or procedure.
		
		Operation is the same in all modes.

	exceptions

	flags

	operation

	meta


clts=Clear Task-Switched Flag in CR0 
	forms

	description
		Clears the task-switched (TS) flag in the CR0 register. This instruction is intended for use in operating-system
		procedures. It is a privileged instruction that can only be executed at a CPL of 0. It is allowed to be executed in real-
		address mode to allow initialization for protected mode.
		
		The processor sets the TS flag every time a task switch occurs. The flag is used to synchronize the saving of FPU
		context in multitasking applications. See the description of the TS flag in the section titled "Control Registers" in
		Chapter 2 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, for more information
		about this flag.
		
		CLTS operation is the same in non-64-bit modes and 64-bit mode.
		
		See Chapter 25, "VMX Non-Root Operation," of the Intel 64 and IA-32 Architectures Software Developer's
		Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.

	exceptions

	flags

	operation

	meta


cmc=Complement Carry Flag 
	forms

	description
		Complements the CF flag in the EFLAGS register. 
		CMC operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


cmovcc=Conditional Move 
	forms

	description
		The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
		and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
		associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
		is not performed and execution continues with the instruction following the CMOVcc instruction.
		
		These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
		general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
		The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
		and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for unsigned integers.
		
		Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
		defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
		(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
		
		The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
		supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
		the processor's feature information with the CPUID instruction.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional
		registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


cmp=Compare Two Operands 
	forms

	description
		Compares the first source operand with the second source operand and sets the status flags in the EFLAGS register
		according to the results. The comparison is performed by subtracting the second operand from the first operand
		and then setting the status flags in the same manner as the SUB instruction. When an immediate value is used as
		an operand, it is sign-extended to the length of the first operand.
		
		The condition codes used by the Jcc, CMOVcc, and SETcc instructions are based on the results of a CMP instruction.
		Appendix B, "EFLAGS Condition Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual,
		Volume 1, shows the relationship of the status flags and the condition codes.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
		tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


cmppd/vcmppd=Compare Packed Double-Precision Floating-Point Values 
	forms

	description
		Performs a SIMD compare of the packed double-precision floating-point values in the source operand (second
		operand) and the destination operand (first operand) and returns the results of the comparison to the destination
		operand. The comparison predicate operand (third operand) specifies the type of comparison performed on each of
		the pairs of packed values. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s
		(comparison false). The sign of zero is ignored for comparisons, so that -0.0 is equal to +0.0.
		
		128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The
		second source operand (second operand) can be an XMM register or 128-bit memory location. The comparison
		predicate operand is an 8-bit immediate, bits 2:0 of the immediate define the type of comparison to be performed.
		Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		Two comparisons are performed with results written to bits 127:0 of the destination operand.

	exceptions

	flags

	operation

	meta


cmpps/vcmpps=Compare Packed Single-Precision Floating-Point Values 
	forms

	description
		Performs a SIMD compare of the packed single-precision floating-point values in the source operand (second
		operand) and the destination operand (first operand) and returns the results of the comparison to the destination
		operand. The comparison predicate operand (third operand) specifies the type of comparison performed on each of
		the pairs of packed values. The result of each comparison is a doubleword mask of all 1s (comparison true) or all
		0s (comparison false). The sign of zero is ignored for comparisons, so that -0.0 is equal to +0.0.
		128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The
		second source operand (second operand) can be an XMM register or 128-bit memory location. The comparison
		predicate operand is an 8-bit immediate, bits 2:0 of the immediate define the type of comparison to be performed
		(see Table 3-7). Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:128) of the corresponding YMM destination
		register remain unchanged. Four comparisons are performed with results written to bits 127:0 of the destination operand.
		
		The unordered relationship is true when at least one of the two source operands being compared is a NaN; the
		ordered relationship is true when neither source operand is a NaN.
		A subsequent computational instruction that uses the mask result in the destination operand as an input operand
		will not generate a fault, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s
		corresponds to a QNaN.
		
		Note that processors with "CPUID.1H:ECX.AVX =0" do not implement the "greater-than", "greater-than-or-equal",
		"not-greater than", and "not-greater-than-or-equal relations" predicates. These comparisons can be made either
		by using the inverse relationship (that is, use the "not-less-than-or-equal" to make a "greater-than" comparison)
		or by using software emulation. When using software emulation, the program must swap the operands (copying
		registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate.
		
		Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand
		CMPPS instruction, for processors with "CPUID.1H:ECX.AVX =0". Compilers should treat reserved Imm8 values as illegal syntax.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cmps/cmpsb/cmpsw/cmpsd/cmpsq=Compare String Operands 
	forms

	description
		Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word,
		doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register
		according to the results.
		
		Both source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI
		or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the
		second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the
		instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.
		
		At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
		operands" form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands
		to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the
		source values. This explicit-operand form is provided to allow documentation. However, note that the documenta-
		tion provided by this form can be misleading. That is, the source operand symbols must specify the correct type
		(size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-
		tion. Locations of the source operands are always specified by the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) regis-
		ters, which must be loaded correctly before the compare string instruction is executed.
		
		The no-operands form provides "short forms" of the byte, word, and doubleword versions of the CMPS instructions.
		Here also the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers are assumed by the processor to specify the loca-
		tion of the source operands. The size of the source operands is selected with the mnemonic:
		
		CMPSB - byte comparison
		CMPSW - word comparison
		CMPSD - doubleword comparison
		CMPSQ - quadword comparison using REX.W
		
		After the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the
		setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E/R)SI and (E/R)DI register increment; if the
		DF flag is 1, the registers decrement.) The registers increment or decrement by 1 for byte operations, by 2 for word
		operations, 4 for doubleword operations. If operand size is 64, RSI and RDI registers increment by 8 for quadword operations.
		
		The CMPS, CMPSB, CMPSW, CMPSD, and CMPSQ instructions can be preceded by the REP prefix for block compar-
		isons. More often, however, these instructions will be used in a LOOP construct that takes some action based on the
		setting of the status flags before the next comparison is made. 
		
		In 64-bit mode, the instruction's default address size is 64 bits, 32 bit address size is supported using the prefix
		67H. Use of the REX.W prefix promotes doubleword operation to 64 bits (see CMPSQ).

	exceptions

	flags

	operation

	meta


cmpsd/vcmpsd=Compare Scalar Double-Precision Floating-Point Values 
	forms

	description
		Compares the low double-precision floating-point values in the source operand (second operand) and the destination
		operand (first operand) and returns the results of the comparison to the destination operand. The comparison
		predicate operand (third operand) specifies the type of comparison performed. The comparison result is a quad-
		word mask of all 1s (comparison true) or all 0s (comparison false). The sign of zero is ignored for comparisons, so
		that -0.0 is equal to +0.0.
		
		128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The
		second source operand (second operand) can be an XMM register or 64-bit memory location. The comparison pred-
		icate operand is an 8-bit immediate, bits 2:0 of the immediate define the type of comparison to be performed. 
		Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.
		
		The unordered relationship is true when at least one of the two source operands being compared is a NaN; the
		ordered relationship is true when neither source operand is a NaN.
		A subsequent computational instruction that uses the mask result in the destination operand as an input operand
		will not generate a fault, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s
		corresponds to a QNaN.
		
		Note that processors with "CPUID.1H:ECX.AVX = 0" do not implement the "greater-than", "greater-than-or-equal",
		"not-greater than", and "not-greater-than-or-equal relations" predicates. These comparisons can be made either
		by using the inverse relationship (that is, use the "not-less-than-or-equal" to make a "greater-than" comparison)
		or by using software emulation. When using software emulation, the program must swap the operands (copying
		registers when necessary to protect the data that will now be in the destination operand), and then perform the
		compare using a different predicate. 
		
		Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand
		CMPSD instruction, for processors with "CPUID.1H:ECX.AVX = 0". Compilers should treat reserved imm8 values as illegal syntax.
		
		The greater-than relations not implemented in the processor require more than one instruction to emulate in soft-
		ware and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the
		operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to
		the correct destination register and that the source operand is left intact.)
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		
		~Enhanced Comparison Predicate for VEX-Encoded VCMPSD
			VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source
			operand (third operand) can be an XMM register or a 64-bit memory location. Bits (VLMAX-1:128) of the destination 
			YMM register are zeroed. The comparison predicate operand is an 8-bit immediate:
			
			- For instructions encoded using the VEX prefix, bits 4:0 define the type of comparison to be performed. Bits 5 through 7 of the immediate are reserved.
			
			Processors with "CPUID.1H:ECX.AVX =1" implement the full complement of 32 predicates, software emulation is no longer needed. 
			Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPSD instruction. 
			Compilers should treat reserved Imm8 values as illegal syntax. 
			Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic interface.


	exceptions

	flags

	operation

	meta


cmpss/vcmpss=Compare Scalar Single-Precision Floating-Point Values 
	forms

	description
		Compares the low single-precision floating-point values in the source operand (second operand) and the destination
		operand (first operand) and returns the results of the comparison to the destination operand. The comparison
		predicate operand (third operand) specifies the type of comparison performed. The comparison result is a double-
		word mask of all 1s (comparison true) or all 0s (comparison false). The sign of zero is ignored for comparisons, so
		that -0.0 is equal to +0.0.
		
		128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The
		second source operand (second operand) can be an XMM register or 64-bit memory location. The comparison pred-
		icate operand is an 8-bit immediate, bits 2:0 of the immediate define the type of comparison to be performed.
		Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.
		
		The unordered relationship is true when at least one of the two source operands being compared is a NaN; the
		ordered relationship is true when neither source operand is a NaN.
		
		A subsequent computational instruction that uses the mask result in the destination operand as an input operand
		will not generate a fault, since a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s
		corresponds to a QNaN.
		
		Note that processors with "CPUID.1H:ECX.AVX =0" do not implement the "greater-than", "greater-than-or-equal",
		"not-greater than", and "not-greater-than-or-equal relations" predicates. These comparisons can be made either
		by using the inverse relationship (that is, use the "not-less-than-or-equal" to make a "greater-than" comparison)
		or by using software emulation. When using software emulation, the program must swap the operands (copying
		registers when necessary to protect the data that will now be in the destination operand), and then perform the
		compare using a different predicate. 
		
		Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand
		CMPSS instruction, for processors with "CPUID.1H:ECX.AVX =0". See Table 3-15. Compilers should treat reserved Imm8 values as illegal syntax.
		
		The greater-than relations not implemented in the processor require more than one instruction to emulate in soft-
		ware and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the
		operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to
		the correct destination register and that the source operand is left intact.)
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		
		~Enhanced Comparison Predicate for VEX-Encoded VCMPSD
			VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source
			operand (third operand) can be an XMM register or a 32-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed. 
			The comparison predicate operand is an 8-bit immediate:
			
			- For instructions encoded using the VEX prefix, bits 4:0 define the type of comparison to be performed. Bits 5 through 7 of the immediate are reserved.
			
			Processors with "CPUID.1H:ECX.AVX =1" implement the full complement of 32 predicates, software emulation is no longer needed.
			Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPSS instruction.
			Compilers should treat reserved Imm8 values as illegal syntax.
			Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic interface.

	exceptions

	flags

	operation

	meta


cmpxchg=Compare and Exchange
	forms

	description
		Compares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two
		values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the
		destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode.
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the
		interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the
		comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is
		written into the destination. (The processor never produces a locked read without also producing a locked write.)
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). 
		Use of the REX.W prefix promotes operation to 64 bits.
		
		This instruction is not supported on Intel processors earlier than the Intel 486 processors.

	exceptions

	flags

	operation

	meta


cmpxchg8b/cmpxchg16b=Compare and Exchange Bytes 
	forms

	description
		Compares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand
		(destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored
		in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX).
		The destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For
		the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the
		low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-
		order 64 bits and RAX and RBX contain the low-order 64bits of a 128-bit value.
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the
		interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the
		comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is
		written into the destination. (The processor never produces a locked read without also producing a locked write.)
		
		In 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. Note that
		CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned. See the summary chart at the
		beginning of this section for encoding data and limits.
		
		This instruction encoding is not supported on Intel processors earlier than the Pentium processors.

	exceptions

	flags

	operation

	meta


comisd/vcomisd=Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS 
	forms

	description
		Compares the double-precision floating-point values in the low quadwords of operand 1 (first operand) and
		operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result 
		(unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. 
		The unordered result is returned if either source operand is a NaN (QNaN or SNaN). The sign of zero is ignored for
		comparisons, so that -0.0 is equal to +0.0.
		
		Operand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory location.
		The COMISD instruction differs from the UCOMISD instruction in that it signals a SIMD floating-point invalid oper-
		ation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISD instruction signals an invalid
		numeric exception only if a source operand is an SNaN.
		The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


comiss/vcomiss=Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS 
	forms

	description
		Compares the single-precision floating-point values in the low doublewords of operand 1 (first operand) and
		operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result 
		(unordered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. 
		The unordered result is returned if either source operand is a NaN (QNaN or SNaN). The sign of zero is ignored for
		comparisons, so that -0.0 is equal to +0.0.
		
		Operand 1 is an XMM register; Operand 2 can be an XMM register or a 32 bit memory location.
		The COMISS instruction differs from the UCOMISS instruction in that it signals a SIMD floating-point invalid opera-
		tion exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISS instruction signals an invalid
		numeric exception only if a source operand is an SNaN.
		
		The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cpuid=CPU Identification
	forms

	description
		CPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers.1 The
		instruction's output is dependent on the contents of the EAX register upon execution (in some cases, ECX as well).
		
		Two types of information are returned: basic and extended function information. If a value entered for CPUID.EAX
		is higher than the maximum input value for basic or extended function for that processor then the data for the
		highest basic information leaf is returned.
		
		The ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can
		set and clear this flag, the processor executing the procedure supports the CPUID instruction. 
		
		If a value entered for CPUID.EAX is less than or equal to the maximum input value and the leaf is not supported on
		that processor then 0 is returned in all the registers.
		
		When CPUID returns the highest basic leaf information as a result of an invalid input EAX value, any dependence
		on input ECX value in the basic leaf is honored.
		CPUID can be executed at any privilege level to serialize instruction execution. Serializing instruction execution
		guarantees that any modifications to flags, registers, and memory for previous instructions are completed before
		the next instruction is fetched and executed.
		
		This instruction operates the same in non-64-bit modes and 64-bit mode.
		
		When CPUID executes with EAX set to 0, the processor returns the highest value the CPUID recognizes for
		returning basic processor information. The value is returned in the EAX register (see Table 3-18) and is processor
		specific.
		A vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is "GenuineIntel" and is expressed:
		EBX = 756e6547h (* "Genu", with G in the low eight bits of BL *)
		EDX = 49656e69h (* "ineI", with i in the low eight bits of DL *)
		ECX = 6c65746eh (* "ntel", with n in the low eight bits of CL *)
		
		When CPUID executes with EAX set to 80000000H, the processor returns the highest value the processor recognizes 
		for returning extended processor information. The value is returned in the EAX register and is processor specific.

	exceptions

	flags

	operation

	meta
		see
			"Serializing Instructions", Chapter 8 - "Multiple-Processor Management", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A
			"Caching Translation Information", Chapter 4 - "Paging", Intel64 and IA-32 Architectures Software Developer's Manual, Volume 3A


crc32=Accumulate CRC32 Value 
	forms

	description
		Starting with an initial value in the first operand (destination operand), accumulates a CRC32 (polynomial
		11EDC6F41H) value for the second operand (source operand) and stores the result in the destination operand. The
		source operand can be a register or a memory location. The destination operand must be an r32 or r64 register. If
		the destination is an r64 register, then the 32-bit result is stored in the least significant double word and
		00000000H is stored in the most significant double word of the r64 register.
		
		The initial value supplied in the destination operand is a double word integer stored in the r32 register or the least
		significant double word of the r64 register. To incrementally accumulate a CRC32 value, software retains the result
		of the previous CRC32 operation in the destination operand, then executes the CRC32 instruction again with new
		input data in the source operand. Data contained in the source operand is processed in reflected bit order.
		This means that the most significant bit of the source operand is treated as the least significant bit of the quotient, 
		and so on, for all the bits of the source operand. Likewise, the result of the CRC operation is stored in the destination
		operand in reflected bit order. This means that the most significant bit of the resulting CRC (bit 31) is stored in the
		least significant bit of the destination operand (bit 0), and so on, for all the bits of the CRC.

	exceptions

	flags

	operation

	meta


cvtdq2pd/vcvtdq2pd=Convert Packed Dword Integers to Packed Double-Precision FP Values 
	forms

	description
		Converts two packed signed doubleword integers in the source operand (second operand) to two packed double-
		precision floating-point values in the destination operand (first operand).
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding XMM register destination are
		unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 128- bit memory location. The destination
		operation is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtdq2ps/vcvtdq2ps=Convert Packed Dword Integers to Packed Single-Precision FP Values 
	forms

	description
		Converts four packed signed doubleword integers in the source operand (second operand) to four packed single-
		precision floating-point values in the destination operand (first operand).
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding XMM register destination are unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
		operation is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtpd2dq/vcvtpd2dq=Convert Packed Double-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts two packed double-precision floating-point values in the source operand (second operand) to two packed
		signed doubleword integers in the destination operand (first operand).
		The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM
		register. The result is stored in the low quadword of the destination operand and the high quadword is cleared to all 0s.
		
		When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
		register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid
		exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper bits
		(VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is a YMM register. The upper bits (VLMAX-1:64) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
		operation is an XMM register. The upper bits (255:128) of the corresponding YMM register destination are zeroed.
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtpd2pi/vcvtpd2pi=Convert Packed Double-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts two packed double-precision floating-point values in the source operand (second operand) to two packed
		signed doubleword integers in the destination operand (first operand).
		The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.
		
		When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
		register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid
		exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.
		This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
		pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
		floating-point exception is pending, the exception is handled before the CVTPD2PI instruction is executed.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cvtpd2ps/vcvtpd2ps=Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values 
	forms

	description
		Converts two packed double-precision floating-point values in the source operand (second operand) to two packed
		single-precision floating-point values in the destination operand (first operand).
		
		When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper bits
		(VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is a YMM register. The upper bits (VLMAX-1:64) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
		operation is an XMM register. The upper bits (255:128) of the corresponding YMM register destination are zeroed.
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtpi2pd=Convert Packed Dword Integers to Packed Double-Precision FP Values 
	forms

	description
		Converts two packed signed doubleword integers in the source operand (second operand) to two packed double-
		precision floating-point values in the destination operand (first operand).
		The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an
		XMM register. In addition, depending on the operand configuration:

		- For operands xmm, mm: the instruction causes a transition from x87 FPU to MMX technology operation (that
		is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this
		instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before
		the CVTPI2PD instruction is executed.
		
		- For operands xmm, m64: the instruction does not cause a transition to MMX technology and does not take
		x87 FPU exceptions.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cvtpi2ps=Convert Packed Dword Integers to Packed Single-Precision FP Values 
	forms

	description
		Converts two packed signed doubleword integers in the source operand (second operand) to two packed single-
		precision floating-point values in the destination operand (first operand).
		
		The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an
		XMM register. The results are stored in the low quadword of the destination operand, and the high quadword
		remains unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control
		bits in the MXCSR register.
		
		This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
		pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
		floating-point exception is pending, the exception is handled before the CVTPI2PS instruction is executed.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cvtps2dq/vcvtps2dq=Convert Packed Single-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts four or eight packed single-precision floating-point values in the source operand to four or eight signed
		doubleword integers in the destination operand.
		
		When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
		register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid
		exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is a YMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
		operation is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtps2pd/vcvtps2pd=Convert Packed Single-Precision FP Values to Packed Double-Precision FP Values 
	forms

	description
		Converts two or four packed single-precision floating-point values in the source operand (second operand) to two
		or four packed double-precision floating-point values in the destination operand (first operand).
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination
		operation is a YMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtps2pi=Convert Packed Single-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts two packed single-precision floating-point values in the source operand (second operand) to two packed
		signed doubleword integers in the destination operand (first operand).
		
		The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX tech-
		nology register. When the source operand is an XMM register, the two single-precision floating-point values are
		contained in the low quadword of the register. When a conversion is inexact, the value returned is rounded
		according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum
		signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indef-
		inite integer value (80000000H) is returned.
		
		CVTPS2PI causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer
		is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-
		point exception is pending, the exception is handled before the CVTPS2PI instruction is executed.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cvtsd2si/vcvtsd2si=Convert Scalar Double-Precision FP Value to Integer 
	forms

	description
		Converts a double-precision floating-point value in the source operand (second operand) to a signed doubleword
		integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory
		location. The destination operand is a general-purpose register. When the source operand is an XMM register, the
		double-precision floating-point value is contained in the low quadword of the register.
		When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.
		
		If a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode
		with REX.W/VEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite
		integer value (80000000H) is returned.
		
		If a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W = 1),
		the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value
		(8000000000000000H) is returned.
		
		Legacy SSE instructions: Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary
		chart at the beginning of this section for encoding data and limits.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtsd2ss/vcvtsd2ss=Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value 
	forms

	description
		Converts a double-precision floating-point value in the source operand (second operand) to a single-precision
		floating-point value in the destination operand (first operand).
		
		The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM
		register. When the source operand is an XMM register, the double-precision floating-point value is contained in the
		low quadword of the register. The result is stored in the low doubleword of the destination operand, and the upper
		3 doublewords are left unchanged. When the conversion is inexact, the value returned is rounded according to the
		rounding control bits in the MXCSR register.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:32) of the
		corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


cvtsi2sd/vcvtsi2sd=Convert Dword Integer to Scalar Double-Precision FP Value 
	forms

	description
		Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the second source
		operand to a double-precision floating-point value in the destination operand. The result is stored in the low quad-
		word of the destination operand, and the high quadword left unchanged. When conversion is inexact, the value
		returned is rounded according to the rounding control bits in the MXCSR register.
		
		Legacy SSE instructions: Use of the REX.W prefix promotes the instruction to 64-bit operands. See the summary
		chart at the beginning of this section for encoding data and limits.
		The second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and
		destination operands are XMM registers.
		
		128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:64) of the
		corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


cvtsi2ss/vcvtsi2ss=Convert Dword Integer to Scalar Single-Precision FP Value 
	forms

	description
		Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the source operand
		(second operand) to a single-precision floating-point value in the destination operand (first operand). The source
		operand can be a general-purpose register or a memory location. The destination operand is an XMM register. The
		result is stored in the low doubleword of the destination operand, and the upper three doublewords are left
		unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in
		the MXCSR register.
		
		Legacy SSE instructions: In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15)
		when used with a REX.R prefix. Use of the REX.W prefix promotes the instruction to 64-bit operands. See the
		summary chart at the beginning of this section for encoding data and limits.
		
		128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:32) of the
		corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:32) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


cvtss2sd/vcvtss2sd=Convert Scalar Single-Precision FP Value to Scalar Double-Precision FP Value 
	forms

	description
		Converts a single-precision floating-point value in the source operand (second operand) to a double-precision
		floating-point value in the destination operand (first operand). The source operand can be an XMM register or a 32-
		bit memory location. The destination operand is an XMM register. When the source operand is an XMM register, the
		single-precision floating-point value is contained in the low doubleword of the register. The result is stored in the
		low quadword of the destination operand, and the high quadword is left unchanged.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:64) of the
		corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


cvtss2si/vcvtss2si=Convert Scalar Single-Precision FP Value to Dword Integer 
	forms

	description
		Converts a single-precision floating-point value in the source operand (second operand) to a signed doubleword
		integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The
		source operand can be an XMM register or a memory location. The destination operand is a general-purpose
		register. When the source operand is an XMM register, the single-precision floating-point value is contained in the
		low doubleword of the register.
		
		When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
		register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid
		exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.
		In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R
		prefix. Use of the REX.W prefix promotes the instruction to 64-bit operands. See the summary chart at the begin-
		ning of this section for encoding data and limits.
		
		Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operands. See
		the summary chart at the beginning of this section for encoding data and limits.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvttpd2dq/vcvttpd2dq=Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts two or four packed double-precision floating-point values in the source operand (second operand) to two
		or four packed signed doubleword integers in the destination operand (first operand).
		When a conversion is inexact, a truncated (round toward zero) value is returned.If a converted result is larger than
		the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is
		masked, the indefinite integer value (80000000H) is returned.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is a YMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
		operation is an XMM register. The upper bits (255:128) of the corresponding YMM register destination are zeroed.
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvttpd2pi=Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts two packed double-precision floating-point values in the source operand (second operand) to two packed
		signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register
		or a 128-bit memory location. The destination operand is an MMX technology register.
		
		When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than
		the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is
		masked, the indefinite integer value (80000000H) is returned.
		
		This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
		pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
		floating-point exception is pending, the exception is handled before the CVTTPD2PI instruction is executed.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cvttps2dq/vcvttps2dq=Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts four or eight packed single-precision floating-point values in the source operand to four or eight signed
		doubleword integers in the destination operand.
		When a conversion is inexact, a truncated (round toward zero) value is returned.If a converted result is larger than
		the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is
		masked, the indefinite integer value (80000000H) is returned.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is a YMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
		operation is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvttps2pi=Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts two packed single-precision floating-point values in the source operand (second operand) to two packed
		signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register
		or a 64-bit memory location. The destination operand is an MMX technology register. When the source operand is
		an XMM register, the two single-precision floating-point values are contained in the low quadword of the register.
		When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger
		than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is
		masked, the indefinite integer value (80000000H) is returned.
		
		This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
		pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
		floating-point exception is pending, the exception is handled before the CVTTPS2PI instruction is executed.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cvttsd2si/vcvttsd2si=Convert with Truncation Scalar Double-Precision FP Value to Signed Integer 
	forms

	description
		Converts a double-precision floating-point value in the source operand (second operand) to a signed doubleword
		integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The
		source operand can be an XMM register or a 64-bit memory location. The destination operand is a general purpose
		register. When the source operand is an XMM register, the double-precision floating-point value is contained in the
		low quadword of the register.
		
		When a conversion is inexact, a truncated (round toward zero) result is returned.
		If a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode
		with REX.W/VEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite
		integer value (80000000H) is returned.
		
		If a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W = 1),
		the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value
		(8000000000000000H) is returned.
		
		Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See
		the summary chart at the beginning of this section for encoding data and limits.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvttss2si/vcvttss2si=Convert with Truncation Scalar Single-Precision FP Value to Dword Integer 
	forms

	description
		Converts a single-precision floating-point value in the source operand (second operand) to a signed doubleword
		integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The
		source operand can be an XMM register or a 32-bit memory location. The destination operand is a general-purpose
		register. When the source operand is an XMM register, the single-precision floating-point value is contained in the
		low doubleword of the register.
		
		When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than
		the maximum signed doubleword integer, the floating-point invalid exception is raised. If this exception is masked,
		the indefinite integer value (80000000H) is returned.
		
		Legacy SSE instructions: In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15)
		when used with a REX.R prefix. Use of the REX.W prefix promotes the instruction to 64-bit operation. See the
		summary chart at the beginning of this section for encoding data and limits.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cwd=Convert Word to Doubleword
cdq=Convert Doubleword to Quadword
cqo=Convert Quadword to Octword
	forms

	description
		Doubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign
		extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction
		copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction
		copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruc-
		tion (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position
		in the RDX register.
		
		The CWD instruction can be used to produce a doubleword dividend from a word before word division. The CDQ
		instruction can be used to produce a quadword dividend from a doubleword before doubleword division. The CQO
		instruction can be used to produce a double quadword dividend from a quadword before a quadword division.
		The CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the
		operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers
		may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these
		mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the
		size of values to be converted, regardless of the mnemonic used.
		
		In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same
		opcode as CWD/CDQ. See the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


daa=Decimal Adjust AL after Addition 
	forms

	description
		Adjusts the sum of two packed BCD values to create a packed BCD result. The AL register is the implied source and
		destination operand. The DAA instruction is only useful when it follows an ADD instruction that adds (binary addi-
		tion) two 2-digit, packed BCD values and stores a byte result in the AL register. The DAA instruction then adjusts
		the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal carry is detected, the
		CF and AF flags are set accordingly.
		
		This instruction executes as described above in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


das=Decimal Adjust AL after Subtraction 
	forms

	description
		Adjusts the result of the subtraction of two packed BCD values to create a packed BCD result. The AL register is the
		implied source and destination operand. The DAS instruction is only useful when it follows a SUB instruction that
		subtracts (binary subtraction) one 2-digit, packed BCD value from another and stores a byte result in the AL register.
		The DAS instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result.
		If a decimal borrow is detected, the CF and AF flags are set accordingly.
		
		This instruction executes as described above in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


dec=Decrement by 1
	forms

	description
		Subtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be
		a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag.
		(To perform a decrement operation that updates the CF flag, use a SUB instruction with an immediate operand of 1.)
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		
		In 64-bit mode, DEC r16 and DEC r32 are not encodable (because opcodes 48H through 4FH are REX prefixes).
		
		Otherwise, the instruction's 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to
		additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.
		See the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


div=Unsigned Divide 
	forms

	description
		Divides unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers (dividend) by the source operand
		(divisor) and stores the result in the AX (AH:AL), DX:AX, EDX:EAX, or RDX:RAX registers. The source operand can
		be a general-purpose register or a memory location. The action of this instruction depends on the operand size
		(dividend/divisor). Division using 64-bit operand is available only in 64-bit mode.
		
		Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude.
		Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional 
		registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied,
		the instruction divides the unsigned value in RDX:RAX by the source operand and stores the quotient in RAX, the remainder in RDX.

	exceptions

	flags

	operation

	meta


divpd/vdivpd=Divide Packed Double-Precision Floating-Point Values 
	forms

	description
		Performs an SIMD divide of the two or four packed double-precision floating-point values in the first source operand
		by the two or four packed double-precision floating-point values in the second source operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


divps/vdivps=Divide Packed Single-Precision Floating-Point Values
	forms

	description
		Performs an SIMD divide of the four or eight packed single-precision floating-point values in the first source
		operand by the four or eight packed single-precision floating-point values in the second source operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


divsd/vdivsd=Divide Scalar Double-Precision Floating-Point Values
	forms

	description
		Divides the low double-precision floating-point value in the first source operand by the low double-precision
		floating-point value in the second source operand, and stores the double-precision floating-point result in the desti-
		nation operand. The second source operand can be an XMM register or a 64-bit memory location. The first source
		and destination hyperons are XMM registers. The high quadword of the destination operand is copied from the high
		quadword of the first source operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
		1:64) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


divss/vdivss=Divide Scalar Single-Precision Floating-Point Values 
	forms

	description
		Divides the low single-precision floating-point value in the first source operand by the low single-precision floating-
		point value in the second source operand, and stores the single-precision floating-point result in the destination
		operand. The second source operand can be an XMM register or a 32-bit memory location. The first source and
		destination operands are XMM registers. The three high-order doublewords of the destination are copied from the
		same dwords of the first source operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
		1:32) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


dppd/vdppd=Dot Product of Packed Double Precision Floating-Point Values 
	forms

	description
		Conditionally multiplies the packed double-precision floating-point values in the destination operand (first operand)
		with the packed double-precision floating-point values in the source (second operand) depending on a mask
		extracted from bits [5:4] of the immediate operand (third operand). If a condition mask bit is zero, the corre-
		sponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1.
		
		The two resulting double-precision values are summed into an intermediate result. The intermediate result is
		conditionally broadcasted to the destination using a broadcast mask specified by bits [1:0] of the immediate byte.
		If a broadcast mask bit is "1", the intermediate result is copied to the corresponding qword element in the destina-
		tion operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.
		DPPD follows the NaN forwarding rules stated in the Software Developer's Manual, vol. 1, table 4.7. These rules do
		not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of
		those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally gener-
		ated NaNs will have at least one NaN propagated to the destination.
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		If VDPPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an
		#UD exception.

	exceptions

	flags

	operation

	meta


dpps/vdpps=Dot Product of Packed Single Precision Floating-Point Values 
	forms

	description
		Conditionally multiplies the packed single precision floating-point values in the destination operand (first operand)
		with the packed single-precision floats in the source (second operand) depending on a mask extracted from the
		high 4 bits of the immediate byte (third operand). If a condition mask bit in Imm8[7:4] is zero, the corresponding
		multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel 64 and IA-32 Archi-
		tectures Software Developer's Manual, Volume 1.
		
		The four resulting single-precision values are summed into an intermediate result. The intermediate result is condi-
		tionally broadcasted to the destination using a broadcast mask specified by bits [3:0] of the immediate byte.
		If a broadcast mask bit is "1", the intermediate result is copied to the corresponding dword element in the destina-
		tion operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.
		DPPS follows the NaN forwarding rules stated in the Software Developer's Manual, vol. 1, table 4.7. These rules do
		not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of
		those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally gener-
		ated NaNs will have at least one NaN propagated to the destination.
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


emms=Empty MMX Technology State 
	forms

	description
		Sets the values of all the tags in the x87 FPU tag word to empty (all 1s). This operation marks the x87 FPU data
		registers (which are aliased to the MMX technology registers) as available for use by x87 FPU floating-point instructions. 
		All other MMX instructions (other than the EMMS instruction) set all the tags in x87 FPU tag word to valid (all 0s).
		
		The EMMS instruction must be used to clear the MMX technology state at the end of all MMX technology procedures
		or subroutines and before calling other procedures or subroutines that may execute x87 floating-point instructions.
		If a floating-point instruction loads one of the registers in the x87 FPU data register stack before the x87 FPU tag
		word has been reset by the EMMS instruction, an x87 floating-point register stack overflow can occur that will
		result in an x87 floating-point exception or incorrect result.
		
		EMMS operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


enter=Make Stack Frame for Procedure Parameters 
	forms

	description
		Creates a stack frame for a procedure. The first operand (size operand) specifies the size of the stack frame (that
		is, the number of bytes of dynamic storage allocated on the stack for the procedure). The second operand (nesting
		level operand) gives the lexical nesting level (0 to 31) of the procedure. The nesting level determines the number
		of stack frame pointers that are copied into the "display area" of the new stack frame from the preceding frame.
		Both of these operands are immediate values.
		
		The stack-size attribute determines whether the BP (16 bits), EBP (32 bits), or RBP (64 bits) register specifies the
		current frame pointer and whether SP (16 bits), ESP (32 bits), or RSP (64 bits) specifies the stack pointer. In 64-bit mode, 
		stack-size attribute is always 64-bits.
		
		The ENTER and companion LEAVE instructions are provided to support block structured languages. The ENTER
		instruction (when used) is typically the first instruction in a procedure and is used to set up a new stack frame for
		a procedure. The LEAVE instruction is then used at the end of the procedure (just before the RET instruction) to
		release the stack frame.
		
		If the nesting level is 0, the processor pushes the frame pointer from the BP/EBP/RBP register onto the stack,
		copies the current stack pointer from the SP/ESP/RSP register into the BP/EBP/RBP register, and loads the
		SP/ESP/RSP register with the current stack-pointer value minus the value in the size operand. For nesting levels of
		1 or greater, the processor pushes additional frame pointers on the stack before adjusting the stack pointer. These
		additional frame pointers provide the called procedure with access points to other nested frames on the stack. See
		"Procedure Calls for Block-Structured Languages" in Chapter 6 of the Intel 64 and IA-32 Architectures Software
		Developer's Manual, Volume 1, for more information about the actions of the ENTER instruction.
		The ENTER instruction causes a page fault whenever a write using the final value of the stack pointer (within the
		current stack segment) would do so.
		
		In 64-bit mode, default operation size is 64 bits; 32-bit operation size cannot be encoded.

	exceptions

	flags

	operation

	meta


extractps/vextractps=Extract Packed Single Precision Floating-Point Value
	forms

	description
		Extracts a single-precision floating-point value from the source operand (second operand) at the 32-bit offset specified from imm8. 
		Immediate bits higher than the most significant offset for the vector length are ignored.
		The extracted single-precision floating-point value is stored in the low 32-bits of the destination operand
		In 64-bit mode, destination register operand has default operand size of 64 bits. The upper 32-bits of the register
		are filled with zero. REX.W is ignored.
		
		128-bit Legacy SSE version: When a REX.W prefix is used in 64-bit mode with a general purpose register (GPR) as
		a destination operand, the packed single quantity is zero extended to 64 bits.
		
		VEX.128 encoded version: When VEX.128.66.0F3A.W1 17 form is used in 64-bit mode with a general purpose
		register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits. VEX.vvvv is
		reserved and must be 1111b otherwise instructions will #UD.
		
		The source register is an XMM register. Imm8[1:0] determine the starting DWORD offset from which to extract the
		32-bit floating-point value.
		
		If VEXTRACTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause
		an #UD exception.

	exceptions

	flags

	operation

	meta


f2xm1=Compute 2^^x-1 
	forms

	description
		Computes the exponential value of 2 to the power of the source operand minus 1. The source operand is located in
		register ST(0) and the result is also stored in ST(0). The value of the source operand must lie in the range -1.0 to
		+1.0. If the source value is outside this range, the result is undefined.

	exceptions

	flags

	operation

	meta


fabs=Absolute Value 
	forms

	description
		Clears the sign bit of ST(0) to create the absolute value of the operand.

	exceptions

	flags

	operation

	meta


fadd/faddp/fiadd=Add Floating-Point Values
	forms

	description
		Adds the destination and source operands and stores the sum in the destination location. The destination operand
		is always an FPU register; the source operand can be a register or a memory location. Source operands in memory
		can be in single-precision or double-precision floating-point format or in word or doubleword integer format.
		The no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-
		operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents
		of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice
		versa. The value in ST(0) can be doubled by coding:
		
		FADD ST(0), ST(0);
		
		The FADDP instructions perform the additional operation of popping the FPU register stack after storing the result.
		To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
		by 1. (The no-operand version of the floating-point add instructions always results in the register stack being
		popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)
		
		The FIADD instructions convert an integer source operand to double extended-precision floating-point format
		before performing the addition.
		
		When the sum of two operands with opposite signs is 0, the result is +0, except for the round toward -infinity mode, in
		which case the result is -0. When the source operand is an integer 0, it is treated as a +0.
		When both operand are infinities of the same sign, the result is infinity of the expected sign. 
		If both operands are infinities of opposite signs, an invalid-operation exception is generated. 

	exceptions

	flags

	operation

	meta


fbld=Load Binary Coded Decimal 
	forms

	description
		Converts the BCD source operand into double extended-precision floating-point format and pushes the value onto
		the FPU stack. The source operand is loaded without rounding errors. The sign of the source operand is preserved,
		including that of -0.
		
		The packed BCD digits are assumed to be in the range 0 through 9; the instruction does not check for invalid digits
		(AH through FH). Attempting to load an invalid encoding produces an undefined result.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fbstp=Store BCD Integer and Pop 
	forms

	description
		Converts the value in the ST(0) register to an 18-digit packed BCD integer, stores the result in the destination
		operand, and pops the register stack. If the source value is a non-integral value, it is rounded to an integer value,
		according to rounding mode specified by the RC field of the FPU control word. To pop the register stack, the
		processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
		
		The destination operand specifies the address where the first byte destination value is to be stored. The BCD value
		(including its sign bit) requires 10 bytes of space in memory.
		
		If the converted value is too large for the destination format, or if the source operand is an infinity, SNaN, QNAN, or is in
		an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is
		not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination
		operand. If the invalid-operation exception is masked, the packed BCD indefinite value is stored in memory.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fchs=Change Sign 
	forms

	description
		Complements the sign bit of ST(0). This operation changes a positive value into a negative value of equal magnitude or vice versa.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fclex/fnclex=Clear Exceptions 
	forms

	description
		Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception summary status flag (ES), the
		stack fault flag (SF), and the busy flag (B) in the FPU status word. The FCLEX instruction checks for and handles
		any pending unmasked floating-point exceptions before clearing the exception flags; the FNCLEX instruction does
		not.
		
		The assembler issues two instructions for the FCLEX instruction (an FWAIT instruction followed by an FNCLEX
		instruction), and the processor executes each of these instructions separately. If an exception is generated for
		either of these instructions, the save EIP points to the instruction that caused the exception.
		
		When operating a Pentium or Intel486 processor in MS-DOS* compatibility mode, it is possible (under unusual
		circumstances) for an FNCLEX instruction to be interrupted prior to being executed to handle a pending FPU excep-
		tion. See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the Intel
		64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a description of these circumstances. An
		FNCLEX instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.
		This instruction affects only the x87 FPU floating-point exception flags. It does not affect the SIMD floating-point
		exception flags in the MXCRS register.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fcmovb=Floating-Point Move If Below
fcmove=Floating-Point Move If Equal
fcmovbe=Floating-Point Move If Below Or Equal
fcmovu=Floating-Point Move If Unordered
fcmovnb=Floating-Point Move If Not Below
fcmovne=Floating-Point Move If Not Equal
fcmovnbe=Floating-Point Move If Not Below Or Equal
fcmovnu=Floating-Point Move If Not Unordered
	forms

	description
		Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
		operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
		tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1.
		The source operand is always in the ST(i) register and the destination operand is always ST(0).
		
		The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
		overhead for IF operations and the possibility of branch mispredictions by the processor.
		A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
		supported by checking the processor's feature information with the CPUID instruction. If both the CMOV and FPU
		feature bits are set, the FCMOVcc instructions are supported.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fcom/fcomp/fcompp=Compare Floating Point Values 
	forms

	description
		Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU
		status word according to the results. The source operand can be a data register or a memory
		location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is
		ignored, so that -0.0 is equal to +0.0.
		
		This instruction checks the class of the numbers being compared (see "FXAM-Examine ModR/M" in this chapter).
		If either operand is a NaN or is in an unsupported format, an invalid-arithmetic-operand exception (#IA) is raised
		and, if the exception is masked, the condition flags are set to "unordered." 
		If the invalid-arithmetic-operand exception is unmasked, the condition code flags are not set.
		
		The FCOMP instruction pops the register stack following the comparison operation and the FCOMPP instruction
		pops the register stack twice following the comparison operation. To pop the register stack, the processor marks
		the ST(0) register as empty and increments the stack pointer (TOP) by 1.
		
		The FCOM instructions perform the same operation as the FUCOM instructions. The only difference is how they
		handle QNaN operands. The FCOM instructions raise an invalid-arithmetic-operand exception (#IA) when either or
		both of the operands is a NaN value or is in an unsupported format. The FUCOM instructions perform the same
		operation as the FCOM instructions, except that they do not generate an invalid-arithmetic-operand exception for
		QNaNs.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fcomi/fcomip/fucomi/fucomip=Compare Floating Point Values and Set EFLAGS
	forms

	description
		Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and
		CF in the EFLAGS register according to the results. The sign of zero is ignored for comparisons, so that -0.0 is equal to +0.0.
		
		An unordered comparison checks the class of the numbers being compared (see "FXAM-Examine ModR/M" in this
		chapter). The FUCOMI/FUCOMIP instructions perform the same operations as the FCOMI/FCOMIP instructions. The
		only difference is that the FUCOMI/FUCOMIP instructions raise the invalid-arithmetic-operand exception (#IA) only
		when either or both operands are an SNaN or are in an unsupported format; QNaNs cause the condition code flags
		to be set to unordered, but do not cause an exception to be generated. The FCOMI/FCOMIP instructions raise an
		invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format.
		
		If the operation results in an invalid-arithmetic-operand exception being raised, the status flags in the EFLAGS
		register are set only if the exception is masked.
		
		The FCOMI/FCOMIP and FUCOMI/FUCOMIP instructions set the OF, SF and AF flags to zero in the EFLAGS register
		(regardless of whether an invalid-operation exception is detected).
		
		The FCOMIP and FUCOMIP instructions also pop the register stack following the comparison operation. To pop the
		register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fcos= Cosine 
	forms

	description
		Computes the approximate cosine of the source operand in register ST(0) and stores the result in ST(0). The
		source operand must be given in radians and must be within the range -2^^63 to +2^^63.
		
		If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in
		register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of
		range. It is up to the program to check the C2 flag for out-of-range conditions.
		Source values outside the range -2^^63 to +2^^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2*PI.
		
		However, even within the range -2^^63 to +2^^63, inaccurate results can occur because the finite approximation of PI
		used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply
		FCOS only to arguments reduced accurately in software, to a value smaller in absolute value than 3*PI/8. See the
		sections titled "Approximation of Pi" and "Transcendental Instruction Accuracy" in Chapter 8 of the Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1, for a discussion of the proper value to use for PI in performing such reductions.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fdecstp=Decrement Stack-Top Pointer
	forms

	description
		Subtracts one from the TOP field of the FPU status word (decrements the top-of-stack pointer). If the TOP field
		contains a 0, it is set to 7. The effect of this instruction is to rotate the stack by one position. The contents of the
		FPU data registers and tag register are not affected.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fdiv/fdivp/fidiv=Divide 
	forms

	description
		Divides the destination operand by the source operand and stores the result in the destination location.
		The destination operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory
		location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.
		
		The no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0)
		register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location
		(either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by
		the contents of the ST(i) register or vice versa.
		
		The FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result.
		To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
		by 1. The no-operand version of the floating-point divide instructions always results in the register stack being
		popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.
		
		The FIDIV instructions convert an integer source operand to double extended-precision floating-point format
		before performing the division. When the source operand is an integer 0, it is treated as a +0.
		
		If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an infinity of
		the appropriate sign is stored in the destination operand.
		
		The following table shows the results obtained when dividing various classes of numbers, assuming that neither
		overflow nor underflow occurs.

	exceptions

	flags

	operation

	meta


fdivr/fdivrp/fidivr=Reverse Divide 
	forms

	description
		Divides the source operand by the destination operand and stores the result in the destination location.
		The destination operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory
		location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.
		
		These instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to
		support more efficient coding.
		
		The no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1)
		register. The one-operand version divides the contents of a memory location (either a floating-point or an integer
		value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by
		the contents of the ST(0) register or vice versa.
		
		The FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result.
		To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
		by 1. The no-operand version of the floating-point divide instructions always results in the register stack being
		popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.
		
		The FIDIVR instructions convert an integer source operand to double extended-precision floating-point format
		before performing the division.
		
		If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an infinity of
		the appropriate sign is stored in the destination operand.
		
		The following table shows the results obtained when dividing various classes of numbers, assuming that neither
		overflow nor underflow occurs.

	exceptions

	flags

	operation

	meta


ffree=Free Floating-Point Register 
	forms

	description
		Sets the tag in the FPU tag register associated with register ST(i) to empty (11B). The contents of ST(i) and the FPU
		stack-top pointer (TOP) are not affected.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


ficom/ficomp=Compare Integer
	forms

	description
		Compares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in
		the FPU status word according to the results. 
		The integer value is converted to double extended-precision floating-point format before the comparison is made.
		
		These instructions perform an "unordered comparison." An unordered comparison also checks the class of the
		numbers being compared. If either operand is a NaN or is in an undefined format, the condition flags are set to "unordered."
		The sign of zero is ignored, so that -0.0 to +0.0.
		
		The FICOMP instructions pop the register stack following the comparison. To pop the register stack, the processor
		marks the ST(0) register empty and increments the stack pointer (TOP) by 1.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.


	exceptions

	flags

	operation

	meta


fild=Load Integer 
	forms

	description
		Converts the signed-integer source operand into double extended-precision floating-point format and pushes the
		value onto the FPU register stack. The source operand can be a word, doubleword, or quadword integer. It is loaded
		without rounding errors. The sign of the source operand is preserved.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fincstp=Increment Stack-Top Pointer 
	forms

	description
		Adds one to the TOP field of the FPU status word (increments the top-of-stack pointer). If the TOP field contains a
		7, it is set to 0. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data
		registers and tag register are not affected. This operation is not equivalent to popping the stack, because the tag
		for the previous top-of-stack register is not marked empty.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


finit/fninit=Initialize Floating-Point Unit 
	forms

	description
		Sets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU
		control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared
		(no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all
		tagged as empty (11B). Both the instruction and data pointers are cleared.
		
		The FINIT instruction checks for and handles any pending unmasked floating-point exceptions before performing the initialization; the FNINIT instruction does not.
		
		The assembler issues two instructions for the FINIT instruction (an FWAIT instruction followed by an FNINIT instruction),
		and the processor executes each of these instructions in separately. If an exception is generated for
		either of these instructions, the save EIP points to the instruction that caused the exception.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.
		
		When operating a Pentium or Intel 486 processor in MS-DOS compatibility mode, it is possible (under unusual
		circumstances) for an FNINIT instruction to be interrupted prior to being executed to handle a pending FPU exception. 
		See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the Intel
		64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a description of these circumstances. An
		FNINIT instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.
		In the Intel 387 math co-processor, the FINIT/FNINIT instruction does not clear the instruction and data pointers.
		This instruction affects only the x87 FPU. It does not affect the XMM and MXCSR registers.

	exceptions

	flags

	operation

	meta


fist/fistp=Store Integer 
	forms

	description
		The FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the destination operand.
		Values can be stored in word or doubleword integer format.
		The destination operand specifies the address where the first byte of the destination value is to be stored.
		
		The FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop
		the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
		The FISTP instruction also stores values in quadword integer format.
		
		If the source value is a non-integral value, it is rounded to an integer value, according to the rounding mode spec-
		ified by the RC field of the FPU control word.
		
		If the converted value is too large for the destination format, or if the source operand is an infinity, SNaN, QNAN, or is in
		an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is
		not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination
		operand. If the invalid-operation exception is masked, the integer indefinite value is stored in memory.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fisttp=Store Integer with Truncation 
	forms

	description
		FISTTP converts the value in ST into a signed integer using truncation (chop) as rounding mode, transfers the
		result to the destination, and pop ST. FISTTP accepts word, short integer, and long integer destinations.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fld=Load Floating Point Value
	forms

	description
		Pushes the source operand onto the FPU register stack. The source operand can be in single-precision, double-
		precision, or double extended-precision floating-point format. If the source operand is in single-precision or
		double-precision floating-point format, it is automatically converted to the double extended-precision floating-
		point format before being pushed on the stack.
		
		The FLD instruction can also push the value in a selected FPU register [ST(i)] onto the stack. Here, pushing register ST(0) duplicates the stack top.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fld1=Push +1.0 onto the FPU register stack
fldl2t=Push log2(10) onto the FPU register stack
fldl2e=Push log2(e) onto the FPU register stack
fldpi=Push PI onto the FPU register stack
fldlg2=Push log10(2) onto the FPU register stack
fldln2=Push ln(2) onto the FPU register stack
fldz=Push +0.0 onto the FPU register stack
	forms

	description
		Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU
		register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log2(10), log2(e), PI, log10(2),
		and ln(2). For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control
		word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a
		result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.
		
		When the RC field is set to round-to-nearest, the FPU produces the same constants that is produced by the Intel 8087 and Intel 287 math co-processors.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fldcw=Load x87 FPU Control Word 
	forms

	description
		Loads the 16-bit source operand into the FPU control word. The source operand is a memory location. This instruc-
		tion is typically used to establish or change the FPU's mode of operation.
		
		If one or more exception flags are set in the FPU status word prior to loading a new FPU control word and the new
		control word unmasks one or more of those exceptions, a floating-point exception will be generated upon execution
		of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled "Soft-
		ware Exception Handling" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Developer's Manual,
		Volume 1). To avoid raising exceptions when changing FPU operating modes, clear any pending exceptions (using
		the FCLEX or FNCLEX instruction) before loading the new control word.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fldenv=Load x87 FPU Environment
	forms

	description
		Loads the complete x87 FPU operating environment from memory into the FPU registers. The source operand spec-
		ifies the first byte of the operating-environment data in memory. This data is typically written to the specified
		memory location by a FSTENV or FNSTENV instruction.
		
		The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data
		pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and IA-32 Architectures Software Developer's
		Manual, Volume 1, show the layout in memory of the loaded environment, depending on the operating mode of the
		processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the
		real mode layouts are used.
		
		The FLDENV instruction should be executed in the same operating mode as the corresponding FSTENV/FNSTENV instruction.
		
		If one or more unmasked exception flags are set in the new FPU status word, a floating-point exception will be
		generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions,
		see the section titled "Software Exception Handling" in Chapter 8 of the Intel 64 and IA-32 Architectures Soft-
		ware Developer's Manual, Volume 1). To avoid generating exceptions when loading a new environment, clear all
		the exception flags in the FPU status word that is being loaded.
		
		If a page or limit fault occurs during the execution of this instruction, the state of the x87 FPU registers as seen by
		the fault handler may be different than the state being loaded from memory. In such situations, the fault handler
		should ignore the status of the x87 FPU registers, handle the fault, and return. The FLDENV instruction will then
		complete the loading of the x87 FPU registers with no resulting context inconsistency.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fmul/fmulp/fimul=Multiply
	forms

	description
		Multiplies the destination and source operands and stores the product in the destination location. The destination
		operand is always an FPU data register; the source operand can be an FPU data register or a memory location.
		Source operands in memory can be in single-precision or double-precision floating-point format or in word or
		doubleword integer format.
		
		The no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0)
		register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0)
		register by the contents of a memory location (either a floating point or an integer value) and stores the product in
		the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the
		ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the desti-
		nation operand).
		
		The FMULP instructions perform the additional operation of popping the FPU register stack after storing the
		product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack
		pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register
		stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP.
		
		The FIMUL instructions convert an integer source operand to double extended- precision floating-point format before performing the multiplication.
		The sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multi-
		plied is 0 or infinity. When the source operand is an integer 0, it is treated as a +0.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fnop=No Operation
	forms

	description
		Performs no FPU operation. This instruction takes up space in the instruction stream but does not affect the FPU or
		machine context, except the EIP register and the FPU Instruction Pointer.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fpatan=Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack
	forms

	description
		Computes the arctangent of the source operand in register ST(1) divided by the source operand in register ST(0),
		stores the result in ST(1), and pops the FPU register stack. The result in register ST(0) has the same sign as the
		source operand ST(1) and a magnitude less than +PI.
		
		The FPATAN instruction returns the angle between the X axis and the line from the origin to the point (X,Y), where
		Y (the ordinate) is ST(1) and X (the abscissa) is ST(0). The angle depends on the sign of X and Y independently,
		not just on the sign of the ratio Y/X. This is because a point (-X,Y) is in the second quadrant, resulting in an angle
		between PI/2 and PI, while a point (X,-Y) is in the fourth quadrant, resulting in an angle between 0 and -PI/2. A point
		(-X,-Y) is in the third quadrant, giving an angle between -PI/2 and -PI.
		There is no restriction on the range of source operands that FPATAN can accept (except as listed below).
		
		The source operands for this instruction are restricted for the 80287 math co-processor to the following range: 0 <= |ST(1)| < |ST(0)| < +infinity
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fprem=Partial Remainder 
	forms

	description
		Computes the remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the
		ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value:
		
		Remainder = ST(0) - (Q * ST(1))
		
		Here, Q is an integer value that is obtained by truncating the floating-point number quotient of [ST(0) / ST(1)]
		toward zero. The sign of the remainder is the same as the sign of the dividend. The magnitude of the remainder is
		less than that of the modulus, unless a partial remainder was computed (as described below).
		This instruction produces an exact result; the inexact-result exception does not occur and the rounding control has
		no effect.
		
		When the result is 0, its sign is the same as that of the dividend. When the modulus is infinity, the result is equal to the value in ST(0).
		
		The FPREM instruction does not compute the remainder specified in IEEE Std 754. The IEEE specified remainder
		can be computed with the FPREM1 instruction. The FPREM instruction is provided for compatibility with the Intel
		8087 and Intel 287 math co-processors.
		
		The FPREM instruction gets its name "partial remainder" because of the way it computes the remainder. This
		instruction arrives at a remainder through iterative subtraction. It can, however, reduce the exponent of ST(0) by
		no more than 63 in one execution of the instruction. If the instruction succeeds in producing a remainder that is
		less than the modulus, the operation is complete and the C2 flag in the FPU status word is cleared. Otherwise, C2
		is set, and the result in ST(0) is called the partial remainder. The exponent of the partial remainder will be less
		than the exponent of the original dividend by at least 32. Software can re-execute the instruction (using the partial
		remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing such a remainder-computation
		loop, a higher-priority interrupting routine that needs the FPU can force a context switch in-between the instructions in the loop.)
		
		An important use of the FPREM instruction is to reduce the arguments of periodic functions. When reduction is
		complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU
		status word. This information is important in argument reduction for the tangent function (using a modulus of PI/4),
		because it locates the original angle in the correct one of eight sectors of the unit circle.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fprem1=Partial Remainder
	forms

	description
		Computes the IEEE remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in
		the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value:
		
		Remainder = ST(0) - (Q * ST(1))
		
		Here, Q is an integer value that is obtained by rounding the floating-point number quotient of [ST(0) / ST(1)]
		toward the nearest integer value. The magnitude of the remainder is less than or equal to half the magnitude of the
		modulus, unless a partial remainder was computed (as described below).
		
		This instruction produces an exact result; the precision (inexact) exception does not occur and the rounding control
		has no effect.
		
		When the result is 0, its sign is the same as that of the dividend. When the modulus is infinity, the result is equal to the
		value in ST(0).
		
		The FPREM1 instruction computes the remainder specified in IEEE Standard 754. This instruction operates differ-
		ently from the FPREM instruction in the way that it rounds the quotient of ST(0) divided by ST(1) to an integer (see
		the "Operation" section below).
		
		Like the FPREM instruction, FPREM1 computes the remainder through iterative subtraction, but can reduce the
		exponent of ST(0) by no more than 63 in one execution of the instruction. If the instruction succeeds in producing
		a remainder that is less than one half the modulus, the operation is complete and the C2 flag in the FPU status word
		is cleared. Otherwise, C2 is set, and the result in ST(0) is called the partial remainder. The exponent of the partial
		remainder will be less than the exponent of the original dividend by at least 32. Software can re-execute the
		instruction (using the partial remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing
		such a remainder-computation loop, a higher-priority interrupting routine that needs the FPU can force a context
		switch in-between the instructions in the loop.)
		
		An important use of the FPREM1 instruction is to reduce the arguments of periodic functions. When reduction is
		complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU
		status word. This information is important in argument reduction for the tangent function (using a modulus of PI/4),
		because it locates the original angle in the correct one of eight sectors of the unit circle.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fptan=Partial Tangent 
	forms

	description
		Computes the approximate tangent of the source operand in register ST(0), stores the result in ST(0), and pushes
		a 1.0 onto the FPU register stack. The source operand must be given in radians and must be less than +-2^^63.
		
		If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in
		register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of
		range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the 
		range -2^^63 to +2^^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2*PI.
		However, even within the range -2^^63 to +2^^63, inaccurate results can occur because the finite approximation of PI
		used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply
		FPTAN only to arguments reduced accurately in software, to a value smaller in absolute value than 3*PI/8. See the
		sections titled "Approximation of Pi" and "Transcendental Instruction Accuracy" in Chapter 8 of the Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1, for a discussion of the proper value to use for PI in performing such reductions.
		
		The value 1.0 is pushed onto the register stack after the tangent has been computed to maintain compatibility with
		the Intel 8087 and Intel 287 math co-processors. This operation also simplifies the calculation of other trigonometric
		functions. For instance, the cotangent (which is the reciprocal of the tangent) can be computed by executing a
		FDIVR instruction after the FPTAN instruction.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


frndint=Round to Integer 
	forms

	description
		Rounds the source value in the ST(0) register to the nearest integral value, depending on the current rounding
		mode (setting of the RC field of the FPU control word), and stores the result in ST(0).
		If the source value is infinity, the value is not changed. If the source value is not an integral value, the floating-point
		inexact-result exception (#P) is generated.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


frstor=Restore x87 FPU State
	forms

	description
		Loads the FPU state (operating environment and register stack) from the memory area specified with the source
		operand. This state data is typically written to the specified memory location by a previous FSAVE/FNSAVE instruction.
		
		The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data
		pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and IA-32 Architectures Software Developer's
		Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the
		processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the
		real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately following
		the operating environment image.
		
		The FRSTOR instruction should be executed in the same operating mode as the corresponding FSAVE/FNSAVE
		instruction.
		
		If one or more unmasked exception bits are set in the new FPU status word, a floating-point exception will be
		generated. To avoid raising exceptions when loading a new operating environment, clear all the exception flags in
		the FPU status word that is being loaded.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fsave/fnsave=Store x87 FPU State
	forms

	description
		Stores the current FPU state (operating environment and register stack) at the specified destination in memory,
		and then re-initializes the FPU. The FSAVE instruction checks for and handles pending unmasked floating-point
		exceptions before storing the FPU state; the FNSAVE instruction does not.
		
		The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data
		pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and IA-32 Architectures Software Developer's
		Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the
		processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the
		real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately follow
		the operating environment image.
		
		The saved image reflects the state of the FPU after all floating-point instructions preceding the FSAVE/FNSAVE
		instruction in the instruction stream have been executed.
		
		After the FPU state has been saved, the FPU is reset to the same default values it is set to with the FINIT/FNINIT
		instructions (see "FINIT/FNINIT-Initialize Floating-Point Unit" in this chapter).
		The FSAVE/FNSAVE instructions are typically used when the operating system needs to perform a context switch,
		an exception handler needs to use the FPU, or an application program needs to pass a "clean" FPU to a procedure.
		The assembler issues two instructions for the FSAVE instruction (an FWAIT instruction followed by an FNSAVE
		instruction), and the processor executes each of these instructions separately. If an exception is generated for
		either of these instructions, the save EIP points to the instruction that caused the exception.
		
		For Intel math coprocessors and FPUs prior to the Intel Pentium processor, an FWAIT instruction should be
		executed before attempting to read from the memory image stored with a prior FSAVE/FNSAVE instruction. This
		FWAIT instruction helps ensure that the storage operation has been completed.
		When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual
		circumstances) for an FNSAVE instruction to be interrupted prior to being executed to handle a pending FPU excep-
		tion. See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the Intel
		64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a description of these circumstances. An
		FNSAVE instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fscale=Floating-point scale ST(0) by ST(1) 
	forms

	description
		Truncates the value in the source operand (toward 0) to an integral value and adds that value to the exponent of
		the destination operand. The destination and source operands are floating-point values located in registers ST(0)
		and ST(1), respectively. This instruction provides rapid multiplication or division by integral powers of 2.
		In most cases, only the exponent is changed and the mantissa (significand) remains unchanged. However, when
		the value being scaled in ST(0) is a denormal value, the mantissa is also changed and the result may turn out to be
		a normalized number. Similarly, if overflow or underflow results from a scale operation, the resulting mantissa will
		differ from the source's mantissa.
		
		The FSCALE instruction can also be used to reverse the action of the FXTRACT instruction, as shown in the following example:
		
		FXTRACT;
		FSCALE;
		FSTP ST(1);
		
		In this example, the FXTRACT instruction extracts the significand and exponent from the value in ST(0) and stores
		them in ST(0) and ST(1) respectively. The FSCALE then scales the significand in ST(0) by the exponent in ST(1),
		recreating the original value before the FXTRACT operation was performed. The FSTP ST(1) instruction overwrites
		the exponent (extracted by the FXTRACT instruction) with the recreated value, which returns the stack to its orig-
		inal state with only one register [ST(0)] occupied.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fsin=Sine 
	forms

	description
		Computes an approximation of the sine of the source operand in register ST(0) and stores the result in ST(0). The
		source operand must be given in radians and must be within the range -2^^63 to +2^^63.
		
		If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in
		register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of
		range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range -
		263 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2*PI.
		However, even within the range -2^^63 to +2^^63, inaccurate results can occur because the finite approximation of PI
		used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply
		FSIN only to arguments reduced accurately in software, to a value smaller in absolute value than 3*PI/4. See the
		sections titled "Approximation of Pi" and "Transcendental Instruction Accuracy" in Chapter 8 of the Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1, for a discussion of the proper value to use for PI in performing such reductions.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fsincos=Sine and Cosine 
	forms

	description
		Computes both the approximate sine and the cosine of the source operand in register ST(0), stores the sine in
		ST(0), and pushes the cosine onto the top of the FPU register stack. (This instruction is faster than executing the FSIN and FCOS instructions in succession.)
		The source operand must be given in radians and must be within the range -2^^63 to +2^^63.
		If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in
		register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of
		range. It is up to the program to check the C2 flag for out-of-range conditions. 
		Source values outside the range -2^^63 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2*PI.
		However, even within the range -2^^63 to +2^^63, inaccurate results can occur because the finite approximation of PI
		used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply
		FSINCOS only to arguments reduced accurately in software, to a value smaller in absolute value than 3*PI/8. See the
		sections titled "Approximation of Pi" and "Transcendental Instruction Accuracy" in Chapter 8 of the Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1, for a discussion of the proper value to use for PI in performing such reductions.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fsqrt=Square Root 
	forms

	description
		Computes the square root of the source value in the ST(0) register and stores the result in ST(0).
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fst/fstp=Store Floating Point Value 
	forms

	description
		The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory location 
		or another register in the FPU register stack. When storing the value in memory, the value is converted to
		single-precision or double-precision floating-point format.
		
		The FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop
		the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
		The FSTP instruction can also store values in memory in double extended-precision floating-point format.
		If the destination operand is a memory location, the operand specifies the address where the first byte of the destination value is to be stored. 
		If the destination operand is a register, the operand specifies a register in the register stack relative to the top of the stack.
		
		If the destination size is single-precision or double-precision, the significand of the value being stored is rounded
		to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word),
		and the exponent is converted to the width and bias of the destination format. If the value being stored is too large
		for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no
		value is stored in the destination operand. If the value being stored is a denormal value, the denormal exception
		(#D) is not generated. This condition is simply signaled as a numeric underflow exception (#U) condition.
		If the value being stored is +-0, +-infinity, or a NaN, the least-significant bits of the significand and the exponent are truncated 
		to fit the destination format. This operation preserves the value's identity as a 0, infinity, or NaN.
		If the destination operand is a non-empty register, the invalid-operation exception is not generated.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fstcw/fnstcw=Store x87 FPU Control Word 
	forms

	description
		Stores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction
		checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW
		instruction does not.
		The assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW
		instruction), and the processor executes each of these instructions in separately. If an exception is generated for
		either of these instructions, the save EIP points to the instruction that caused the exception.
		
		When operating a Pentium or Intel 486 processor in MS-DOS compatibility mode, it is possible (under unusual
		circumstances) for an FNSTCW instruction to be interrupted prior to being executed to handle a pending FPU
		exception. See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the
		Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a description of these circumstances.
		An FNSTCW instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family
		processor.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fstenv/fnstenv=Store x87 FPU Environment 
	forms

	description
		Saves the current FPU operating environment at the memory location specified with the destination operand, and
		then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status
		word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1, show the layout in memory of the stored environment,
		depending on the operating mode of the processor (protected or real) and the current operand-size attribute
		(16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.
		
		The FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing
		the FPU environment; the FNSTENV instruction does not. The saved image reflects the state of the FPU after all
		floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been
		executed.
		
		These instructions are often used by exception handlers because they provide access to the FPU instruction and
		data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment
		prevents floating-point exceptions from interrupting the exception handler.
		
		The assembler issues two instructions for the FSTENV instruction (an FWAIT instruction followed by an FNSTENV
		instruction), and the processor executes each of these instructions separately. If an exception is generated for
		either of these instructions, the save EIP points to the instruction that caused the exception.
		
		When operating a Pentium or Intel 486 processor in MS-DOS compatibility mode, it is possible (under unusual
		circumstances) for an FNSTENV instruction to be interrupted prior to being executed to handle a pending FPU
		exception. See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the
		Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a description of these circumstances.
		An FNSTENV instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fstsw/fnstsw=Store x87 FPU Status Word 
	forms

	description
		Stores the current value of the x87 FPU status word in the destination location. The destination operand can be
		either a two-byte memory location or the AX register. The FSTSW instruction checks for and handles pending
		unmasked floating-point exceptions before storing the status word; the FNSTSW instruction does not.
		
		The FNSTSW AX form of the instruction is used primarily in conditional branching (for instance, after an FPU
		comparison instruction or an FPREM, FPREM1, or FXAM instruction), where the direction of the branch depends on
		the state of the FPU condition code flags. (See the section titled "Branching and Conditional Moves on FPU Condi-
		tion Codes" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1.) This
		instruction can also be used to invoke exception handlers (by examining the exception flags) in environments that
		do not use interrupts. When the FNSTSW AX instruction is executed, the AX register is updated before the
		processor executes any further instructions. The status stored in the AX register is thus guaranteed to be from the
		completion of the prior FPU instruction.
		
		The assembler issues two instructions for the FSTSW instruction (an FWAIT instruction followed by an FNSTSW
		instruction), and the processor executes each of these instructions separately. If an exception is generated for
		either of these instructions, the save EIP points to the instruction that caused the exception.
		When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual
		circumstances) for an FNSTSW instruction to be interrupted prior to being executed to handle a pending FPU
		exception. See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the
		Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a description of these circumstances.
		An FNSTSW instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fsub/fsubp/fisub=Subtract 
	forms

	description
		Subtracts the source operand from the destination operand and stores the difference in the destination location.
		The destination operand is always an FPU data register; the source operand can be a register or a memory location.
		Source operands in memory can be in single-precision or double-precision floating-point format or in word or
		doubleword integer format.
		
		The no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and
		stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-
		point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand
		version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.
		
		The FSUBP instructions perform the additional operation of popping the FPU register stack following the subtraction.
		To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer
		(TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack
		being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.
		The FISUB instructions convert an integer source operand to double extended-precision floating-point format
		before performing the subtraction.
		
		When the difference between two operands of like sign is 0, the result is +0, except for the round toward -infinity mode,
		in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the
		source operand is an integer 0, it is treated as a +0.
		When one operand is infinity, the result is infinity of the expected sign. If both operands are infinity of the same sign,
		an invalid-operation exception is generated.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.
	exceptions

	flags

	operation

	meta


fsubr/fsubrp/fisubr=Reverse Subtract
	forms

	description
		Subtracts the destination operand from the source operand and stores the difference in the destination location.
		The destination operand is always an FPU register; the source operand can be a register or a memory location.
		Source operands in memory can be in single-precision or double-precision floating-point format or in word or
		doubleword integer format.
		
		These instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided
		to support more efficient coding.
		
		The no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and
		stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents
		of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand
		version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.
		The FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtrac-
		tion. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer
		(TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register
		stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.
		The FISUBR instructions convert an integer source operand to double extended-precision floating-point format
		before performing the subtraction.
		
		When the difference between two operands of like sign is 0, the result is +0, except for the round toward -infinity mode,
		in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the
		source operand is an integer 0, it is treated as a +0.
		When one operand is infinity, the result is infinity of the expected sign. If both operands are infinity of the same sign, an invalid-
		operation exception is generated.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


ftst=Compare ST(0) with 0.0
	forms

	description
		Compares the value in the ST(0) register with 0.0 and sets the condition code flags C0, C2, and C3 in the FPU
		status word according to the results.
		
		This instruction performs an "unordered comparison." An unordered comparison also checks the class of the
		numbers being compared. If the value in register ST(0) is a NaN or is in an undefined format, 
		the condition flags are set to "unordered" and the invalid operation exception is generated.
		The sign of zero is ignored, so that (-0.0 == +0.0).
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fucom/fucomp/fucompp=Unordered Compare Floating Point Values 
	forms

	description
		Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2,
		and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the
		contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that -0.0 is equal to +0.0.
		
		An unordered comparison checks the class of the numbers being compared.
		The FUCOM/FUCOMP/FUCOMPP instructions perform the same operations as the FCOM/FCOMP/FCOMPP instructions. 
		The only difference is that the FUCOM/FUCOMP/FUCOMPP instructions raise the invalid-arithmetic-
		operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format; QNaNs
		cause the condition code flags to be set to unordered, but do not cause an exception to be generated. The
		FCOM/FCOMP/FCOMPP instructions raise an invalid-operation exception when either or both of the operands are a
		NaN value of any kind or are in an unsupported format.
		
		As with the FCOM/FCOMP/FCOMPP instructions, if the operation results in an invalid-arithmetic-operand exception
		being raised, the condition code flags are set only if the exception is masked.
		
		The FUCOMP instruction pops the register stack following the comparison operation and the FUCOMPP instruction
		pops the register stack twice following the comparison operation. To pop the register stack, the processor marks
		the ST(0) register as empty and increments the stack pointer (TOP) by 1.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fxam=Examine ModR/M 
	forms

	description
		Examines the contents of the ST(0) register and sets the condition code flags C0, C2, and C3 in the FPU status word
		to indicate the class of value or number in the register.
		
		The C1 flag is set to the sign of the value in ST(0), regardless of whether the register is empty or full.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fxch=Exchange Register Contents 
	forms

	description
		Exchanges the contents of registers ST(0) and ST(i). If no source operand is specified, the contents of ST(0) and ST(1) are exchanged.
		
		This instruction provides a simple means of moving values in the FPU register stack to the top of the stack [ST(0)],
		so that they can be operated on by those floating-point instructions that can only operate on values in ST(0). For
		example, the following instruction sequence takes the square root of the third register from the top of the register stack:
		
		FXCH ST(3);
		FSQRT;
		FXCH ST(3);
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fxrstor=Restore x87 FPU, MMX, XMM, and MXCSR State 
	forms

	description
		Reloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in
		the source operand. This data should have been written to memory previously using the FXSAVE instruction, and
		in the same format as required by the operating modes. The first byte of the data should be located on a 16-byte
		boundary. There are three distinct layouts of the FXSAVE state map: one for legacy and compatibility mode, a
		second format for 64-bit mode FXSAVE/FXRSTOR with REX.W=0, and the third format is for 64-bit mode with
		FXSAVE64/FXRSTOR64.
		
		The state image referenced with an FXRSTOR instruction must have been saved using an FXSAVE instruction or be
		in the same format.
		Referencing a state image saved with an FSAVE, FNSAVE instruction or incompatible field layout will result in an incorrect state restoration.
		
		The FXRSTOR instruction does not flush pending x87 FPU exceptions. To check and raise exceptions when loading
		x87 FPU state information with the FXRSTOR instruction, use an FWAIT instruction after the FXRSTOR instruction.
		If the OSFXSR bit in control register CR4 is not set, the FXRSTOR instruction may not restore the states of the XMM
		and MXCSR registers. This behavior is implementation dependent.
		
		If the MXCSR state contains an unmasked exception with a corresponding status flag also set, loading the register
		with the FXRSTOR instruction will not result in a SIMD floating-point error condition being generated. Only the next
		occurrence of this unmasked exception will result in the exception being generated.
		
		Bits 16 through 32 of the MXCSR register are defined as reserved and should be set to 0. Attempting to write a 1
		in any of these bits from the saved state image will result in a general protection exception (#GP) being generated.
		Bytes 464:511 of an FXSAVE image are available for software use. FXRSTOR ignores the content of bytes 464:511
		in an FXSAVE state image.

	exceptions

	flags

	operation

	meta


fxsave=Save x87 FPU, MMX Technology, and SSE State 
	forms

	description
		Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory location 
		specified in the destination operand. The content layout of the 512 byte region depends on whether the
		processor is operating in non-64-bit operating modes or 64-bit sub-mode of IA-32e mode.

	exceptions

	flags

	operation

	meta


fxtract=Extract Exponent and Significand 
	forms

	description
		Separates the source value in the ST(0) register into its exponent and significand, stores the exponent in ST(0),
		and pushes the significand onto the register stack. Following this operation, the new top-of-stack register ST(0)
		contains the value of the original significand expressed as a floating-point value. The sign and significand of this
		value are the same as those found in the source operand, and the exponent is 3FFFH (biased value for a true exponent of zero).
		The ST(1) register contains the value of the original operand's true (unbiased) exponent expressed as a floating-point value.
		(The operation performed by this instruction is a superset of the IEEE-recommended logb(x) function.)
		
		This instruction and the F2XM1 instruction are useful for performing power and range scaling operations. The
		FXTRACT instruction is also useful for converting numbers in double extended-precision floating-point format to
		decimal representations (e.g., for printing or displaying).
		
		If the floating-point zero-divide exception (#Z) is masked and the source operand is zero, 
		an exponent value of -infinity is stored in register ST(1) and 0 with the sign of the source operand is stored in register ST(0).
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fyl2x=Compute y * log2(x )
	forms

	description
		Computes (ST(1) * log2 (ST(0))), stores the result in resister ST(1), and pops the FPU register stack. The source
		operand in ST(0) must be a non-zero positive number.
		If the divide-by-zero exception is masked and register ST(0) contains +-0, the instruction returns infinity with a sign that
		is the opposite of the sign of the source operand in register ST(1).
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fyl2xp1=Compute y * log2(x + 1) 
	forms

	description
		Computes (ST(1) * log2(ST(0) + 1.0)), stores the result in register ST(1), and pops the FPU register stack. The
		source operand in ST(0) must be in the range -( 1 - sqrt(2) / 2 ) ) to ( 1 - sqrt(2) / 2 )
		The source operand in ST(1) can range from -infinity to +infinity. If the ST(0) operand is outside of its acceptable range, the
		result is undefined and software should not rely on an exception being generated. Under some circumstances
		exceptions may be generated when ST(0) is out of range, but this behavior is implementation specific and not guaranteed.
		
		This instruction provides optimal accuracy for values of epsilon [the value in register ST(0)] that are close to 0. For
		small epsilon values, more significant digits can be retained by using the FYL2XP1 instruction than by using
		(epsilon+1) as an argument to the FYL2X instruction. The (epsilon+1) expression is commonly found in compound interest and
		annuity calculations. The result can be simply converted into a value in another logarithm base by including a scale
		factor in the ST(1) source operand.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


haddpd/vhaddpd=Packed Double-FP Horizontal Add 
	forms

	description
		Adds the double-precision floating-point values in the high and low quadwords of the destination operand and
		stores the result in the low quadword of the destination operand.
		
		Then adds the double-precision floating-point values in the high and low quadwords of the source operand and stores the
		result in the high quadword of the destination operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


haddps/vhaddps=Packed Single-FP Horizontal Add 
	forms

	description
		Adds the single-precision floating-point values in the first and second dwords of the destination operand and stores
		the result in the first dword of the destination operand.
		
		Adds single-precision floating-point values in the third and fourth dword of the destination operand and stores the
		result in the second dword of the destination operand.
		
		Adds single-precision floating-point values in the first and second dword of the source operand and stores the
		result in the third dword of the destination operand.
		
		Adds single-precision floating-point values in the third and fourth dword of the source operand and stores the
		result in the fourth dword of the destination operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


hlt=Halt 
	forms

	description
		Stops instruction execution and places the processor in a HALT state. An enabled interrupt (including NMI and
		SMI), a debug exception, the BINIT# signal, the INIT# signal, or the RESET# signal will resume execution. If an
		interrupt (including NMI) is used to resume execution after a HLT instruction, the saved instruction pointer
		(CS:EIP) points to the instruction following the HLT instruction.
		
		When a HLT instruction is executed on an Intel 64 or IA-32 processor supporting Intel Hyper-Threading Technology,
		only the logical processor that executes the instruction is halted. The other logical processors in the physical
		processor remain active, unless they are each individually halted by executing a HLT instruction.
		
		The HLT instruction is a privileged instruction. When the processor is running in protected or virtual-8086 mode,
		the privilege level of a program or procedure must be 0 to execute the HLT instruction.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


hsubpd/vhsubpd=Packed Double-FP Horizontal Subtract 
	forms

	description
		The HSUBPD instruction subtracts horizontally the packed double-precision FP numbers of both operands.
		Subtracts the double-precision floating-point value in the high quadword of the destination operand from the low
		quadword of the destination operand and stores the result in the low quadword of the destination operand.
		Subtracts the double-precision floating-point value in the high quadword of the source operand from the low quad-
		word of the source operand and stores the result in the high quadword of the destination operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


hsubps/vhsubps=Packed Single-FP Horizontal Subtract 
	forms

	description
		Subtracts the single-precision floating-point value in the second dword of the destination operand from the first
		dword of the destination operand and stores the result in the first dword of the destination operand.
		
		Subtracts the single-precision floating-point value in the fourth dword of the destination operand from the third
		dword of the destination operand and stores the result in the second dword of the destination operand.
		
		Subtracts the single-precision floating-point value in the second dword of the source operand from the first dword
		of the source operand and stores the result in the third dword of the destination operand.
		
		Subtracts the single-precision floating-point value in the fourth dword of the source operand from the third dword
		of the source operand and stores the result in the fourth dword of the destination operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


idiv=Signed Divide 
	forms

	description
		Divides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by the source operand (divisor) and stores the
		result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a
		memory location. The action of this instruction depends on the operand size (dividend/divisor).
		
		Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magni-
		tude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15).
		Use of the REX.W prefix promotes operation to 64 bits.
		In 64-bit mode when REX.W is applied, the instruction divides the signed value in RDX:RAX by the source operand.
		RAX contains a 64-bit quotient; RDX contains a 64-bit remainder.

	exceptions

	flags

	operation

	meta


imul=Signed Multiply 
	forms

	description
		Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of operands.
		
		~One-operand form
			This form is identical to that used by the MUL instruction. Here, the source operand (in
			a general-purpose register or memory location) is multiplied by the value in the AL, AX, EAX, or RAX register
			(depending on the operand size) and the product (twice the size of the input operand) is stored in the AX,
			DX:AX, EDX:EAX, or RDX:RAX registers, respectively.
		
		~Two-operand form
			With this form the destination operand (the first operand) is multiplied by the source
			operand (second operand). The destination operand is a general-purpose register and the source operand is an
			immediate value, a general-purpose register, or a memory location. The intermediate product (twice the size of
			the input operand) is truncated and stored in the destination operand location.
		
		~Three-operand form
			This form requires a destination operand (the first operand) and two source operands
			(the second and the third operands). Here, the first source operand (which can be a general-purpose register
			or a memory location) is multiplied by the second source operand (an immediate value). The intermediate
			product (twice the size of the first source operand) is truncated and stored in the destination operand (a general-purpose register).
		
		When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.
		The CF and OF flags are set when the signed integer value of the intermediate product differs from the sign
		extended operand-size-truncated product, otherwise the CF and OF flags are cleared.
		The three forms of the IMUL instruction are similar in that the length of the product is calculated to twice the length
		of the operands. With the one-operand form, the product is stored exactly in the destination. With the two- and
		three- operand forms, however, the result is truncated to the length of the destination before it is stored in the
		destination register. Because of this truncation, the CF or OF flag should be tested to ensure that no significant bits
		are lost.
		The two- and three-operand forms may also be used with unsigned operands because the lower half of the product
		is the same regardless if the operands are signed or unsigned. The CF and OF flags, however, cannot be used to
		determine if the upper half of the result is non-zero.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
		tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. Use of REX.W modifies the three
		forms of the instruction as follows:
		
		~One-operand form
			The source operand (in a 64-bit general-purpose register or memory location) is
			multiplied by the value in the RAX register and the product is stored in the RDX:RAX registers.
		
		~Two-operand form
			The source operand is promoted to 64 bits if it is a register or a memory location. The
			destination operand is promoted to 64 bits.
		
		~Three-operand form
			The first source operand (either a register or a memory location) and destination
			operand are promoted to 64 bits. If the source operand is an immediate, it is sign extended to 64 bits.

	exceptions

	flags

	operation

	meta


in=Input from Port 
	forms

	description
		Copies the value from the I/O port specified with the second operand (source operand) to the destination operand
		(first operand). The source operand can be a byte-immediate or the DX register; the destination operand can be
		register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively).
		Using the DX register as a source operand allows I/O port addresses from 0 to 65,535 to be accessed; 
		using a byte immediate allows I/O port addresses 0 to 255 to be accessed.
		
		When accessing an 8-bit I/O port, the opcode determines the port size; when accessing a 16- and 32-bit I/O port,
		the operand-size attribute determines the port size. At the machine code level, I/O instructions are shorter when
		accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.
		
		This instruction is only useful for accessing I/O ports located in the processor's I/O address space.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta
		see
			Chapter 1 - "Input/Output", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


inc=Increment by 1 
	forms

	description
		Adds 1 to the destination operand, while preserving the state of the CF flag. The destination operand can be a
		register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag.
		(Use a ADD instruction with an immediate operand of 1 to perform an increment operation that does updates the CF flag.)
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		In 64-bit mode, INC r16 and INC r32 are not encodable (because opcodes 40H through 47H are REX prefixes).
		Otherwise, the instruction's 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to
		additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


ins/insb/insw/insd=Input from Port to String 
	forms

	description
		Copies the data from the I/O port specified with the source operand (second operand) to the destination operand
		(first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The
		destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI
		registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment
		cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of
		the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute 
		of the instruction for a 16- or 32-bit I/O port.
		
		At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
		operands" form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination
		operands to be specified explicitly. Here, the source operand must be "DX," and the destination operand should be
		a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided
		to allow documentation; however, note that the documentation provided by this form can be misleading. That is,
		the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword),
		but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers,
		which must be loaded correctly before the INS instruction is executed.
		
		The no-operands form provides "short forms" of the byte, word, and doubleword versions of the INS instructions.
		Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination
		operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD (doubleword).
		
		After the byte, word, or doubleword is transfer from the I/O port to the memory location, the DI/EDI/RDI register
		is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the
		DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI
		register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword
		operations.
		
		The INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words,
		or doublewords. See "REP/REPE/REPZ /REPNE/REPNZ-Repeat String Operation Prefix" in Chapter 4 of the Intel
		64 and IA-32 Architectures Software Developer's Manual, Volume 2B, for a description of the REP prefix.
		These instructions are only useful for accessing I/O ports located in the processor's I/O address space.
		In 64-bit mode, default address size is 64 bits, 32 bit address size is supported using the prefix 67H. The address
		of the memory destination is specified by RDI or EDI. 16-bit address size is not supported in 64-bit mode. The
		operand size is not promoted.

	exceptions

	flags

	operation

	meta
		see
			Chapter 16 - "Input/Output", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1

insertps/vinsertps=Insert Packed Single Precision Floating-Point Value 
	forms

	description
		~Register source form
			Select a single precision floating-point element from second source as indicated by Count_S bits of the immediate
			operand and insert it into the first source at the location indicated by the Count_D bits of the immediate operand.
			Store in the destination and zero out destination elements based on the ZMask bits of the immediate operand.
		
		~Memory source form
			Load a floating-point element from a 32-bit memory location and insert it into the first source at the location indi-
			cated by the Count_D bits of the immediate operand. Store in the destination and zero out destination elements
			based on the ZMask bits of the immediate operand.
			
			128-bit Legacy SSE version: The first source register is an XMM register. The second source operand is either an
			XMM register or a 32-bit memory location. The destination is not distinct from the first source XMM register and the
			upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
			VEX.128 encoded version. The destination and first source register is an XMM register. The second source operand
			is either an XMM register or a 32-bit memory location. The upper bits (VLMAX-1:128) of the corresponding YMM
			register destination are zeroed.
			
			If VINSERTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause
			an #UD exception.

	exceptions

	flags

	operation

	meta


int n/into/int 3=Call to Interrupt Procedure 
	forms

	description
		The INT n instruction generates a call to the interrupt or exception handler specified with the destination operand.
		The destination operand specifies a vector from 0 to 255, encoded as an 8-bit
		unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vectors are
		reserved by Intel for system use. Some of these vectors are used for internally generated exceptions.
		
		The INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The
		INTO instruction is a special mnemonic for calling overflow exception (#OF), exception 4. The overflow interrupt
		checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The
		INTO instruction cannot be used in 64-bit mode.)
		
		The INT 3 instruction generates a special one byte opcode (CC) that is intended for calling the debug exception
		handler. (This one byte form is valuable because it can be used to replace the first byte of any instruction with a
		breakpoint, including other one byte instructions, without over-writing other code). To further support its function
		as a debug breakpoint, the interrupt generated with the CC opcode also differs from the regular software interrupts
		as follows:
		
		- Interrupt redirection does not happen when in VME mode; the interrupt is handled by a protected-mode handler.
		- The virtual-8086 mode IOPL checks do not occur. The interrupt is taken without faulting at any IOPL level.
		
		Note that the "normal" 2-byte opcode for INT 3 (CD03) does not have these special features. Intel and Microsoft
		assemblers will not generate the CD03 opcode from any mnemonic, but this opcode can be created by direct
		numeric code definition or by self-modifying code.
		
		The action of the INT n instruction (including the INTO and INT 3 instructions) is similar to that of a far call made
		with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed
		onto the stack before the return address. (The return address is a far address consisting of the current values of
		the CS and EIP registers.) Returns from interrupt procedures are handled with the IRET instruction, which pops the
		EFLAGS information and return address from the stack.
		
		The vector specifies an interrupt descriptor in the interrupt descriptor table (IDT); that is, it provides index into the
		IDT. The selected interrupt descriptor in turn contains a pointer to an interrupt or exception handler procedure.
		In protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate,
		or task gate. In real-address mode, the IDT is an array of 4-byte far pointers (2-byte code segment selector and
		a 2-byte instruction pointer), each of which point directly to a procedure in the selected segment. (Note that in
		real-address mode, the IDT is called the interrupt vector table, and its pointers are called interrupt vectors.)
		
		When the processor is executing in virtual-8086 mode, the IOPL determines the action of the INT n instruction. If
		the IOPL is less than 3, the processor generates a #GP(selector) exception; if the IOPL is 3, the processor executes
		a protected mode interrupt to privilege level 0. The interrupt gate's DPL must be set to 3 and the target CPL of the
		interrupt handler procedure must be 0 to execute the protected mode interrupt to privilege level 0.
		
		The interrupt descriptor table register (IDTR) specifies the base linear address and limit of the IDT. The initial base
		address value of the IDTR after the processor is powered up or reset is 0.

	exceptions

	flags

	operation

	meta
		see
			Chapter 6 - "Interrupts and Exceptions", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


invd=Invalidate Internal Caches 
	forms

	description
		Invalidates (flushes) the processor's internal caches and issues a special-function bus cycle that directs external
		caches to also flush themselves. Data held in internal caches is not written back to main memory.
		After executing this instruction, the processor does not wait for the external caches to complete their flushing operation
		before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache flush signal.
		
		The INVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a
		program or procedure must be 0 to execute this instruction.
		
		The INVD instruction may be used when the cache is used as temporary memory and the cache contents need to
		be invalidated rather than written back to memory. When the cache is used as temporary memory, no external
		device should be actively writing data to main memory.
		
		Use this instruction with care. Data cached internally and not written back to main memory will be lost. Note that
		any data from an external device to main memory (for example, via a PCIWrite) can be temporarily stored in the
		caches; these data can be lost when an INVD instruction is executed. Unless there is a specific requirement or
		benefit to flushing caches without writing back modified cache lines (for example, temporary memory, testing, or
		fault recovery where cache coherency with main memory is not a concern), software should instead use the WBINVD instruction.
		
		The INVD instruction is implementation dependent; it may be implemented differently on different families of Intel
		64 or IA-32 processors. This instruction is not supported on IA-32 processors earlier than the Intel 486 processor.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


invlpg=Invalidate TLB Entries 
	forms

	description
		Invalidates any translation lookaside buffer (TLB) entries specified with the source operand. The source operand is
		a memory address. The processor determines the page that contains that address and flushes all TLB entries for that page.
		
		The INVLPG instruction is a privileged instruction. When the processor is running in protected mode, the CPL must
		be 0 to execute this instruction.
		
		The INVLPG instruction normally flushes TLB entries only for the specified page; however, in some cases, it may
		flush more entries, even the entire TLB. The instruction is guaranteed to invalidates only TLB entries associated
		with the current PCID. (If PCIDs are disabled - CR4.PCIDE = 0 - the current PCID is 000H.) The instruction also
		invalidates any global TLB entries for the specified page, regardless of PCID.
		
		This instruction's operation is the same in all non-64-bit modes. It also operates the same in 64-bit mode, except
		if the memory address is in non-canonical form. In this case, INVLPG is the same as a NOP.

	exceptions

	flags

	operation

	meta


invpcid=Invalidate Process-Context Identifier 
	forms

	description
		Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on process-
		context identifier (PCID). (See Section 4.10, "Caching Translation Information," in Intel 64 and IA-32 Architecture
		Software Developer's Manual, Volume 3A.) Invalidation is based on the INVPCID type specified in the register
		operand and the INVPCID descriptor specified in the memory operand.
		Outside 64-bit mode, the register operand is always 32 bits, regardless of the value of CS.D.
		In 64-bit mode the register operand has 64 bits.
		
		There are four INVPCID types currently defined:
		
		- Individual-address invalidation: If the INVPCID type is 0, the logical processor invalidates mappings, except
		global translations, for the linear address and PCID specified in the INVPCID descriptor. 1 In some cases, the
		instruction may invalidate global translations or mappings for other linear addresses (or other PCIDs) as well.
		
		- Single-context invalidation: If the INVPCID type is 1, the logical processor invalidates all mappings, except
		global translations, associated with the PCID specified in the INVPCID descriptor. In some cases, the
		instruction may invalidate global translations or mappings for other PCIDs as well.
		
		- All-context invalidation, including global translations: If the INVPCID type is 2, the logical processor invalidates
		all mappings, including global translations, associated with any PCID.
		
		- All-context invalidation: If the INVPCID type is 3, the logical processor invalidates all mappings, except global
		translations, associated with any PCID. In some case, the instruction may invalidate global translations as
		well.
		
		For INVPCID type 0, the processor uses the full 64 bits of the linear address even outside 64-bit mode; the linear
		address is not used for other INVPCID types.

	exceptions

	flags

	operation

	meta


iret/iretd/iretq=Interrupt Return
	forms

	description
		Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by
		an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform
		a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or
		when an interrupt or exception causes a task switch to an interrupt or exception handler.)
		
		IRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended
		for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the
		IRET mnemonic interchangeably for both operand sizes.
		
		In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During
		this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image
		from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted
		program or procedure.
		
		In Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags
		in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting
		of these flags, the processor performs the following types of interrupt returns:
		
		- Return from virtual-8086 mode.
		- Return to virtual-8086 mode.
		- Intra-privilege level return.
		- Inter-privilege level return.
		- Return from nested task (task switch).
		
		If the NT flag (EFLAGS register) is cleared, the IRET instruction performs a far return from the interrupt procedure,
		without a task switch. The code segment being returned to must be equally or less privileged than the interrupt
		handler routine (as indicated by the RPL field of the code segment selector popped from the stack).
		
		As with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code
		segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then
		resumes execution of the interrupted program or procedure. If the return is to another privilege level, the IRET
		instruction also pops the stack pointer and SS from the stack, before resuming program execution. If the return is
		to virtual-8086 mode, the processor also pops the data segment registers from the stack.
		
		If the NT flag is set, the IRET instruction performs a task switch (return) from a nested task (a task called with a
		CALL instruction, an interrupt, or an exception) back to the calling or interrupted task. The updated state of the
		task executing the IRET instruction is saved in its TSS. If the task is re-entered later, the code that follows the IRET
		instruction is executed.
		
		If the NT flag is set and the processor is in IA-32e mode, the IRET instruction causes a general protection exception.
		If nonmaskable interrupts (NMIs) are blocked, execution of the IRET instruction unblocks NMIs.
		This unblocking occurs even if the instruction causes a fault. In such a case, NMIs are unmasked before the exception handler is invoked.
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.W prefix promotes operation to 64-bits (IRETQ).

	exceptions

	flags

	operation

	meta
		see
			Chapter 7 - "Task Linking", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A
			Section 6.7.1 - "Handling Multiple NMIs", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A
			Chapter 25 - "Changes to Instruction Behavior in VMX Non-Root Operation", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3C


ja=Jump if above (CF = 0 and ZF = 0)
jae=Jump if above or equal (CF = 0)
jb=Jump if below (CF = 1)
jbe=Jump if below or equal (CF = 1 or ZF = 1)
jc=Jump if carry (CF = 1)
jcxz=Jump if CX register is 0
jecxz=Jump if the ECX register is 0
jrcxz=Jump if the RCX register is 0
je=Jump if equal (ZF = 1)
jg=Jump if greater (ZF = 0 and SF = OF)
jge=Jump if greater or equal (SF = OF)
jl=Jump if less (SF != OF)
jle=Jump if less or equal (ZF = 1 or SF != OF)
jna=Jump if not above(CF = 1 or ZF = 1)
jnae=Jump if not above or equal (CF = 1)
jnb=Jump if not below (CF = 0)
jnbe=Jump if not below or equal (CF = 0 and ZF = 0)
jnc=Jump if not carry (CF = 0)
jne=Jump if not equal (ZF = 0)
jng=Jump if not greater (ZF = 1 or SF != OF)
jnge=Jump if not greater or equal (SF != OF)
jnl=Jump if not less (SF = 0F)
jnle=Jump if not less or equal (ZF = 0 and SF = OF)
jno=Jump if not overflow (OF = 0)
jnp=Jump if not parity (PF = 0)
jns=Jump if not sign (SF = 0)
jnz=Jump if not zero (ZF = 0)
jo=Jump if overflow (OF = 1)
jp=Jump if parity (PF = 1)
jpe=Jump if parity even (PF = 1)
jpo=Jump if parity odd (PF = 0)
js=Jump if sign (SF = 1)
jz=Jump if zero (ZF = 1)
jcc=Conditional jumps (group)
	forms

	description
		Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
		are in the specified state (condition), performs a jump to the target instruction specified by the destination
		operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
		condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.
		The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). 
		A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
		
		code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
		the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
		is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
		The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
		terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for unsigned integers.
		
		Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
		defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
		equal) instruction are alternate mnemonics for the opcode 77H.
		
		The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
		jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
		and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
		following conditional far jump is illegal:
		
		JZ FARLABEL;
		
		To accomplish this far jump, use the following two instructions:
		
		JNZ BEYOND;
		JMP FARLABEL;
		BEYOND:
		
		The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
		Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
		instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
		(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
		is 0. This would cause the loop to execute 2^^64 , 2^^32 or 2^^16 times (not zero times).
		
		All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cacheability.
		
		In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits.
		JMP Near is RIP = RIP + 32-bit offset sign extended to 64-bits.

	exceptions

	flags

	operation

	meta


jmp=Unconditional jump 
	forms

	description
		Transfers program control to a different point in the instruction stream without recording return information. The
		destination (target) operand specifies the address of the instruction being jumped to. This operand can be an
		immediate value, a general-purpose register, or a memory location.
		This instruction can be used to execute four different types of jumps:
		
		- Near jump: A jump to an instruction within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment jump.
		
		- Short jump: A near jump where the jump range is limited to -128 to +127 from the current EIP value.
		
		- Far jump: A jump to an instruction located in a different segment than the current code segment but at the same privilege level, sometimes referred to as an intersegment jump.
		
		- Task switch: A jump to an instruction located in a different task.
		
		A task switch can only be executed in protected mode (see Chapter 7, in the Intel 64 and IA-32 Architectures
		Software Developer's Manual, Volume 3A, for information on performing task switches with the JMP instruction).
		
		~Near and Short Jumps
			When executing a near jump, the processor jumps to the address (within the current code
			segment) that is specified with the target operand. The target operand specifies either an absolute offset (that is
			an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current
			value of the instruction pointer in the EIP register). A near jump to a relative offset of 8-bits (rel8) is referred to as
			a short jump. The CS register is not changed on near and short jumps.
			An absolute offset is specified indirectly in a general-purpose register or a memory location (r/m16 or r/m32). The
			operand-size attribute determines the size of the target operand (16 or 32 bits). Absolute offsets are loaded
			directly into the EIP register. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared,
			resulting in a maximum instruction pointer size of 16 bits.
			A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code
			level, it is encoded as a signed 8-, 16-, or 32-bit immediate value. This value is added to the value in the EIP
			register. (Here, the EIP register contains the address of the instruction following the JMP instruction). When using
			relative offsets, the opcode (for short vs. near jumps) and the operand-size attribute (for near relative jumps)
			determines the size of the target operand (8, 16, or 32 bits).
		
		~Far Jumps in Real-Address or Virtual-8086 Mode
			When executing a far jump in real-address or virtual-8086 mode, the processor jumps to the code segment and offset specified with the target operand.
			Here the target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory
			location (m16:16 or m16:32). With the pointer method, the segment and address of the called procedure is
			encoded in the instruction, using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate. 
			With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size)
			or 6-byte (32-bit operand size) far address. The far address is loaded directly into the CS and EIP registers.
			If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.
		
		~Far Jumps in Protected Mode
			When the processor is operating in protected mode, the JMP instruction can be used to perform the following three types of far jumps:
			
			- A far jump to a conforming or non-conforming code segment.
			- A far jump through a call gate.
			- A task switch.
			
			(The JMP instruction cannot be used to perform inter-privilege-level far jumps.)
			In protected mode, the processor always uses the segment selector part of the far address to access the corre-
			sponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access
			rights determine the type of jump to be performed.
			
			If the selected descriptor is for a code segment, a far jump to a code segment at the same privilege level is
			performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming,
			a general-protection exception is generated.) A far jump to the same privilege level in protected mode is very
			similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far
			address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or
			m16:32). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new
			code segment selector and its descriptor are loaded into CS register, and the offset from the instruction is loaded
			into the EIP register. Note that a call gate (described in the next paragraph) can also be used to perform far call to
			a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the
			preferred method of making jumps between 16-bit and 32-bit code segments.
			
			When executing a far jump through a call gate, the segment selector specified by the target operand identifies the
			call gate. (The offset part of the target operand is ignored.) The processor then jumps to the code segment speci-
			fied in the call gate descriptor and begins executing the instruction at the offset specified in the call gate. No stack
			switch occurs. Here again, the target operand can specify the far address of the call gate either directly with a
			pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32).
			
			Executing a task switch with the JMP instruction is somewhat similar to executing a jump through a call gate. Here
			the target operand specifies the segment selector of the task gate for the task being switched to (and the offset
			part of the target operand is ignored). The task gate in turn points to the TSS for the task, which contains the
			segment selectors for the task's code and stack segments. The TSS also contains the EIP value for the next instruc-
			tion that was to be executed before the task was suspended. This instruction pointer value is loaded into the EIP
			register so that the task begins executing again at this next instruction.
			
			The JMP instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the
			task gate.
			
			Note that when you execute at task switch with a JMP instruction, the nested task flag (NT) is not set in the EFLAGS
			register and the new TSS's previous task link field is not loaded with the old task's TSS selector. A return to the
			previous task can thus not be carried out by executing the IRET instruction. Switching tasks with the JMP instruc-
			tion differs in this regard from the CALL instruction which does set the NT flag and save the previous task link infor-
			mation, allowing a return to the calling task with an IRET instruction.
		
		In 64-Bit Mode the instruction's operation size is fixed at 64 bits. If a selector points to a gate, then RIP equals
		the 64-bit displacement taken from gate; else RIP equals the zero-extended offset from the far pointer referenced
		in the instruction.

	exceptions

	flags

	operation

	meta
		see
			Chapter 7 - "Task Switching", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A


lahf=Load Status Flags into AH Register 
	forms

	description
		Load: AH = EFLAGS(SF:ZF:0:AF:0:PF:1:CF)
		
		This instruction executes as described in compatibility mode and legacy mode. It is valid in 64-bit mode only
		if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1.

	exceptions

	flags

	operation

	meta


lar=Load Access Rights Byte 
	forms

	description
		Loads the access rights from the segment descriptor specified by the second operand (source operand) into the
		first operand (destination operand) and sets the ZF flag in the flag register. The source operand (which can be a
		register or a memory location) contains the segment selector for the segment descriptor being accessed. If the
		source operand is a memory address, only 16 bits of data are accessed. The destination operand is a general-
		purpose register.
		
		The processor performs access checks as part of the loading process. Once loaded in the destination register, soft-
		ware can perform additional checks on the access rights information.
		
		The access rights for a segment descriptor include fields located in the second doubleword (bytes 4-7) of the
		segment descriptor. The following fields are loaded by the LAR instruction:
		
		-Bits 7:0 are returned as 0
		-Bits 11:8 return the segment type.
		-Bit 12 returns the S flag.
		-Bits 14:13 return the DPL.
		-Bit 15 returns the P flag.
		-The following fields are returned only if the operand size is greater than 16 bits:
		-- Bits 19:16 are undefined.
		-- Bit 20 returns the software-available bit in the descriptor.
		-- Bit 21 returns the L flag.
		-- Bit 22 returns the D/B flag.
		-- Bit 23 returns the G flag.
		-- Bits 31:24 are returned as 0.
		
		This instruction performs the following checks before it loads the access rights in the destination register:
		
		- Checks that the segment selector is not NULL.
		- Checks that the segment selector points to a descriptor that is within the limits of the GDT or LDT being accessed
		- Checks that the descriptor type is valid for this instruction. All code and data segment descriptors are valid for
		(can be accessed with) the LAR instruction.
		- If the segment is not a conforming code segment, it checks that the specified segment descriptor is visible at
		the CPL (that is, if the CPL and the RPL of the segment selector are less than or equal to the DPL of the segment
		selector).
		
		If the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no
		access rights are loaded in the destination operand.
		
		The LAR instruction can only be executed in protected mode and IA-32e mode.

	exceptions

	flags

	operation

	meta


lddqu/vlddqu=Load Unaligned Integer 128 Bits
	forms

	description
		The instruction is functionally similar to (V)MOVDQU ymm/xmm, m256/m128 for loading from memory. That is:
		32/16 bytes of data starting at an address specified by the source memory operand (second operand) are fetched
		from memory and placed in a destination register (first operand). The source operand need not be aligned on a
		32/16-byte boundary. Up to 64/32 bytes may be loaded from memory; this is implementation dependent.
		This instruction may improve performance relative to (V)MOVDQU if the source operand crosses a cache line
		boundary. In situations that require the data loaded by (V)LDDQU be modified and stored to the same location, use
		(V)MOVDQU or (V)MOVDQA instead of (V)LDDQU. To move a double quadword to or from memory locations that
		are known to be aligned on 16-byte boundaries, use the (V)MOVDQA instruction.
		
		If the source is aligned to a 32/16-byte boundary, based on the implementation, the 32/16 bytes may be
		loaded more than once. For that reason, the usage of (V)LDDQU should be avoided when using uncached or
		write-combining (WC) memory regions. For uncached or WC memory regions, keep using (V)MOVDQU.
		
		This instruction is a replacement for (V)MOVDQU (load) in situations where cache line splits significantly affect
		performance. It should not be used in situations where store-load forwarding is performance critical. If
		performance of store-load forwarding is critical to the application, use (V)MOVDQA store-load pairs when data
		is 256/128-bit aligned or (V)MOVDQU store-load pairs when data is 256/128-bit unaligned.
		
		If the memory address is not aligned on 32/16-byte boundary, some implementations may load up to 64/32
		bytes and return 32/16 bytes in the destination. Some processor implementations may issue multiple loads to
		access the appropriate 32/16 bytes. Developers of multi-threaded or multi-processor software should be aware
		that on these processors the loads will be performed in a non-atomic way.
		
		If alignment checking is enabled (CR0.AM = 1, RFLAGS.AC = 1, and CPL = 3), an alignment-check exception
		(#AC) may or may not be generated (depending on processor implementation) when the memory address is
		not aligned on an 8-byte boundary.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


ldmxcsr/vldmxcsr=Load MXCSR Register 
	forms

	description
		Loads the source operand into the MXCSR control/status register. The source operand is a 32-bit memory location.
		The LDMXCSR instruction is typically used in conjunction with the (V)STMXCSR instruction, which stores the contents of the MXCSR register in memory.
		
		The default MXCSR value at reset is 1F80H.
		
		If a (V)LDMXCSR instruction clears a SIMD floating-point exception mask bit and sets the corresponding exception
		flag bit, a SIMD floating-point exception will not be immediately generated. The exception will be generated only
		upon the execution of the next instruction that meets both conditions below:
		
		- the instruction must operate on an XMM or YMM register operand,
		- the instruction causes that particular SIMD floating-point exception to be reported.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.
		If VLDMXCSR is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation
		MXCSR = m32

	meta
		see
			Chapter 10 - "MXCSR Control and Status Register", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


lds/les/lfs/lgs/lss=Load Far Pointer 
	forms

	description
		Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment
		register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in
		memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The
		instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-
		bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS,
		SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.
		If one of these instructions is executed in protected mode, additional information from the segment descriptor
		pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment register.
		
		Also in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers
		without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment
		register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to
		the segment occurs.)
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes
		operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory.
		Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15).

	exceptions

	flags

	operation

	meta


lea=Load Effective Address 
	forms

	description
		Computes the effective address of the second operand (the source operand) and stores it in the first operand
		(destination operand). The source operand is a memory address (offset part) specified with one of the processors
		addressing modes; the destination operand is a general-purpose register. The address-size and operand-size attributes 
		affect the action performed by this instruction. The operand-size attribute of the instruction is determined by the chosen register; 
		the address-size attribute is determined by the attribute of the code segment.
		
		Different assemblers may use different algorithms based on the size attribute and symbolic reference of the source
		operand.
		
		In 64-bit mode, the instruction's destination operand is governed by operand size attribute, the default operand
		size is 32 bits. Address calculation is governed by address size attribute, the default address size is 64-bits. In 64-
		bit mode, address size of 16 bits is not encodable.

	exceptions

	flags

	operation

	meta


leave=High Level Procedure Exit 
	forms

	description
		Releases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction copies the frame pointer (in
		the EBP register) into the stack pointer register (ESP), which releases the stack space allocated to the stack frame.
		The old frame pointer (the frame pointer for the calling procedure that was saved by the ENTER instruction) is then
		popped from the stack into the EBP register, restoring the calling procedure's stack frame.
		
		A RET instruction is commonly executed following a LEAVE instruction to return program control to the calling
		procedure.
		
		In 64-bit mode, the instruction's default operation size is 64 bits; 32-bit operation cannot be encoded.

	exceptions

	flags

	operation

	meta
		see
			Chapter 7 - "Procedure Calls for Block-Structured Languages", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1

lfence=Serializes load operations
	forms

	description
		Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruc-
		tion. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruc-
		tion begins execution until LFENCE completes. In particular, an instruction that loads from memory and that
		precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an
		instruction that stores to memory might complete before the data being stored have become globally visible.)
		Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute until
		the LFENCE completes.
		
		Weakly ordered memory types can be used to achieve higher processor performance through such techniques as
		out-of-order issue and speculative reads. The degree to which a consumer of data recognizes or knows that the
		data is weakly ordered varies among applications and may be unknown to the producer of this data. The LFENCE
		instruction provides a performance-efficient way of ensuring load ordering between routines that produce weakly-
		ordered results and routines that consume that data.
		
		Processors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and
		WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution. 
		Thus, it is not ordered with respect to executions of the LFENCE instruction; 
		
		data can be brought into the caches speculatively just before, during, or after the execution of an LFENCE instruction.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.
		
		Specification of the instruction's opcode above indicates a ModR/M byte of E8. For this instruction, the processor
		ignores the r/m field of the ModR/M byte. Thus, LFENCE is encoded by any opcode of the form 0F AE Ex, where x is
		in the range 8-F.

	exceptions

	flags

	operation

	meta


lgdt=Load Global Descriptor Table Register
lidt=Load Interrupt Descriptor Table Register
	forms

	description
		Loads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor
		table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a
		linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor
		table (IDT). If operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-
		bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute
		is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here,
		the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is
		filled with zeros.
		
		The LGDT and LIDT instructions are used only in operating-system software; they are not used in application
		programs. They are the only instructions that directly load a linear address (that is, not a segment-relative
		address) and a limit in protected mode. They are commonly executed in real-address mode to allow processor
		initialization prior to switching to protected mode.
		
		In 64-bit mode, the instruction's operand size is fixed at 8+2 bytes (an 8-byte base and a 2-byte limit). See the
		summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta
		linked
			sgdt


lldt=Load Local Descriptor Table Register 
	forms

	description
		Loads the source operand into the segment selector field of the local descriptor table register (LDTR). The source
		operand (a general-purpose register or a memory location) contains a segment selector that points to a local
		descriptor table (LDT). After the segment selector is loaded in the LDTR, the processor uses the segment selector
		to locate the segment descriptor for the LDT in the global descriptor table (GDT). It then loads the segment limit
		and base address for the LDT from the segment descriptor into the LDTR. The segment registers DS, ES, SS, FS, GS, and CS
		are not affected by this instruction, nor is the LDTR field in the task state segment (TSS) for the current task.
		
		If bits 2-15 of the source operand are 0, LDTR is marked invalid and the LLDT instruction completes silently.
		However, all subsequent references to descriptors in the LDT (except by the LAR, VERR, VERW or LSL instructions)
		cause a general protection exception (#GP).
		
		The operand-size attribute has no effect on this instruction.
		
		The LLDT instruction is provided for use in operating-system software; it should not be used in application
		programs. This instruction can only be executed in protected mode or 64-bit mode.
		
		In 64-bit mode, the operand size is fixed at 16 bits.

	exceptions

	flags

	operation

	meta


lmsw=Load Machine Status Word 
	forms

	description
		Loads the source operand into the machine status word, bits 0 through 15 of register CR0. The source operand can
		be a 16-bit general-purpose register or a memory location. Only the low-order 4 bits of the source operand (which
		contains the PE, MP, EM, and TS flags) are loaded into CR0. The PG, CD, NW, AM, WP, NE, and ET flags of CR0 are
		not affected. The operand-size attribute has no effect on this instruction.
		
		If the PE flag of the source operand (bit 0) is set to 1, the instruction causes the processor to switch to protected
		mode. While in protected mode, the LMSW instruction cannot be used to clear the PE flag and force a switch back
		to real-address mode.
		
		The LMSW instruction is provided for use in operating-system software; it should not be used in application
		programs. In protected or virtual-8086 mode, it can only be executed at CPL 0.
		
		This instruction is provided for compatibility with the Intel 286 processor; programs and procedures intended to
		run on the Pentium 4, Intel Xeon, P6 family, Pentium, Intel 486, and Intel 386 processors should use the MOV
		(control registers) instruction to load the whole CR0 register. The MOV CR0 instruction can be used to set and clear
		the PE flag in CR0, allowing a procedure or program to switch between protected and real-address modes.
		This instruction is a serializing instruction.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode. Note that the operand size is fixed at 16 bits.

	exceptions

	flags

	operation

	meta


lock=Instruction prefix: assert the LOCK# signal
	forms

	description
		Causes the processor's LOCK# signal to be asserted during execution of the accompanying instruction (turns the
		instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal ensures that the
		processor has exclusive use of any shared memory while the signal is asserted.
		
		Note that, in later Intel 64 and IA-32 processors (including the Pentium 4, Intel Xeon, and P6 family processors),
		locking may occur without the LOCK# signal being asserted.
		
		The LOCK prefix can be prepended only to the following instructions and only to those forms of the instructions
		where the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B,
		CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. If the LOCK prefix is used with one of
		these instructions and the source operand is a memory operand, an undefined opcode exception (#UD) may be
		generated. An undefined opcode exception will also be generated if the LOCK prefix is used with any instruction not
		in the above list. The XCHG instruction always asserts the LOCK# signal regardless of the presence or absence of
		the LOCK prefix.
		
		The LOCK prefix is typically used with the BTS instruction to perform a read-modify-write operation on a memory
		location in shared memory environment.
		
		The integrity of the LOCK prefix is not affected by the alignment of the memory field. Memory locking is observed
		for arbitrarily misaligned fields.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta
		linked
			add,adc,and,btc,btr,bts,cmpxchg,cmpxchg8b,cmpxchg16b,dec,inc,neg,not,or,sbb,sub,xor,xadd,xchg


lods/lodsb/lodsw/lodsd/lodsq=Load String 
	forms

	description
		Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The
		source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers
		(depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be over-
		ridden with a segment override prefix.
		
		At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
		operands" form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be
		specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source
		value. The destination operand is then automatically selected to match the size of the source operand (the AL
		register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form
		is provided to allow documentation; however, note that the documentation provided by this form can be
		misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or
		doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI
		registers, which must be loaded correctly before the load string instruction is executed.
		The no-operands form provides "short forms" of the byte, word, and doubleword versions of the LODS instructions.
		Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the desti-
		nation operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte
		loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).
		After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the
		(E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS
		register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.)
		The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for
		doubleword operations.
		
		In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address
		(R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of
		the DF flag in the EFLAGS register.
		
		The LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX
		bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because
		further processing of the data moved into the register is usually necessary before the next transfer can be made.

	exceptions

	flags

	operation

	meta


loop=Loop if decrement (R/E)CX is not zero
loope=Loop if decrement (R/E)CX is not zero and ZF = 1
loopne=Loop if decrement (R/E)CX is not zero and ZF = 0
	forms

	description
		Performs a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64
		bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden
		using a 67H prefix.
		
		Each time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is
		0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If
		the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the
		instruction at the beginning of the loop.
		
		The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
		tion pointer in the IP/EIP/RIP register). This offset is generally specified as a label in assembly code, but at the
		machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer.
		Offsets of -128 to +127 are allowed with this instruction.
		
		Some forms of the loop instruction (LOOPcc) also accept the ZF flag as a condition for terminating the loop before
		the count reaches zero. With these forms of the instruction, a condition code (cc) is associated with each instruc-
		tion to indicate the condition being tested for. Here, the LOOPcc instruction itself does not affect the state of the ZF
		flag; the ZF flag is changed by other instructions in the loop.

	exceptions

	flags

	operation

	meta


lsl=Load segment limit 
	forms

	description
		Loads the unscrambled segment limit from the segment descriptor specified with the second operand (source
		operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source
		operand (which can be a register or a memory location) contains the segment selector for the segment descriptor
		being accessed. The destination operand is a general-purpose register.
		
		The processor performs access checks as part of the loading process. Once loaded in the destination register, soft-
		ware can compare the segment limit with the offset of a pointer.
		
		The segment limit is a 20-bit value contained in bytes 0 and 1 and in the first 4 bits of byte 6 of the segment
		descriptor. If the descriptor has a byte granular segment limit (the granularity flag is set to 0), the destination
		operand is loaded with a byte granular value (byte limit). If the descriptor has a page granular segment limit (the
		granularity flag is set to 1), the LSL instruction will translate the page granular limit (page limit) into a byte limit
		before loading it into the destination operand. The translation is performed by shifting the 20-bit "raw" limit left 12
		bits and filling the low-order 12 bits with 1s.
		
		When the operand size is 32 bits, the 32-bit byte limit is stored in the destination operand. When the operand size
		is 16 bits, a valid 32-bit limit is computed; however, the upper 16 bits are truncated and only the low-order 16 bits
		are loaded into the destination operand.
		
		This instruction performs the following checks before it loads the segment limit into the destination register:
		
		- Checks that the segment selector is not NULL.
		- Checks that the segment selector points to a descriptor that is within the limits of the GDT or LDT being accessed
		- Checks that the descriptor type is valid for this instruction. All code and data segment descriptors are valid for
			(can be accessed with) the LSL instruction. The valid special segment and gate descriptor types are given in the
			following table.
		- If the segment is not a conforming code segment, the instruction checks that the specified segment descriptor
			is visible at the CPL (that is, if the CPL and the RPL of the segment selector are less than or equal to the DPL of the segment selector).
		
		If the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no
		value is loaded in the destination operand.

	exceptions

	flags

	operation

	meta


ltr=Load Task Register 
	forms

	description
		Loads the source operand into the segment selector field of the task register. The source operand (a general-
		purpose register or a memory location) contains a segment selector that points to a task state segment (TSS).
		After the segment selector is loaded in the task register, the processor uses the segment selector to locate the
		segment descriptor for the TSS in the global descriptor table (GDT). It then loads the segment limit and base
		address for the TSS from the segment descriptor into the task register. The task pointed to by the task register is
		marked busy, but a switch to the task does not occur.
		
		The LTR instruction is provided for use in operating-system software; it should not be used in application programs.
		It can only be executed in protected mode when the CPL is 0. It is commonly used in initialization code to establish
		the first task to be executed.
		
		The operand-size attribute has no effect on this instruction.
		
		In 64-bit mode, the operand size is still fixed at 16 bits. The instruction references a 16-byte descriptor to load the
		64-bit base.

	exceptions

	flags

	operation

	meta


lzcnt=Count the Number of Leading Zero Bits 
	forms

	description
		Counts the number of leading most significant zero bits in a source operand (second operand) returning the result
		into a destination (first operand).
		
		LZCNT differs from BSR. For example, LZCNT will produce the operand size when the input operand is zero. It
		should be noted that on processors that do not support LZCNT, the instruction byte encoding is executed as BSR.
		
		In 64-bit mode 64-bit operand size requires REX.W=1.

	exceptions

	flags

	operation

	meta


maskmovdqu/vmaskmovdqu=Store Selected Bytes of Double Quadword 
	forms

	description
		Stores selected bytes from the source operand (first operand) into an 128-bit memory location. The mask operand
		(second operand) selects which bytes from the source operand are written to memory. The source and mask oper-
		ands are XMM registers. The memory location specified by the effective address in the DI/EDI/RDI register (the
		default segment register is DS, but this may be overridden with a segment-override prefix). The memory location
		does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size attribute.)
		
		The most significant bit in each byte of the mask operand determines whether the corresponding byte in the source
		operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.
		The MASKMOVDQU instruction generates a non-temporal hint to the processor to minimize cache pollution. The
		non-temporal hint is implemented by using a write combining (WC) memory type protocol (see "Caching of
		Temporal vs. Non-Temporal Data" in Chapter 10, of the Intel 64 and IA-32 Architectures Software Developer's
		Manual, Volume 1). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing opera-
		tion implemented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVDQU
		instructions if multiple processors might use different memory types to read/write the destination memory locations.
		
		Behavior with a mask of all 0s is as follows:
		- No data will be written to memory.
		- Signaling of breakpoints (code or data) is not guaranteed; different processor implementations may signal or not signal these breakpoints.
		- Exceptions associated with addressing memory and page faults may still be signaled (implementation dependent).
		- If the destination memory region is mapped as UC or WP, enforcement of associated semantics for these
			memory types is not guaranteed (that is, is reserved) and is implementation-specific.
		
		The MASKMOVDQU instruction can be used to improve performance of algorithms that need to merge data on a
		byte-by-byte basis. MASKMOVDQU should not cause a read for ownership; doing so generates unnecessary band-
		width since data is to be written directly using the byte-mask without allocating old data prior to the store.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
		
		If VMASKMOVDQU is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will
		cause an #UD exception.

	exceptions

	flags

	operation

	meta


maskmovq=Store Selected Bytes of Quadword 
	forms

	description
		Stores selected bytes from the source operand (first operand) into a 64-bit memory location. The mask operand
		(second operand) selects which bytes from the source operand are written to memory. The source and mask oper-
		ands are MMX technology registers. The memory location specified by the effective address in the DI/EDI/RDI
		register (the default segment register is DS, but this may be overridden with a segment-override prefix). The
		memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the
		address-size attribute.)
		
		The most significant bit in each byte of the mask operand determines whether the corresponding byte in the source
		operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.
		The MASKMOVQ instruction generates a non-temporal hint to the processor to minimize cache pollution. The non-
		temporal hint is implemented by using a write combining (WC) memory type protocol (see "Caching of Temporal
		vs. Non-Temporal Data" in Chapter 10, of the Intel 64 and IA-32 Architectures Software Developer's Manual,
		Volume 1). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation imple-
		mented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVQ instructions if
		multiple processors might use different memory types to read/write the destination memory locations.
		
		This instruction causes a transition from x87 FPU to MMX technology state (that is, the x87 FPU top-of-stack pointer
		is set to 0 and the x87 FPU tag word is set to all 0s [valid]).
		
		The behavior of the MASKMOVQ instruction with a mask of all 0s is as follows:
		- No data will be written to memory.
		- Transition from x87 FPU to MMX technology state will occur.
		- Exceptions associated with addressing memory and page faults may still be signaled (implementation dependent).
		- Signaling of breakpoints (code or data) is not guaranteed (implementation dependent).
		- If the destination memory region is mapped as UC or WP, enforcement of associated semantics for these
			memory types is not guaranteed (that is, is reserved) and is implementation-specific.
		
		The MASKMOVQ instruction can be used to improve performance for algorithms that need to merge data on a byte-
		by-byte basis. It should not cause a read for ownership; doing so generates unnecessary bandwidth since data is
		to be written directly using the byte-mask without allocating old data prior to the store.
		In 64-bit mode, the memory address is specified by DS:RDI.

	exceptions

	flags

	operation

	meta


maxpd/vmaxpd=Return Maximum Packed Double-Precision Floating-Point Values
	forms

	description
		Performs an SIMD compare of the packed double-precision floating-point values in the first source operand and the
		second source operand and returns the maximum value for each pair of values to the destination operand.
		If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is
		returned. If a value in the second operand is an SNaN, that SNaN is forwarded unchanged to the destination (that
		is, a QNaN version of the SNaN is not returned).
		
		If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN
		or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source
		operand (from either the first or second operand) be returned, the action of MAXPD can be emulated using a
		sequence of instructions, such as, a comparison followed by AND, ANDN and OR.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


maxps/vmaxps=Return Maximum Packed Single-Precision Floating-Point Values
	forms

	description
		Performs an SIMD compare of the packed single-precision floating-point values in the first source operand and the
		second source operand and returns the maximum value for each pair of values to the destination operand.
		If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is
		returned. If a value in the second operand is an SNaN, that SNaN is forwarded unchanged to the destination (that
		is, a QNaN version of the SNaN is not returned).
		
		If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN
		or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source
		operand (from either the first or second operand) be returned, the action of MAXPS can be emulated using a
		sequence of instructions, such as, a comparison followed by AND, ANDN and OR.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


maxsd/vmaxsd=Return Maximum Scalar Double-Precision Floating-Point Value 
	forms

	description
		Compares the low double-precision floating-point values in the first source operand and second the source
		operand, and returns the maximum value to the low quadword of the destination operand. The second source
		operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM
		registers. When the second source operand is a memory operand, only 64 bits are accessed. The high quadword of
		the destination operand is copied from the same bits of first source operand.
		
		If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If
		a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a
		QNaN version of the SNaN is not returned).
		
		If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid
		floating-point value, is written to the result. If instead of this behavior, it is required that the NaN of either source
		operand be returned, the action of MAXSD can be emulated using a sequence of instructions, such as, a comparison
		followed by AND, ANDN and OR.
		
		The second source operand can be an XMM register or a 64-bit memory location. The first source and destination
		operands are XMM registers.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:64) of the
		corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


maxss/vmaxss=Return Maximum Scalar Single-Precision Floating-Point Value 
	forms

	description
		Compares the low single-precision floating-point values in the first source operand and the second source operand,
		and returns the maximum value to the low doubleword of the destination operand.
		
		If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If
		a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a
		QNaN version of the SNaN is not returned).
		
		If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid
		floating-point value, is written to the result. If instead of this behavior, it is required that the NaN from either source
		operand be returned, the action of MAXSS can be emulated using a sequence of instructions, such as, a comparison
		followed by AND, ANDN and OR.
		
		The second source operand can be an XMM register or a 32-bit memory location. The first source and destination
		operands are XMM registers.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:32) of the
		corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:32) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


mfence=Memory Fence 
	forms

	description
		Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior
		the MFENCE instruction. This serializing operation guarantees that every load and store instruction that precedes
		the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows
		the MFENCE instruction.1 The MFENCE instruction is ordered with respect to all load and store instructions, other
		MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID
		instruction). MFENCE does not serialize the instruction stream.
		
		Weakly ordered memory types can be used to achieve higher processor performance through such techniques as
		out-of-order issue, speculative reads, write-combining, and write-collapsing. The degree to which a consumer of
		data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the
		producer of this data. The MFENCE instruction provides a performance-efficient way of ensuring load and store
		ordering between routines that produce weakly-ordered results and routines that consume that data.
		
		Processors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and
		WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution. Thus, it
		is not ordered with respect to executions of the MFENCE instruction; data can be brought into the caches specula-
		tively just before, during, or after the execution of an MFENCE instruction.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.
		
		Specification of the instruction's opcode above indicates a ModR/M byte of F0. For this instruction, the processor
		ignores the r/m field of the ModR/M byte. Thus, MFENCE is encoded by any opcode of the form 0F AE Fx, where x
		is in the range 0-7.

	exceptions

	flags

	operation

	meta


minpd/vminpd=Return Minimum Packed Double-Precision Floating-Point Values 
	forms

	description
		Performs an SIMD compare of the packed double-precision floating-point values in the first source operand and the
		second source operand and returns the minimum value for each pair of values to the destination operand.
		If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is
		returned. If a value in the second operand is an SNaN, that SNaN is forwarded unchanged to the destination (that
		is, a QNaN version of the SNaN is not returned).
		
		If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN
		or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source
		operand (from either the first or second operand) be returned, the action of MINPD can be emulated using a
		sequence of instructions, such as, a comparison followed by AND, ANDN and OR.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.

	exceptions

	flags

	operation

	meta


minps/vminps=Return Minimum Packed Single-Precision Floating-Point Values 
	forms

	description
		Performs an SIMD compare of the packed single-precision floating-point values in the first source operand and the
		second source operand and returns the minimum value for each pair of values to the destination operand.
		If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is
		returned. If a value in the second operand is an SNaN, that SNaN is forwarded unchanged to the destination (that
		is, a QNaN version of the SNaN is not returned).
		
		If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN
		or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source
		operand (from either the first or second operand) be returned, the action of MINPS can be emulated using a
		sequence of instructions, such as, a comparison followed by AND, ANDN and OR.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


minsd/vminsd=Return Minimum Scalar Double-Precision Floating-Point Value 
	forms

	description
		Compares the low double-precision floating-point values in the first source operand and the second source
		operand, and returns the minimum value to the low quadword of the destination operand. When the source
		operand is a memory operand, only the 64 bits are accessed. The high quadword of the destination operand is
		copied from the same bits in the first source operand.
		
		If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If
		a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a
		QNaN version of the SNaN is not returned).
		
		If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid
		floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand
		(from either the first or second source) be returned, the action of MINSD can be emulated using a sequence of
		instructions, such as, a comparison followed by AND, ANDN and OR.
		
		The second source operand can be an XMM register or a 64-bit memory location. The first source and destination
		operands are XMM registers.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:64) of the
		corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


minss/vminss=Return Minimum Scalar Single-Precision Floating-Point Value 
	forms

	description
		Compares the low single-precision floating-point values in the first source operand and the second source operand
		and returns the minimum value to the low doubleword of the destination operand.
		
		If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If
		a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN
		version of the SNaN is not returned).
		
		If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid
		floating-point value, is written to the result. If instead of this behavior, it is required that the NaN in either source
		operand be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison
		followed by AND, ANDN and OR.
		
		The second source operand can be an XMM register or a 32-bit memory location. The first source and destination
		operands are XMM registers.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:32) of the
		corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:32) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


monitor=Set Up Monitor Address 
	forms

	description
		The MONITOR instruction arms address monitoring hardware using an address specified in EAX (the address range
		that the monitoring hardware checks for store operations can be determined by using CPUID). A store to an
		address within the specified address range triggers the monitoring hardware. The state of monitor hardware is
		used by MWAIT.
		
		The content of EAX is an effective address (in 64-bit mode, RAX is used). By default, the DS segment is used to
		create a linear address that is monitored. Segment overrides can be used.
		
		ECX and EDX are also used. They communicate other information to MONITOR. ECX specifies optional extensions.
		EDX specifies optional hints; it does not change the architectural behavior of the instruction. For the Pentium 4
		processor (family 15, model 3), no extensions or hints are defined. Undefined hints in EDX are ignored by the
		processor; undefined extensions in ECX raises a general protection fault.
		
		The address range must use memory of the write-back type. Only write-back memory will correctly trigger the
		monitoring hardware. @see(0)
		
		The MONITOR instruction is ordered as a load operation with respect to other memory transactions. The instruction
		is subject to the permission checking and faults associated with a byte load. Like a load, MONITOR sets the A-bit
		but not the D-bit in page tables.
		
		CPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT in the processor. When set,
		MONITOR may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode
		exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE
		MSR; disabling MONITOR clears the CPUID feature flag and causes execution to generate an invalid-opcode excep-
		tion.
		
		The instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta
		see
			Chapter 8 - "Multiple-Processor Management", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A.


mov=Move
	forms

	description
		~General purpose move
			Copies the second operand (source operand) to the first operand (destination operand). The source operand can be
			an immediate value, general-purpose register, segment register, or memory location; the destination register can
			be a general-purpose register, segment register, or memory location. Both operands must be the same size, which
			can be a byte, a word, a doubleword, or a quadword.
			
			The MOV instruction cannot be used to load the CS register. Attempting to do so results in an invalid opcode excep-
			tion (#UD). To load the CS register, use the far JMP, CALL, or RET instruction.
			
			If the destination operand is a segment register (DS, ES, FS, GS, or SS), the source operand must be a valid
			segment selector. In protected mode, moving a segment selector into a segment register automatically causes the
			segment descriptor information associated with that segment selector to be loaded into the hidden (shadow) part
			of the segment register. While loading this information, the segment selector and segment descriptor information
			is validated. The segment descriptor data is obtained from the GDT or LDT entry for the specified segment selector.
			
			A NULL segment selector (values 0000-0003) can be loaded into the DS, ES, FS, and GS registers without causing
			a protection exception. However, any subsequent attempt to reference a segment whose corresponding segment
			register is loaded with a NULL value causes a general protection exception (#GP) and no memory reference occurs.
			Loading the SS register with a MOV instruction inhibits all interrupts until after the execution of the next instruc-
			tion. This operation allows a stack pointer to be loaded into the ESP register with the next instruction (MOV ESP,
			stack-pointer value) before an interrupt occurs. Be aware that the LSS instruction offers a more efficient
			method of loading the SS and ESP registers.
			
			When operating in 32-bit mode and moving data between a segment register and a general-purpose register, the
			32-bit IA-32 processors do not require the use of the 16-bit operand-size prefix (a byte with the value 66H) with
			this instruction, but most assemblers will insert it if the standard form of the instruction is used (for example, MOV
			DS, AX). The processor will execute this instruction correctly, but it will usually require an extra clock. With most
			assemblers, using the instruction form MOV DS, EAX will avoid this unneeded 66H prefix. When the processor
			executes the instruction with a 32-bit general-purpose register, it assumes that the 16 least-significant bits of the
			general-purpose register are the destination or source operand. If the register is a destination operand, the
			resulting value in the two high-order bytes of the register is implementation dependent. For the Pentium 4, Intel
			Xeon, and P6 family processors, the two high-order bytes are filled with zeros; for earlier 32-bit IA-32 processors,
			the two high order bytes are undefined.
			
			In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
			tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
			beginning of this section for encoding data and limits.
		
		~Control register move
			Moves the contents of a control register (CR0, CR2, CR3, CR4, or CR8) to a general-purpose register or the
			contents of a general purpose register to a control register. The operand size for these instructions is always 32 bits
			in non-64-bit modes, regardless of the operand-size attribute. (See @see(control) for a detailed description of the flags and
			fields in the control registers.) This instruction can be executed only when the current privilege level is 0.
			At the opcode level, the reg field within the ModR/M byte specifies which of the control registers is loaded or read.
			The 2 bits in the mod field are ignored. The r/m field specifies the general-purpose register loaded or read.
			Attempts to reference CR1, CR5, CR6, CR7, and CR9-CR15 result in undefined opcode (#UD) exceptions.
			
			When loading control registers, programs should not attempt to change the reserved bits; that is, always set
			reserved bits to the value previously read. An attempt to change CR4's reserved bits will cause a general protection
			fault. Reserved bits in CR0 and CR3 remain clear after any load of those registers; attempts to set them have no
			impact. On Pentium 4, Intel Xeon and P6 family processors, CR0.ET remains set after any load of CR0; attempts to
			clear this bit have no impact.
			
			In certain cases, these instructions have the side effect of invalidating entries in the TLBs and the paging-structure
			caches. @see(caches).
			
			The following side effects are implementation-specific for the Pentium 4, Intel Xeon, and P6 processor family: when
			modifying PE or PG in register CR0, or PSE or PAE in register CR4, all TLB entries are flushed, including global
			entries. Software should not depend on this functionality in all Intel 64 or IA-32 processors.
			In 64-bit mode, the instruction's default operation size is 64 bits. The REX.R prefix must be used to access CR8. Use
			of REX.B permits access to additional registers (R8-R15). Use of the REX.W prefix or 66H prefix is ignored. Use of
			the REX.R prefix to specify a register other than CR8 causes an invalid-opcode exception. See the summary chart
			at the beginning of this section for encoding data and limits.
			
			If CR4.PCIDE = 1, bit 63 of the source operand to MOV to CR3 determines whether the instruction invalidates
			entries in the TLBs and the paging-structure caches (@see(caches)). The
			instruction does not modify bit 63 of CR3, which is reserved and always 0. 
			@see(vmx) for more information about the behavior of this instruction in VMX non-root operation.
		
		~Move to/from debug registers
			Moves the contents of a debug register (DR0, DR1, DR2, DR3, DR4, DR5, DR6, or DR7) to a general-purpose
			register or vice versa. The operand size for these instructions is always 32 bits in non-64-bit modes, regardless of
			the operand-size attribute. (@see(debug) for a detailed description of the flags and fields in the debug registers.)
			
			The instructions must be executed at privilege level 0 or in real-address mode.
			
			When the debug extension (DE) flag in register CR4 is clear, these instructions operate on debug registers in a
			manner that is compatible with Intel386 and Intel486 processors. In this mode, references to DR4 and DR5 refer
			to DR6 and DR7, respectively. When the DE flag in CR4 is set, attempts to reference DR4 and DR5 result in an
			undefined opcode (#UD) exception. (The CR4 register was added to the IA-32 Architecture beginning with the Pentium processor.)
			
			At the opcode level, the reg field within the ModR/M byte specifies which of the debug registers is loaded or read.
			The two bits in the mod field are ignored. The r/m field specifies the general-purpose register loaded or read.
			In 64-bit mode, the instruction's default operation size is 64 bits. Use of the REX.B prefix permits access to addi-
			tional registers (R8-R15). Use of the REX.W or 66H prefix is ignored. Use of the REX.R prefix causes an invalid-
			opcode exception. See the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta
		see
			control => Chapter 2 - "Control Registers", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A
			caches => Section 4.10.4.1 - "Operations that Invalidate TLBs and Paging-Structure Caches,", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A
			debug => Section 17.2 - "Debug Registers", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A
			vmx => Chapter 25 - "Changes to Instruction Behavior in VMX Non-Root Operation", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3C


movapd/vmovapd=Move Aligned Packed Double-Precision Floating-Point Values
	forms

	description
		Moves 2 or 4 double-precision floating-point values from the source operand (second operand) to the destination
		operand (first operand). This instruction can be used to load an XMM or YMM register from an 128-bit or 256-bit
		memory location, to store the contents of an XMM or YMM register into a 128-bit or 256-bit memory location, or to
		move data between two XMM or two YMM registers. When the source or destination operand is a memory operand,
		the operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary or a
		general-protection exception (#GP) will be generated.
		
		To move double-precision floating-point values to and from unaligned memory locations, use the @ref(movupd/vmovupd) instruction.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit versions: Moves 128 bits of packed double-precision floating-point values from the source operand (second
		operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a
		128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data
		between two XMM registers. When the source or destination operand is a memory operand, the operand must be
		aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision
		floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register destination are zeroed.
		
		VEX.256 encoded version: Moves 256 bits of packed double-precision floating-point values from the source
		operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM
		register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location,
		or to move data between two YMM registers. When the source or destination operand is a memory operand, the
		operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated. To
		move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


movaps/vmovaps=Move Aligned Packed Single-Precision Floating-Point Values 
	forms

	description
		Moves 4 or8 single-precision floating-point values from the source operand (second operand) to the destination
		operand (first operand). This instruction can be used to load an XMM or YMM register from an 128-bit or 256-bit
		memory location, to store the contents of an XMM or YMM register into a 128-bit or 256-bit memory location, or to
		move data between two XMM or two YMM registers. When the source or destination operand is a memory operand,
		the operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary or a
		general-protection exception (#GP) will be generated.
		
		To move single-precision floating-point values to and from unaligned memory locations, use the @ref(movups/vmovups) instruction.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
		
		128-bit versions:
		Moves 128 bits of packed single-precision floating-point values from the source operand (second operand) to the
		destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory
		location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two
		XMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a
		16-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision floating-
		point values to and from unaligned memory locations, use the VMOVUPS instruction.
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version:
		Moves 256 bits of packed single-precision floating-point values from the source operand (second operand) to the
		destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory
		location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM
		registers.

	exceptions

	flags

	operation

	meta


movbe=Move Data After Swapping Bytes
	forms

	description
		Performs a byte swap operation on the data copied from the second operand (source operand) and store the result
		in the first operand (destination operand). The source operand can be a general-purpose register, or memory loca-
		tion; the destination register can be a general-purpose register, or a memory location; however, both operands can
		not be registers, and only one operand can be a memory location. Both operands must be the same size, which can
		be a word, a doubleword or quadword.
		
		The MOVBE instruction is provided for swapping the bytes on a read from memory or on a write to memory; thus
		providing support for converting little-endian values to big-endian format and vice versa.
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
		tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


movd=Move Doubleword
movq=Move Quadword 
	forms

	description
		Copies a doubleword from the source operand (second operand) to the destination operand (first operand). The
		source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or
		32-bit memory locations. This instruction can be used to move a doubleword to and from the low doubleword of an
		MMX technology register and a general-purpose register or a 32-bit memory location, or to and from the low
		doubleword of an XMM register and a general-purpose register or a 32-bit memory location. The instruction cannot
		be used to transfer data between MMX technology registers, between XMM registers, between general-purpose
		registers, or between memory locations.
		
		When the destination operand is an MMX technology register, the source operand is written to the low doubleword
		of the register, and the register is zero-extended to 64 bits. When the destination operand is an XMM register, the
		source operand is written to the low doubleword of the register, and the register is zero-extended to 128 bits.
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
		tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
		beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


movddup/vmovddup=Move One Double-FP and Duplicate 
	forms

	description
		The linear address corresponds to the address of the least-significant byte of the referenced memory data. When a
		memory address is indicated, the 8 bytes of data at memory location m64 are loaded. When the register-register
		form of this operation is used, the lower half of the 128-bit source register is duplicated and copied into the 128-bit
		destination register.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


movdqa/vmovdqa=Move Aligned Double Quadword 
	forms

	description
		128-bit versions:
		Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand
		(first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the
		contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.
		When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary
		or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory
		locations, use the @ref(movdqu) instruction.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain
		unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version:
		Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand
		(first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the
		contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.
		When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary
		or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory
		locations, use the @ref(vmovdqu) instruction.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


movdqu/vmovdqu=Move Unaligned Double Quadword 
	forms

	description
		128-bit versions:
		Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand
		(first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the
		contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When
		the source or destination operand is a memory operand, the operand may be unaligned on a 16-byte boundary
		without causing a general-protection exception (#GP) to be generated.
		
		To move a double quadword to or from memory locations that are known to be aligned on 16-byte boundaries, use
		the @ref(movdqa) instruction.
		
		While executing in 16-bit addressing mode, a linear address for a 128-bit data access that overlaps the end of a 16-
		bit segment is not allowed and is defined as reserved behavior. A specific processor implementation may or may
		not generate a general-protection exception (#GP) in this situation, and the address that spans the end of the
		segment may or may not wrap around to the beginning of the segment.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		When the source or destination operand is a memory operand, the operand may be unaligned to any alignment
		without causing a general-protection exception (#GP) to be generated
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: Moves 256 bits of packed integer values from the source operand (second operand) to
		the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory
		location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


movdq2q=Move Quadword from XMM to MMX Technology Register 
	forms

	description
		Moves the low quadword from the source operand (second operand) to the destination operand (first operand). The
		source operand is an XMM register and the destination operand is an MMX technology register.
		
		This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
		pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
		floating-point exception is pending, the exception is handled before the MOVDQ2Q instruction is executed.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


movhlps=Move Packed Single-Precision Floating-Point Values High to Low
	forms

	description
		Moves two packed single-precision floating-point values from the high quadword of the second XMM argument
		(second operand) to the low quadword of the first XMM register (first argument). The high quadword of the destination
		operand is left unchanged. Bits (VLMAX-1:64) of the corresponding YMM destination register are unmodified.

	exceptions

	flags

	operation

	meta


vmovhlps=Merge Packed Single-Precision Floating-Point Values High to Low
	forms

	description
		Moves two packed single-precision floating-point values from the high quadword of the third XMM argument (third
		operand) to the low quadword of the destination (first operand). Copies the high quadword from the second XMM
		argument (second operand) to the high quadword of the destination (first operand). Bits (VLMAX-1:128) of the
		destination YMM register are zeroed.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		
		If VMOVHLPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause
		an #UD exception.

	exceptions

	flags

	operation

	meta


movhpd=Move High Packed Double-Precision Floating-Point Value
	forms

	description
		Moves a double-precision floating-point value from the source 64-bit memory operand and stores it in the high 64-
		bits of the destination XMM register. The lower 64bits of the XMM register are preserved. The upper 128-bits of the
		corresponding YMM destination register are preserved.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta

vmovhpd=Move/Merge High Packed Double-Precision Floating-Point Value
	forms

	description
		~VEX.128 encoded load
			Loads a double-precision floating-point value from the source 64-bit memory operand (third operand) and stores
			it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from second XMM register
			(second operand) are stored in the lower 64-bits of the destination. The upper 128-bits of the destination YMM
			register are zeroed.
		
		~128-bit store
			Stores a double-precision floating-point value from the high 64-bits of the XMM register source (second operand)
			to the 64-bit memory location (first operand).
			Note: VMOVHPD (store) (VEX.128.66.0F 17 /r) is legal and has the same behavior as the existing 66 0F 17 store.
			For VMOVHPD (store) (VEX.128.66.0F 17 /r) instruction version, VEX.vvvv is reserved and must be 1111b other-
			wise instruction will #UD.
		
		If VMOVHPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.

	exceptions

	flags

	operation

	meta


movhps=Move High Packed Single-Precision Floating-Point Values
	forms

	description
		Moves two packed single-precision floating-point values from the source 64-bit memory operand and stores them
		in the high 64-bits of the destination XMM register. The lower 64bits of the XMM register are preserved. The upper
		128-bits of the corresponding YMM destination register are preserved.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta

vmovhps=Move/Merge High Packed Single-Precision Floating-Point Values
	forms

	description
		~VEX.128 encoded load
			Loads two single-precision floating-point values from the source 64-bit memory operand (third operand) and
			stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from second XMM
			register (second operand) are stored in the lower 64-bits of the destination. The upper 128-bits of the destination
			YMM register are zeroed.
		
		~128-bit store
			Stores two packed single-precision floating-point values from the high 64-bits of the XMM register source (second
			operand) to the 64-bit memory location (first operand).
			Note: VMOVHPS (store) (VEX.NDS.128.0F 17 /r) is legal and has the same behavior as the existing 0F 17 store.
			For VMOVHPS (store) (VEX.NDS.128.0F 17 /r) instruction version, VEX.vvvv is reserved and must be 1111b other-
			wise instruction will #UD.
			If VMOVHPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.

	exceptions

	flags

	operation

	meta


movlhps=Move Packed Single-Precision Floating-Point Values Low to High 
	forms

	description
		Moves two packed single-precision floating-point values from the low quadword of the second XMM argument
		(second operand) to the high quadword of the first XMM register (first argument). 
		The low quadword of the destination operand is left unchanged.
		The upper 128 bits of the corresponding YMM destination register are unmodified.

	exceptions

	flags

	operation

	meta

vmovlhps=Merge Packed Single-Precision Floating-Point Values Low to High 
	forms

	description
		Moves two packed single-precision floating-point values from the low quadword of the third XMM argument (third
		operand) to the high quadword of the destination (first operand). Copies the low quadword from the second XMM
		argument (second operand) to the low quadword of the destination (first operand). The upper 128-bits of the
		destination YMM register are zeroed.
		
		If VMOVLHPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


movlpd=Move Low Packed Double-Precision Floating-Point Value 
	forms

	description
		Moves a double-precision floating-point value from the source 64-bit memory operand and stores it in the low 64-
		bits of the destination XMM register. The upper 64bits of the XMM register are preserved. The upper 128-bits of the
		corresponding YMM destination register are preserved.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


vmovlpd=Move/Merge Low Packed Double-Precision Floating-Point Value 
	forms

	description
		~VEX.128 encoded load
			Loads a double-precision floating-point value from the source 64-bit memory operand (third operand), merges it
			with the upper 64-bits of the first source XMM register (second operand), and stores it in the low 128-bits of the
			destination XMM register (first operand). The upper 128-bits of the destination YMM register are zeroed.
		
		~128-bit store
			Stores a double-precision floating-point value from the low 64-bits of the XMM register source (second operand) to
			the 64-bit memory location (first operand).
			
			Note: VMOVLPD (store) (VEX.128.66.0F 13 /r) is legal and has the same behavior as the existing 66 0F 13 store.
			For VMOVLPD (store) (VEX.128.66.0F 13 /r) instruction version, VEX.vvvv is reserved and must be 1111b other-
			wise instruction will #UD.
			
		If VMOVLPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.

	exceptions

	flags

	operation

	meta


movlps=Move Low Packed Single-Precision Floating-Point Values 
	forms

	description
		Moves two packed single-precision floating-point values from the source 64-bit memory operand and stores them
		in the low 64-bits of the destination XMM register. The upper 64bits of the XMM register are preserved. The upper
		128-bits of the corresponding YMM destination register are preserved.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta

vmovlps=Move/Merge Low Packed Single-Precision Floating-Point Values 
	forms

	description
		~VEX.128 encoded load
			Loads two packed single-precision floating-point values from the source 64-bit memory operand (third operand),
			merges them with the upper 64-bits of the first source XMM register (second operand), and stores them in the low
			128-bits of the destination XMM register (first operand). The upper 128-bits of the destination YMM register are zeroed.
		
		~128-bit store
			Loads two packed single-precision floating-point values from the low 64-bits of the XMM register source (second
			operand) to the 64-bit memory location (first operand).
			Note: VMOVLPS (store) (VEX.128.0F 13 /r) is legal and has the same behavior as the existing 0F 13 store. For
			VMOVLPS (store) (VEX.128.0F 13 /r) instruction version, VEX.vvvv is reserved and must be 1111b otherwise
			instruction will #UD.
		
		If VMOVLPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.

	exceptions

	flags

	operation

	meta


movmskpd/vmovmskpd=Extract Packed Double-Precision Floating-Point Sign Mask 
	forms

	description
		Extracts the sign bits from the packed double-precision floating-point values in the source operand (second
		operand), formats them into a 2-bit mask, and stores the mask in the destination operand (first operand). The
		source operand is an XMM register, and the destination operand is a general-purpose register. The mask is stored
		in the 2 low-order bits of the destination operand. Zero-extend the upper bits of the destination.
		
		In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R
		prefix. The default operand size is 64-bit in 64-bit mode.
		
		128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.
		VEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


movmskps/vmovmskps=Extract Packed Single-Precision Floating-Point Sign Mask 
	forms

	description
		Extracts the sign bits from the packed single-precision floating-point values in the source operand (second
		operand), formats them into a 4- or 8-bit mask, and stores the mask in the destination operand (first operand).
		The source operand is an XMM or YMM register, and the destination operand is a general-purpose register. The
		mask is stored in the 4 or 8 low-order bits of the destination operand. The upper bits of the destination operand
		beyond the mask are filled with zeros.
		
		In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R
		prefix. The default operand size is 64-bit in 64-bit mode.
		
		128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.
		VEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


movntdqa/vmovntdqa=Load Double Quadword Non-Temporal Aligned Hint 
	forms

	description
		(V)MOVNTDQA loads a double quadword from the source operand (second operand) to the destination operand
		(first operand) using a non-temporal hint. A processor implementation may make use of the non-temporal hint
		associated with this instruction if the memory source is WC (write combining) memory type. An implementation
		may also make use of the non-temporal hint associated with this instruction if the memory source is WB (write
		back) memory type.
		
		A processor's implementation of the non-temporal hint does not override the effective memory type semantics, but
		the implementation of the hint is processor dependent. For example, a processor implementation may choose to
		ignore the hint and process the instruction as a normal @ref(movdqa) for any memory type. Another implementation of
		the hint for WC memory type may optimize data transfer throughput of WC reads. A third implementation may
		optimize cache reads generated by (V)MOVNTDQA on WB memory type to reduce cache evictions.
		
		~WC Streaming Load Hint
			For WC memory type in particular, the processor never appears to read the data into the cache hierarchy. Instead,
			the non-temporal hint may be implemented by loading a temporary internal buffer with the equivalent of an
			aligned cache line without filling this data to the cache. Any memory-type aliased lines in the cache will be snooped
			and flushed. Subsequent MOVNTDQA reads to unread portions of the WC cache line will receive data from the
			temporary internal buffer if data is available. The temporary internal buffer may be flushed by the processor at any
			time for any reason, for example:
			- A load operation other than a (V)MOVNTDQA which references memory already resident in a temporary internal buffer.
			- A non-WC reference to memory already resident in a temporary internal buffer.
			- Interleaving of reads and writes to memory currently residing in a single temporary internal buffer.
			- Repeated (V)MOVNTDQA loads of a particular 16-byte item in a streaming line.
			- Certain micro-architectural conditions including resource shortages, detection of a mis-speculation condition, and various fault conditions
			
			The memory type of the region being read can override the non-temporal hint, if the memory address specified for
			the non-temporal read is not a WC memory region.
			@see(cache) for more information on non-temporal reads and writes.
			
			Because the WC protocol uses a weakly-ordered memory consistency model, an MFENCE or locked instruction
			should be used in conjunction with MOVNTDQA instructions if multiple processors might reference the same WC
			memory locations or in order to synchronize reads of a processor with writes by other agents in the system.
			Because of the speculative nature of fetching due to MOVNTDQA, Streaming loads must not be used to reference
			memory addresses that are mapped to I/O devices having side effects or when reads to these devices are destruc-
			tive. For additional information on MOVNTDQA usages, @see(sse).
		
		The 128-bit (V)MOVNTDQA addresses must be 16-byte aligned or the instruction will cause a #GP.
		The 256-bit VMOVNTDQA addresses must be 32-byte aligned or the instruction will cause a #GP.
		Note: In VEX-128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0; otherwise instruc-
		tions will #UD.

	exceptions

	flags

	operation

	meta
		see
			cache => Chapter 11 - "Memory Cache Control", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A
			sse => Section 12.10.3 - "Programming with SSE3, SSSE3 and SSE4", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


movntdq/vmovntdq=Store Double Quadword Using Non-Temporal Hint
	forms

	description
		Moves the packed integers in the source operand (second operand) to the destination operand (first operand) using
		a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM
		register or YMM register, which is assumed to contain integer data (packed bytes, words, doublewords, or quad-
		words). The destination operand is a 128-bit or 256-bit memory location. The memory operand must be aligned on
		a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary otherwise a general-protection
		exception (#GP) will be generated.
		
		The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the
		data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it
		fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being
		written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an
		uncacheable (UC) or write protected (WP) memory region.
		For more information on non-temporal stores, @see(cache).
		
		Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented
		with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTDQ instructions if multiple
		processors might use different memory types to read/write the destination memory locations.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		Note: In VEX-128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0; otherwise instruc-
		tions will #UD.

	exceptions

	flags

	operation

	meta
		see
			cache => Chapter 10 - "Caching of Temporal vs. Non-Temporal Data", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1

movnti=Store Doubleword Using Non-Temporal Hint
	forms

	description
		Moves the doubleword integer in the source operand (second operand) to the destination operand (first operand)
		using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is a
		general-purpose register. The destination operand is a 32-bit memory location.
		
		The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the
		data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it
		fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being
		written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an
		uncacheable (UC) or write protected (WP) memory region.
		For more information on non-temporal stores, @see(cache).
		
		Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented
		with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTI instructions if multiple proces-
		sors might use different memory types to read/write the destination memory locations.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
		tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
		beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta
		see
			cache => Chapter 10 - "Caching of Temporal vs. Non-Temporal Data", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


movntpd/vmovntpd=Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint 
	forms

	description
		Moves the packed double-precision floating-point values in the source operand (second operand) to the destination
		operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The
		source operand is an XMM register or YMM register, which is assumed to contain packed double-precision, floating-
		pointing data. The destination operand is a 128-bit or 256-bit memory location. The memory operand must be
		aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary otherwise a general-
		protection exception (#GP) will be generated.
		
		The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the
		data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it
		fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being
		written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an
		uncacheable (UC) or write protected (WP) memory region. 
		For more information on non-temporal stores, @see(cache).
		
		Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented
		with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPD instructions if multiple
		processors might use different memory types to read/write the destination memory locations.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		Note: In VEX-128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0; otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta
		see
			cache => Chapter 10 - "Caching of Temporal vs. Non-Temporal Data", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


movntps/vmovntps=Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint 
	forms

	description
		Moves the packed single-precision floating-point values in the source operand (second operand) to the destination
		operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The
		source operand is an XMM register or YMM register, which is assumed to contain packed single-precision, floating-
		pointing. The destination operand is a 128-bit or 256-bit memory location. The memory operand must be aligned
		on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary otherwise a general-protection
		exception (#GP) will be generated.
		
		The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the
		data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it
		fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being
		written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an
		uncacheable (UC) or write protected (WP) memory region.
		For more information on non-temporal stores, @see(cache).
		
		Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented
		with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPS instructions if multiple
		processors might use different memory types to read/write the destination memory locations.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta
		see
			cache => Chapter 10 - "Caching of Temporal vs. Non-Temporal Data", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


movntq=Store of Quadword Using Non-Temporal Hint 
	forms

	description
		Moves the quadword in the source operand (second operand) to the destination operand (first operand) using a
		non-temporal hint to minimize cache pollution during the write to memory. The source operand is an MMX tech-
		nology register, which is assumed to contain packed integer data (packed bytes, words, or doublewords). The
		destination operand is a 64-bit memory location.
		
		The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the
		data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it
		fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being
		written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an
		uncacheable (UC) or write protected (WP) memory region.
		For more information on non-temporal stores, @see(cache).
		
		Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented
		with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTQ instructions if multiple proces-
		sors might use different memory types to read/write the destination memory locations.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta
		see
			cache => Chapter 10 - "Caching of Temporal vs. Non-Temporal Data", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


movq/vmovq=Move Quadword 
	forms

	description
		Copies a quadword from the source operand (second operand) to the destination operand (first operand). The
		source and destination operands can be MMX technology registers, XMM registers, or 64-bit memory locations. This
		instruction can be used to move a quadword between two MMX technology registers or between an MMX tech-
		nology register and a 64-bit memory location, or to move data between two XMM registers or between an XMM
		register and a 64-bit memory location. The instruction cannot be used to transfer data between memory locations.
		
		When the source operand is an XMM register, the low quadword is moved; when the destination operand is an XMM
		register, the quadword is stored to the low quadword of the register, and the high quadword is cleared to all 0s.
		In 64-bit mode, use of the REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Note: In VEX.128.66.0F D6 instruction version, VEX.vvvv and VEX.L=1 are reserved and the former must be 1111b
		otherwise instructions will #UD.
		
		Note: In VEX.128.F3.0F 7E version, VEX.vvvv and VEX.L=1 are reserved and the former must be 1111b, otherwise
		instructions will #UD.

	exceptions

	flags

	operation

	meta


movq2dq=Move Quadword from MMX Technology to XMM Register 
	forms

	description
		Moves the quadword from the source operand (second operand) to the low quadword of the destination operand
		(first operand). The source operand is an MMX technology register and the destination operand is an XMM register.
		
		This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
		pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
		floating-point exception is pending, the exception is handled before the MOVQ2DQ instruction is executed.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


movs/movsb/movsw/movsd/movsq=Move Data from String to String 
	forms

	description
		Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified
		with the first operand (destination operand). Both the source and destination operands are located in memory. The
		address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attri-
		bute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or
		the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be
		overridden with a segment override prefix, but the ES segment cannot be overridden.
		
		At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
		operands" form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination
		operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the
		size and location of the source value and the destination, respectively. This explicit-operands form is provided to
		allow documentation; however, note that the documentation provided by this form can be misleading. That is, the
		source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or
		doublewords), but they do not have to specify the correct location. The locations of the source and destination
		operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the
		move string instruction is executed.
		
		The no-operands form provides "short forms" of the byte, word, and doubleword versions of the MOVS instruc-
		tions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The
		size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word
		move), or MOVSD (doubleword move).
		
		After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according
		to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incremented;
		if the DF flag is 1, the (E)SI and (E)DI registers are decremented.) The registers are incremented or
		decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.
		
		To improve performance, more recent processors support modifications to the processor's
		operation during the string store operations initiated with MOVS and MOVSB. 
		@see(strings) for additional information on fast-string operation.
		
		The MOVS, MOVSB, MOVSW, and MOVSD instructions can be preceded by the @ref(rep) prefix for block moves of ECX bytes, words, or doublewords.
		
		In 64-bit mode, the instruction's default address size is 64 bits, 32-bit address size is supported using the prefix
		67H. The 64-bit addresses are specified by RSI and RDI; 32-bit address are specified by ESI and EDI. Use of the
		REX.W prefix promotes doubleword operation to 64 bits. See the summary chart at the beginning of this section for
		encoding data and limits.

	exceptions

	flags

	operation

	meta
		see
			strings => Section 7.3.9.3 - "Fast String Operations", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


movsd/vmovsd=Move/Merge Scalar Double-Precision Floating-Point Value 
	forms

	description
		MOVSD moves a scalar double-precision floating-point value from the source operand (second operand) to the
		destination operand (first operand). The source and destination operands can be XMM registers or 64-bit memory
		locations. This instruction can be used to move a double-precision floating-point value to and from the low quad-
		word of an XMM register and a 64-bit memory location, or to move a double-precision floating-point value between
		the low quadwords of two XMM registers. The instruction cannot be used to transfer data between memory locations.
		
		For non-VEX encoded instruction syntax and when the source and destination operands are XMM registers, the
		high quadword of the destination operand remains unchanged. When the source operand is a memory location and
		destination operand is an XMM registers, the high quadword of the destination operand is cleared to all 0s.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		Note: For the "VMOVSD m64, xmm1" (memory store form) instruction version, VEX.vvvv is reserved and must be
		1111b, otherwise instruction will #UD.
		
		Note: For the "VMOVSD xmm1, m64" (memory load form) instruction version, VEX.vvvv is reserved and must be
		1111b otherwise instruction will #UD.
		
		VEX encoded instruction syntax supports two source operands and a destination operand if ModR/M.mod field is
		11B. VEX.vvvv is used to encode the first source operand (the second operand). The low 128 bits of the destination
		operand stores the result of merging the low quadword of the second source operand with the quad word in bits
		127:64 of the first source operand. The upper bits of the destination operand are cleared.

	exceptions

	flags

	operation

	meta


movshdup/vmovshdup=Move Packed Single-FP High and Duplicate
	forms

	description
		The linear address corresponds to the address of the least-significant byte of the referenced memory data. When
		a memory address is indicated, the 16 bytes of data at memory location m128 are loaded and the single-precision
		elements in positions 1 and 3 are duplicated. When the register-register form of this operation is used, the same
		operation is performed but with data coming from the 128-bit source register.
		
		In 64-bit mode, use of the REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain
		unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


movsldup/vmovsldup=Move Packed Single-FP Low and Duplicate 
	forms

	description
		The linear address corresponds to the address of the least-significant byte of the referenced memory data. When
		a memory address is indicated, the 16 bytes of data at memory location m128 are loaded and the single-precision
		elements in positions 0 and 2 are duplicated. When the register-register form of this operation is used, the same
		operation is performed but with data coming from the 128-bit source register.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


movss/vmovss=Move Scalar Single-Precision Floating-Point Values 
	forms

	description
		Moves a scalar single-precision floating-point value from the source operand (second operand) to the destination
		operand (first operand). The source and destination operands can be XMM registers or 32-bit memory locations.
		This instruction can be used to move a single-precision floating-point value to and from the low doubleword of an
		XMM register and a 32-bit memory location, or to move a single-precision floating-point value between the low
		doublewords of two XMM registers. The instruction cannot be used to transfer data between memory locations.
		For non-VEX encoded syntax and when the source and destination operands are XMM registers, the high double-
		words of the destination operand remains unchanged. When the source operand is a memory location and destina-
		tion operand is an XMM registers, the high doublewords of the destination operand is cleared to all 0s.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		
		VEX encoded instruction syntax supports two source operands and a destination operand if ModR/M.mod field is
		11B. VEX.vvvv is used to encode the first source operand (the second operand). The low 128 bits of the destination
		operand stores the result of merging the low dword of the second source operand with three dwords in bits 127:32
		of the first source operand. The upper bits of the destination operand are cleared.
		
		Note: For the "VMOVSS m32, xmm1" (memory store form) instruction version, VEX.vvvv is reserved and must be
		1111b otherwise instruction will #UD.
		
		Note: For the "VMOVSS xmm1, m32" (memory load form) instruction version, VEX.vvvv is reserved and must be
		1111b otherwise instruction will #UD.

	exceptions

	flags

	operation

	meta


movsx/movsxd=Move with Sign-Extension 
	forms

	description
		Copies the contents of the source operand (register or memory location) to the destination operand (register) and
		sign extends the value to 16 or 32 bits. The size of the converted value depends on the operand-size attribute.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
		tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
		beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


movupd/vmovupd=Move Unaligned Packed Double-Precision Floating-Point Values 
	forms

	description
		128-bit versions:
		Moves a double quadword containing two packed double-precision floating-point values from the source operand
		(second operand) to the destination operand (first operand). This instruction can be used to load an XMM register
		from a 128-bit memory location, store the contents of an XMM register into a 128-bit memory location, or move
		data between two XMM registers.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		When the source or destination operand is a memory operand, the operand may be unaligned on a 16-byte
		boundary without causing a general-protection exception (#GP) to be generated. 
		
		To move double-precision floating-point values to and from memory locations that are known to be aligned on 16-
		byte boundaries, use the MOVAPD instruction.
		
		While executing in 16-bit addressing mode, a linear address for a 128-bit data access that overlaps the end of a 16-
		bit segment is not allowed and is defined as reserved behavior. A specific processor implementation may or may
		not generate a general-protection exception (#GP) in this situation, and the address that spans the end of the
		segment may or may not wrap around to the beginning of the segment.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: Moves 256 bits of packed double-precision floating-point values from the source
		operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM
		register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location,
		or to move data between two YMM registers.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


movups/vmovups=Move Unaligned Packed Single-Precision Floating-Point Values
	forms

	description
		128-bit versions: Moves a double quadword containing four packed single-precision floating-point values from the
		source operand (second operand) to the destination operand (first operand). This instruction can be used to load
		an XMM register from a 128-bit memory location, store the contents of an XMM register into a 128-bit memory
		location, or move data between two XMM registers.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		When the source or destination operand is a memory operand, the operand may be unaligned on a 16-byte
		boundary without causing a general-protection exception (#GP) to be generated. 
		
		To move packed single-precision floating-point values to and from memory locations that are known to be aligned
		on 16-byte boundaries, use the MOVAPS instruction.
		
		While executing in 16-bit addressing mode, a linear address for a 128-bit data access that overlaps the end of a 16-
		bit segment is not allowed and is defined as reserved behavior. A specific processor implementation may or may
		not generate a general-protection exception (#GP) in this situation, and the address that spans the end of the
		segment may or may not wrap around to the beginning of the segment.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: Moves 256 bits of packed single-precision floating-point values from the source operand
		(second operand) to the destination operand (first operand). This instruction can be used to load a YMM register
		from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move
		data between two YMM registers.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


movzx=Move with Zero-Extend 
	forms

	description
		Copies the contents of the source operand (register or memory location) to the destination operand (register) and
		zero extends the value. The size of the converted value depends on the operand-size attribute.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
		tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bit operands. See the summary chart
		at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


mpsadbw/vmpsadbw=Compute Multiple Packed Sums of Absolute Difference 
	forms

	description
		(V)MPSADBW calculates packed word results of sum-absolute-difference (SAD) of unsigned bytes from two blocks
		of 32-bit dword elements, using two select fields in the immediate byte to select the offsets of the two blocks within
		the first source operand and the second operand. Packed SAD word results are calculated within each 128-bit lane.
		Each SAD word result is calculated between a stationary block_2 (whose offset within the second source operand
		is selected by a two bit select control, multiplied by 32 bits) and a sliding block_1 at consecutive byte-granular
		position within the first source operand. The offset of the first 32-bit block of block_1 is selectable using a one bit
		select control, multiplied by 32 bits.
		
		128-bit Legacy SSE version: Imm8[1:0]*32 specifies the bit offset of block_2 within the second source operand.
		Imm[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source operand
		and destination operand are the same. The first source and destination operands are XMM registers. The second
		source operand is either an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding
		YMM destination register remain unchanged. Bits 7:3 of the immediate byte are ignored.
		
		VEX.128 encoded version: Imm8[1:0]*32 specifies the bit offset of block_2 within the second source operand.
		Imm[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source and desti-
		nation operands are XMM registers. The second source operand is either an XMM register or a 128-bit memory
		location. Bits (127:128) of the corresponding YMM register are zeroed. Bits 7:3 of the immediate byte are ignored.
		VEX.256 encoded version: The sum-absolute-difference (SAD) operation is repeated 8 times for MPSADW between
		the same block_2 (fixed offset within the second source operand) and a variable block_1 (offset is shifted by 8 bits
		for each SAD operation) in the first source operand. Each 16-bit result of eight SAD operations between block_2
		and block_1 is written to the respective word in the lower 128 bits of the destination operand.
		
		Additionally, VMPSADBW performs another eight SAD operations on block_4 of the second source operand and
		block_3 of the first source operand. (Imm8[4:3]*32 + 128) specifies the bit offset of block_4 within the second
		source operand. (Imm[5]*32+128) specifies the initial bit offset of the block_3 within the first source operand.
		Each 16-bit result of eight SAD operations between block_4 and block_3 is written to the respective word in the
		upper 128 bits of the destination operand.
		
		The first source operand is a YMM register. The second source register can be a YMM register or a 256-bit memory
		location. The destination operand is a YMM register. Bits 7:6 of the immediate byte are ignored.
		
		Note: If VMPSADBW is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will
		cause an #UD exception.

	exceptions

	flags

	operation

	meta


mul=Unsigned Multiply
	forms

	description
		Performs an unsigned multiplication of the first operand (destination operand) and the second operand (source
		operand) and stores the result in the destination operand. The destination operand is an implied operand located
		in register AL, AX or EAX (depending on the size of the operand); the source operand is located in a general-
		purpose register or a memory location. The action of this instruction and the location of the result depends on the
		opcode and the operand size as shown in Table 3-65.
		
		The result is stored in register AX, register pair DX:AX, or register pair EDX:EAX (depending on the operand size),
		with the high-order bits of the product contained in register AH, DX, or EDX, respectively. If the high-order bits of
		the product are 0, the CF and OF flags are cleared; otherwise, the flags are set.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
		tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


mulpd/vmulpd=Multiply Packed Double-Precision Floating-Point Values 
	forms

	description
		Performs a SIMD multiply of the two or four packed double-precision floating-point values from the source operand
		(second operand) and the destination operand (first operand), and stores the packed double-precision floating-
		point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location.
		The destination operand is an XMM register.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the destination YMM register destination are zeroed.
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


mulps/vmulps=Multiply Packed Single-Precision Floating-Point Values 
	forms

	description
		Performs a SIMD multiply of the four packed single-precision floating-point values from the source operand
		(second operand) and the destination operand (first operand), and stores the packed single-precision floating-
		point results in the destination operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the destination YMM register destination are zeroed.
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


mulsd/vmulsd=Multiply Scalar Double-Precision Floating-Point Values 
	forms

	description
		Multiplies the low double-precision floating-point value in the source operand (second operand) by the low double-
		precision floating-point value in the destination operand (first operand), and stores the double-precision floating-
		point result in the destination operand. The source operand can be an XMM register or a 64-bit memory location.
		The destination operand is an XMM register. The high quadword of the destination operand remains unchanged.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
		1:64) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


mulss/vmulss=Multiply Scalar Single-Precision Floating-Point Values 
	forms

	description
		Multiplies the low single-precision floating-point value from the source operand (second operand) by the low
		single-precision floating-point value in the destination operand (first operand), and stores the single-precision
		floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory
		location. The destination operand is an XMM register. The three high-order doublewords of the destination operand
		remain unchanged.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
		1:32) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


mulx=Unsigned Multiply Without Affecting Flags
	forms

	description
		Performs an unsigned multiplication of the implicit source operand (EDX/RDX) and the specified source operand
		(the third operand) and stores the low half of the result in the second destination (second operand), the high half
		of the result in the first destination operand (first operand), without reading or writing the arithmetic flags. This
		enables efficient programming where the software can interleave add with carry operations and multiplications.
		I
		f the first and second operand are identical, it will contain the high half of the multiplication result.
		
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


mwait=Monitor Wait 
	forms

	description
		MWAIT instruction provides hints to allow the processor to enter an implementation-dependent optimized state.
		There are two principal targeted usages: address-range monitor and advanced power management. Both usages
		of MWAIT require the use of the MONITOR instruction.
		
		CPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT in the processor. When set,
		MWAIT may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode
		exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE
		MSR; disabling MWAIT clears the CPUID feature flag and causes execution to generate an invalid-opcode exception.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.
		
		ECX specifies optional extensions for the MWAIT instruction. EAX may contain hints such as the preferred opti-
		mized state the processor should enter. The first processors to implement MWAIT supported only the zero value for
		EAX and ECX. Later processors allowed setting ECX[0] to enable masked interrupts as break events for MWAIT
		(see below). Software can use the CPUID instruction to determine the extensions and hints supported by the processor.
		
		~MWAIT for Address Range Monitoring
			For address-range monitoring, the MWAIT instruction operates with the MONITOR instruction. The two instructions
			allow the definition of an address at which to wait (MONITOR) and a implementation-dependent-optimized opera-
			tion to commence at the wait address (MWAIT). The execution of MWAIT is a hint to the processor that it can enter
			an implementation-dependent-optimized state while waiting for an event or a store operation to the address range
			armed by MONITOR.
			
			The following cause the processor to exit the implementation-dependent-optimized state: a store to the address
			range armed by the MONITOR instruction, an NMI or SMI, a debug exception, a machine check exception, the
			BINIT# signal, the INIT# signal, and the RESET# signal. Other implementation-dependent events may also cause
			the processor to exit the implementation-dependent-optimized state.
			
			In addition, an external interrupt causes the processor to exit the implementation-dependent-optimized state
			either (1) if the interrupt would be delivered to software (e.g., as it would be if HLT had been executed instead of
			MWAIT); or (2) if ECX[0] = 1. Software can execute MWAIT with ECX[0] = 1 only if CPUID.05H:ECX[bit 1] = 1.
			(Implementation-specific conditions may result in an interrupt causing the processor to exit the implementation-
			dependent-optimized state even if interrupts are masked and ECX[0] = 0.)
			
			Following exit from the implementation-dependent-optimized state, control passes to the instruction following the
			MWAIT instruction. A pending interrupt that is not masked (including an NMI or an SMI) may be delivered before
			execution of that instruction. Unlike the HLT instruction, the MWAIT instruction does not support a restart at the
			MWAIT instruction following the handling of an SMI.
			
			If the preceding MONITOR instruction did not successfully arm an address range or if the MONITOR instruction has
			not been executed prior to executing MWAIT, then the processor will not enter the implementation-dependent-opti-
			mized state. Execution will resume at the instruction following the MWAIT.
		
		~MWAIT for Power Management
			MWAIT accepts a hint and optional extension to the processor that it can enter a specified target C state while
			waiting for an event or a store operation to the address range armed by MONITOR. Support for MWAIT extensions
			for power management is indicated by CPUID.05H:ECX[bit 0] reporting 1.
			
			EAX and ECX are used to communicate the additional information to the MWAIT instruction, such as the kind of
			optimized state the processor should enter. ECX specifies optional extensions for the MWAIT instruction. EAX may
			contain hints such as the preferred optimized state the processor should enter. Implementation-specific conditions
			may cause a processor to ignore the hint and enter a different optimized state. Future processor implementations
			may implement several optimized "waiting" states and will select among those states based on the hint argument.
			
			Note that if MWAIT is used to enter any of the C-states that are numerically higher than C1, a store to the address
			range armed by the MONITOR instruction will cause the processor to exit MWAIT only if the store was originated by
			other processor agents. A store from non-processor agent might not cause the processor to exit MWAIT in such
			cases.
			
			@see(power) for more information on MWAIT extensions.

	exceptions

	flags

	operation

	meta
		see
			power => Chapter 14 - "Power and Thermal Management,", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A


neg=Two's Complement Negation 
	forms

	description
		Replaces the value of operand (the destination operand) with its two's complement. (This operation is equivalent to
		subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory location.
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
		the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


nop=No Operation
	forms

	description
		This instruction performs no operation. It is a one-byte or multi-byte NOP that takes up space in the instruction
		stream but does not impact machine context, except for the EIP register.
		
		The multi-byte form of NOP is available on processors with model encoding:
		
		CPUID.01H.EAX[Bytes 11:8] = 0110B or 1111B
		
		The multi-byte NOP instruction does not alter the content of a register and will not issue a memory operation. The
		instruction's operation is the same in non-64-bit modes and 64-bit mode.
		
		The one-byte NOP instruction is an alias mnemonic for the XCHG (E)AX, (E)AX instruction.
		
		The multi-byte NOP instruction performs no operation on supported processors and generates undefined opcode
		exception on processors that do not support the multi-byte NOP instruction.
		
		The memory operand form of the instruction allows software to create a byte sequence of "no operation" as one
		instruction.
	
	exceptions

	flags

	operation

	meta


not=One's Complement Negation 
	forms

	description
		Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is set to 1) on the destination operand and stores
		the result in the destination operand location. The destination operand can be a register or a memory location.
		This instruction can be used with a @ref(lock) prefix to allow the instruction to be executed atomically.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
		the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


or=Logical Inclusive OR 
	forms

	description
		Performs a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores
		the result in the destination operand location. The source operand can be an immediate, a register, or a memory
		location; the destination operand can be a register or a memory location. (However, two memory operands cannot
		be used in one instruction.) Each bit of the result of the OR instruction is set to 0 if both corresponding bits of the
		first and second operands are 0; otherwise, each bit is set to 1.
		
		This instruction can be used with a @ref(lock) prefix to allow the instruction to be executed atomically.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
		the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


orpd/vorpd=Bitwise Logical OR of Double-Precision Floating-Point Values 
	forms

	description
		Performs a bitwise logical OR of the two or four packed double-precision floating-point values from the first source
		operand and the second source operand, and stores the result in the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the destination YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: If VORPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.

	exceptions

	flags

	operation

	meta


orps/vorps=Bitwise Logical OR of Single-Precision Floating-Point Values 
	forms

	description
		Performs a bitwise logical OR of the four or eight packed single-precision floating-point values from the first source
		operand and the second source operand, and stores the result in the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the destination YMM register destination are zeroed.
		
		VEX.256 Encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: If VORPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.

	exceptions

	flags

	operation

	meta


out=Output to Port 
	forms

	description
		Copies the value from the second operand (source operand) to the I/O port specified with the destination operand
		(first operand). The source operand can be register AL, AX, or EAX, depending on the size of the port being
		accessed (8, 16, or 32 bits, respectively); the destination operand can be a byte-immediate or the DX register.
		Using a byte immediate allows I/O port addresses 0 to 255 to be accessed; using the DX register as a source
		operand allows I/O ports from 0 to 65,535 to be accessed.
		
		The size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size
		attribute of the instruction for a 16- or 32-bit I/O port.
		
		At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits
		of the port address will be 0.
		
		This instruction is only useful for accessing I/O ports located in the processor's I/O address space.
		@see(io) for more information on accessing I/O ports in the I/O address space.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta
		see
			io => Chapter 16 - "Input/Output,", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


outs/outsb/outsw/outsd=Output String to Port 
	forms

	description
		Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first
		operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or
		the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The DS
		segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from
		0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source
		and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the
		instruction for a 16- or 32-bit I/O port.
		
		At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
		operands" form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination
		operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O
		port and the source address, and the destination operand must be DX. This explicit-operands form is provided to
		allow documentation; however, note that the documentation provided by this form can be misleading. That is, the
		source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it
		does not have to specify the correct location. The location is always specified by the DS:(E)SI or RSI registers,
		which must be loaded correctly before the OUTS instruction is executed.
		
		The no-operands form provides "short forms" of the byte, word, and doubleword versions of the OUTS instructions.
		Here also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size
		of the I/O port is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or OUTSD (doubleword).
		After the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI
		register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.
		(If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the SI/ESI/RSI register is decremented.)
		The SI/ESI/RSI register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by
		4 for doubleword operations.
		
		The OUTS, OUTSB, OUTSW, and OUTSD instructions can be preceded by the @ref(rep) prefix for block input of ECX bytes,
		words, or doublewords. This instruction is only useful for accessing I/O ports located in the processor's I/O
		address space.
		
		@see(io) for more information on accessing I/O ports in the I/O address space.
		
		In 64-bit mode, the default operand size is 32 bits; operand size is not promoted by the use of REX.W. In 64-bit
		mode, the default address size is 64 bits, and 64-bit address is specified using RSI by default. 32-bit address using
		ESI is support using the prefix 67H, but 16-bit address is not supported in 64-bit mode.

	exceptions

	flags

	operation

	meta
		see
			io => Chapter 16 - "Input/Output,", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


pabsb/pabsw/pabsd/vpabsb/vpabsw/vpabsd=Packed Absolute Value 
	forms

	description
		(V)PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and
		stores the UNSIGNED results in the destination operand (the first operand). (V)PABSB operates on signed bytes,
		(V)PABSW operates on 16-bit words, and (V)PABSD operates on signed 32-bit integers. The source operand can be
		an MMX register or a 64-bit memory location, or it can be an XMM register, a YMM register, a 128-bit memory loca-
		tion, or a 256-bit memory location. The destination operand can be an MMX, an XMM or a YMM register. Both oper-
		ands can be MMX registers or XMM registers. When the source operand is a 128-bit memory operand, the operand
		must be aligned on a 16byte boundary or a general-protection exception (#GP) will be generated.
		
		In 64-bit mode, use the REX prefix to access additional registers.
		
		128-bit Legacy SSE version: The source operand can be an XMM register or a 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		VEX.256 encoded version: The first source operand is a YMM register or a 256-bit memory location. The destination
		operand is a YMM register.
		
		Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0; otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


packsswb/packssdw/vpacksswb/vpackssww=Pack with Signed Saturation 
	forms

	description
		Converts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed
		doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow conditions.
		The (V)PACKSSWB instruction converts 4, 8 or 16 signed word integers from the destination operand (first
		operand) and 4, 8 or 16 signed word integers from the source operand (second operand) into 8, 16 or 32 signed
		byte integers and stores the result in the destination operand. If a signed word integer value is beyond the range
		of a signed byte integer (that is, greater than 7FH for a positive integer or greater than 80H for a negative integer),
		the saturated signed byte integer value of 7FH or 80H, respectively, is stored in the destination.
		
		The (V)PACKSSDW instruction packs 2, 4 or 8 signed doublewords from the destination operand (first operand) and
		2, 4 or 8 signed doublewords from the source operand (second operand) into 4, 8 or 16 signed words in the desti-
		nation operand (see Figure 4-2). If a signed doubleword integer value is beyond the range of a signed word (that
		is, greater than 7FFFH for a positive integer or greater than 8000H for a negative integer), the saturated signed
		word integer value of 7FFFH or 8000H, respectively, is stored into the destination.
		
		The (V)PACKSSWB and (V)PACKSSDW instructions operate on either 64-bit, 128-bit operands or 256-bit operands.
		When operating on 64-bit operands, the destination operand must be an MMX technology register and the source
		operand can be either an MMX technology register or a 64-bit memory location. In 64-bit mode, using a REX prefix
		in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
		register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the
		upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


packusdw/vpackusdw=Pack with Unsigned Saturation 
	forms

	description
		Converts packed signed doubleword integers into packed unsigned word integers using unsigned saturation to
		handle overflow conditions. If the signed doubleword value is beyond the range of an unsigned word (that is,
		greater than FFFFH or less than 0000H), the saturated unsigned word integer value of FFFFH or 0000H, respec-
		tively, is stored in the destination.
		
		128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
		register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the
		upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


packuswb/vpackuswb=Pack with Unsigned Saturation 
	forms

	description
		Converts 4, 8 or 16 signed word integers from the destination operand (first operand) and 4, 8 or 16 signed word
		integers from the source operand (second operand) into 8, 16 or 32 unsigned byte integers and stores the result in
		the destination operand. (See Figure 4-2 for an example of the packing operation.) If a signed word integer value
		is beyond the range of an unsigned byte integer (that is, greater than FFH or less than 00H), the saturated
		unsigned byte integer value of FFH or 00H, respectively, is stored in the destination.
		
		The PACKUSWB instruction operates on either 64-bit, 128-bit or 256-bit operands. When operating on 64-bit oper-
		ands, the destination operand must be an MMX technology register and the source operand can be either an MMX
		technology register or a 64-bit memory location. In 64-bit mode, using a REX prefix in the form of REX.R permits
		this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
		register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the
		upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


paddb/paddw/paddd/vpaddb/vpaddw/paddd=Add Packed Integers 
	forms

	description
		Performs a SIMD add of the packed integers from the source operand (second operand) and the destination
		operand (first operand), and stores the packed integer results in the destination operand.
		
		Adds the packed byte, word, doubleword, or quadword integers in the first source operand to the second source
		operand and stores the result in the destination operand. When a result is too large to be represented in the
		8/16/32 integer (overflow), the result is wrapped around and the low bits are written to the destination element
		(that is, the carry is ignored).
		
		Note that these instructions can operate on either unsigned or signed (two's complement notation) integers;
		however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected
		overflow conditions, software must control the ranges of the values operated on.
		
		These instructions can operate on either 64-bit, 128-bit or 256-bit operands. When operating on 64-bit operands,
		the destination operand must be an MMX technology register and the source operand can be either an MMX tech-
		nology register or a 64-bit memory location. In 64-bit mode, using a REX prefix in the form of REX.R permits this
		instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
		register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the
		upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


paddq/vpaddq=Add Packed Quadword Integers 
	forms

	description
		Adds the first operand (destination operand) to the second operand (source operand) and stores the result in the
		destination operand. The source operand can be a quadword integer stored in an MMX technology register or a 64-
		bit memory location, or it can be two packed quadword integers stored in an XMM register or an 128-bit memory
		location. The destination operand can be a quadword integer stored in an MMX technology register or two packed
		quadword integers stored in an XMM register. When packed quadword operands are used, a SIMD add is
		performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped
		around and the low 64 bits are written to the destination element (that is, the carry is ignored).
		
		Note that the (V)PADDQ instruction can operate on either unsigned or signed (two's complement notation) inte-
		gers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected
		overflow conditions, software must control the ranges of the values operated on.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
		register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the
		upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


paddsb/paddsw/vpaddsb/vpaddsw=Add Packed Signed Integers with Signed Saturation
	forms

	description
		Performs a SIMD add of the packed signed integers from the source operand (second operand) and the destination
		operand (first operand), and stores the packed integer results in the destination operand.
		
		The PADDSB instruction adds packed signed byte integers. When an individual byte result is beyond the range of a
		signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is
		written to the destination operand.
		
		The PADDSW instruction adds packed signed word integers. When an individual word result is beyond the range of
		a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H,
		respectively, is written to the destination operand.
		
		These instructions can operate on either 64-bit, 128-bit or 256-bit operands. When operating on 64-bit operands,
		the destination operand must be an MMX technology register and the source operand can be either an MMX tech-
		nology register or a 64-bit memory location. In 64-bit mode, using a REX prefix in the form of REX.R permits this
		instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
		register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the
		upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


paddusb/paddusw/vpaddusb/vpaddusw=Add Packed Unsigned Integers with Unsigned Saturation 
	forms

	description
		Performs a SIMD add of the packed unsigned integers from the source operand (second operand) and the destina-
		tion operand (first operand), and stores the packed integer results in the destination operand.
		
		The (V)PADDUSB instruction adds packed unsigned byte integers. When an individual byte result is beyond the
		range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH is written to the destination operand.
		The (V)PADDUSW instruction adds packed unsigned word integers. When an individual word result is beyond the
		range of an unsigned word integer (that is, greater than FFFFH), the saturated value of FFFFH is written to the
		destination operand.
		
		These instructions can operate on either 64-bit, 128-bit or 256-bit operands. When operating on 64-bit operands,
		the destination operand must be an MMX technology register and the source operand can be either an MMX technology
		register or a 64-bit memory location. In 64-bit mode, using a REX prefix in the form of REX.R permits this
		instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
		register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the
		upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


palignr/vpalignr=Packed Align Right 
	forms

	description
		(V)PALIGNR concatenates the destination operand (the first operand) and the source operand (the second
		operand) into an intermediate composite, shifts the composite at byte granularity to the right by a constant imme-
		diate, and extracts the right-aligned result into the destination. The first and the second operands can be an MMX,
		XMM or a YMM register. The immediate value is considered unsigned. Immediate shift counts larger than the 2L
		(i.e. 32 for 128-bit operands, or 16 for 64-bit operands) produce a zero result. Both operands can be MMX regis-
		ters, XMM registers or YMM registers. When the source operand is a 128-bit memory operand, the operand must
		be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.
		
		In 64-bit mode, use the REX prefix to access additional registers.
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register and contains two 16-byte blocks. The second
		source operand is a YMM register or a 256-bit memory location containing two 16-byte block. The destination
		operand is a YMM register and contain two 16-byte results. The imm8[7:0] is the common shift count used for the
		two lower 16-byte block sources and the two upper 16-byte block sources. The low 16-byte block of the two source
		operands produce the low 16-byte result of the destination operand, the high 16-byte block of the two source oper-
		ands produce the high 16-byte result of the destination operand.
		
		Concatenation is done with 128-bit data in the first and second source operand for both 128-bit and 256-bit
		instructions. The high 128-bits of the intermediate composite 256-bit result came from the 128-bit data from the
		first source operand; the low 128-bits of the intermediate result came from the 128-bit data of the second source operand.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pand/vpand=Logical AND
	forms

	description
		Performs a bitwise logical AND operation on the first source operand and second source operand and stores the
		result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second
		operands are 1, otherwise it is set to 0.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand can be an MMX technology register.
		
		128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
		register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the
		upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pandn/vpandn=Logical AND NOT 
	forms

	description
		Performs a bitwise logical NOT operation on the first source operand, then performs bitwise AND with second
		source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corre-
		sponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand can be an MMX technology register.
		
		128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
		register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the
		upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pause=Spin Loop Hint 
	forms

	description
		Improves the performance of spin-wait loops. When executing a "spin-wait loop," processors will suffer a severe
		performance penalty when exiting the loop because it detects a possible memory order violation. The PAUSE
		instruction provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint
		to avoid the memory order violation in most situations, which greatly improves processor performance. For this
		reason, it is recommended that a PAUSE instruction be placed in all spin-wait loops.
		
		An additional function of the PAUSE instruction is to reduce the power consumed by a processor while executing a
		spin loop. A processor can execute a spin-wait loop extremely quickly, causing the processor to consume a lot of
		power while it waits for the resource it is spinning on to become available. Inserting a pause instruction in a spin-
		wait loop greatly reduces the processor's power consumption.
		
		This instruction was introduced in the Pentium 4 processors, but is backward compatible with all IA-32 processors.
		In earlier IA-32 processors, the PAUSE instruction operates like a NOP instruction. The Pentium 4 and Intel Xeon
		processors implement the PAUSE instruction as a delay. The delay is finite and can be zero for some processors.
		This instruction does not change the architectural state of the processor (that is, it performs essentially a delaying
		no-op operation).
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


pavgb/pavgw/vpavgb/vpavgw=Average Packed Integers 
	forms

	description
		Performs a SIMD average of the packed unsigned integers from the source operand (second operand) and the
		destination operand (first operand), and stores the results in the destination operand. For each corresponding pair
		of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary
		sum, and that result is shifted right one bit position.
		
		The (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed unsigned words.
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand can be an MMX technology register.
		
		128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
		register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the
		upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


pblendvb/vpblendvb=Variable Blend Packed Bytes 
	forms

	description
		Conditionally copies byte elements from the source operand (second operand) to the destination operand (first
		operand) depending on mask bits defined in the implicit third register argument, XMM0. The mask bits are the
		most significant bit in each byte element of the XMM0 register.
		
		If a mask bit is "1", then the corresponding byte element in the source operand is copied to the destination, else
		the byte element in the destination operand is left unchanged.
		
		The register assignment of the implicit third operand is defined to be the architectural register XMM0.
		128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (VLMAX-1:128)
		of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined
		to be the architectural register XMM0. An attempt to execute PBLENDVB with a VEX prefix will cause #UD.
		
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and
		encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
		ignored. The upper bits (VLMAX-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.L
		must be 0, otherwise the instruction will #UD. VEX.W must be 0, otherwise, the instruction will #UD.
		
		VEX.256 encoded version: The first source operand and the destination operand are YMM registers. The second
		source operand is an YMM register or 256-bit memory location. The third source register is an YMM register and
		encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored.
		
		VPBLENDVB permits the mask to be any XMM or YMM register. In contrast, PBLENDVB treats XMM0 implicitly as the
		mask and do not support non-destructive destination operation. An attempt to execute PBLENDVB encoded with a
		VEX prefix will cause a #UD exception.

	exceptions

	flags

	operation

	meta


pblendw/vpblendw=Blend Packed Words 
	forms

	description
		Words from the source operand (second operand) are conditionally written to the destination operand (first
		operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask
		that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask,
		corresponding to a word, is "1", then the word is copied, else the word element in the destination operand is unchanged.
		
		128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
		first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination
		register remain unchanged.
		
		VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
		first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register
		are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


pclmulqdq/vpclmulqdq=Carry-Less Multiplication Quadword 
	forms

	description
		Performs a carry-less multiplication of two quadwords, selected from the first source and second source operand
		according to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to use.
		
		The first source operand and the destination operand are the same and must be an XMM register. The second
		source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding
		YMM destination register remain unchanged.

	exceptions

	flags

	operation

	meta


pcmpeqb/pcmpeqw/pcmpeqd/vpcmpeqb/vpcmpeqw/vpcmpeqd=Compare Packed Data for Equal 
	forms

	description
		Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first
		operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data
		element in the destination operand is set to all 1s; otherwise, it is set to all 0s.
		
		The (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the
		(V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the
		(V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand can be an MMX technology register.
		
		128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
		first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination
		register remain unchanged.
		
		VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
		first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pcmpeqq/vpcmpeqq=Compare Packed Qword Data for Equal
	forms

	description
		Performs an SIMD compare for equality of the packed quadwords in the destination operand (first operand) and the
		source operand (second operand). If a pair of data elements is equal, the corresponding data element in the desti-
		nation is set to all 1s; otherwise, it is set to 0s.
		
		128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
		first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination
		register remain unchanged.
		
		VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
		first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pcmpestri/vpcmpestri=Packed Compare Explicit Length Strings, Return Index
	forms

	description
		The instruction compares and processes data from two string fragments based on the encoded value in the Imm8
		Control Byte and generates an index stored to the count register (ECX/RCX). @todo(control byte)
		
		Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second
		operand) which contains the data elements of the string (byte or word data). The second value is stored in an input
		length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length repre-
		sents the number of bytes/words which are valid for the respective xmm/m128 data.
		
		The length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-
		value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value
		in the length register is greater than 16 (8) or less than -16 (-8).

	exceptions

	flags

	operation

	meta


pcmpestrm/vpcmpestrm=Packed Compare Explicit Length Strings, Return Mask 
	forms

	description
		The instruction compares data from two string fragments based on the encoded value in the imm8 contol byte and gener-
		ates a mask stored to XMM0. @todo(control byte)
		
		Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second
		operand) which contains the data elements of the string (byte or word data). The second value is stored in an input
		length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length repre-
		sents the number of bytes/words which are valid for the respective xmm/m128 data.
		
		The length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-
		value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value
		in the length register is greater than 16 (8) or less than -16 (-8).

	exceptions

	flags

	operation

	meta


pcmpgtb/pcmpgtw/pcmpgtd/vpcmpgtb/vpcmpgtw/vpcmpgtd=Compare Packed Signed Integers for Greater Than
	forms

	description
		Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the
		destination operand (first operand) and the source operand (second operand). If a data element in the destination
		operand is greater than the corresponding date element in the source operand, the corresponding data element in
		the destination operand is set to all 1s; otherwise, it is set to all 0s.
		
		The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source oper-
		ands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source
		operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the 
		destination and source operands.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand can be an MMX technology register.
		
		128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
		first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
		first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
		register are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pcmpgtq/vpcmpgtq=Compare Packed Data for Greater Than 
	forms

	description
		Performs an SIMD signed compare for the packed quadwords in the destination operand (first operand) and the
		source operand (second operand). If the data element in the first (destination) operand is greater than the
		corresponding element in the second (source) operand, the corresponding data element in the destination is set
		to all 1s; otherwise, it is set to 0s.
		
		128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
		first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
		first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
		register are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
		or a 256-bit memory location. The destination operand is a YMM register.
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pcmpistri/vpcmpistri=Packed Compare Implicit Length Strings, Return Index 
	forms

	description
		The instruction compares data from two strings based on the encoded value in the Imm8 Control Byte and generates an
		index stored to ECX. @todo(control byte)
		
		Each string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which
		contains the data elements of the string (byte or word data). Each input byte/word is augmented with a
		valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null
		byte/word. (The least significant null byte/word is also considered invalid.)

	exceptions

	flags

	operation

	meta


pcmpistrm/vpcmpistrm=Packed Compare Implicit Length Strings, Return Mask
	forms

	description
		The instruction compares data from two strings based on the encoded value in the imm8 byte generating a mask stored to XMM0. @todo(control byte)
		
		Each string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which
		contains the data elements of the string (byte or word data). Each input byte/word is augmented with a
		valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null
		byte/word. (The least significant null byte/word is also considered invalid.)
		
		The comparison and aggregation operation are performed according to the encoded value of Imm8 bit fields.
		As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero
		extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.

	exceptions

	flags

	operation

	meta


pdep=Parallel Bits Deposit 
	forms

	description
		PDEP uses a mask in the second source operand (the third operand) to transfer/scatter contiguous low order bits
		in the first source operand (the second operand) into the destination (the first operand). PDEP takes the low bits
		from the first source operand and deposit them in the destination operand at the corresponding bit locations that
		are set in the second source operand (mask). All other bits (bits not set in mask) in destination are set to zero.
		
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


pext=Parallel Bits Extract 
	forms

	description
		PEXT uses a mask in the second source operand (the third operand) to transfer either contiguous or non-contig-
		uous bits in the first source operand (the second operand) to contiguous low order bit positions in the destination
		(the first operand). For each bit set in the MASK, PEXT extracts the corresponding bits from the first source
		operand and writes them into contiguous lower bits of destination operand. The remaining upper bits of destination are zeroed.
		
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


pextrb/vpextrb=Extract Byte
pextrd/vpextrd=Extract Dword
pextrq/vpextrq=Extract Qword 
	forms

	description
		Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined
		from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a
		register, the upper bits of the register are zero extended.
		
		In legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit
		mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros.
		PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.
		
		Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the
		instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for
		VPEXTRB/VPEXTRD is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.
		
		Attempt to execute VPEXTRQ in non-64-bit mode will cause #UD.

	exceptions

	flags

	operation

	meta


pextrw/vpextrw=Extract Word
	forms

	description
		Copies the word in the source operand (second operand) specified by the count operand (third operand) to the
		destination operand (first operand). The source operand can be an MMX technology register or an XMM register.
		
		The destination operand can be the low word of a general-purpose register or a 16-bit memory address. The count
		operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-signifi-
		cant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the loca-
		tion. The content of the destination register above bit 16 is cleared (set to all 0s).
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15, R8-15). If the destination operand is a general-purpose register, the default operand size is 64-bits in 64-bit mode.
		
		Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the
		instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRW
		is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.

	exceptions

	flags

	operation

	meta


phaddw/phaddd/vphaddw/vphaddd=Packed Horizontal Add
	forms

	description
		(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and
		packs the 16-bit signed results to the destination operand (first operand). (V)PHADDD adds two adjacent 32-bit
		signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the
		destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be
		aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.
		
		Note that these instructions can operate on either unsigned or signed (two's complement notation) integers;
		however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected
		overflow conditions, software must control the ranges of the values operated on.
		
		Legacy SSE instructions: Both operands can be MMX registers. The second source operand can be an MMX register
		or a 64-bit memory location.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		In 64-bit mode, use the REX prefix to access additional registers.
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		register are zeroed.
		
		VEX.256 encoded version: Horizontal addition of two adjacent data elements of the low 16-bytes of the first and
		second source operands are packed into the low 16-bytes of the destination operand. Horizontal addition of two
		adjacent data elements of the high 16-bytes of the first and second source operands are packed into the high 16-
		bytes of the destination operand. The first source and destination operands are YMM registers. The second source
		operand can be an YMM register or a 256-bit memory location.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


phaddsw/vphaddsw=Packed Horizontal Add and Saturate
	forms

	description
		(V)PHADDSW adds two adjacent signed 16-bit integers horizontally from the source and destination operands and
		saturates the signed results; packs the signed, saturated 16-bit results to the destination operand (first operand)
		When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a
		general-protection exception (#GP) will be generated.
		
		Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or
		a 64-bit memory location.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		In 64-bit mode, use the REX prefix to access additional registers.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The first source and destination operands are YMM registers. The second source
		operand can be an YMM register or a 256-bit memory location.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


phminposuw/vphminposuw=Packed Horizontal Word Minimum
	forms

	description
		Determine the minimum unsigned word value in the source operand (second operand) and place the unsigned
		word in the low word (bits 0-15) of the destination operand (first operand). The word index of the minimum value
		is stored in bits 16-18 of the destination operand. The remaining upper bits of the destination are set to zero.
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain
		unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.vvvv is reserved
		and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


phsubw/phsubd/vphsubw/phsubd=Packed Horizontal Subtract
	forms

	description
		(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the
		most significant word from the least significant word of each pair in the source and destination operands, and packs
		the signed 16-bit results to the destination operand (first operand). (V)PHSUBD performs horizontal subtraction on
		each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least signifi-
		cant doubleword of each pair, and packs the signed 32-bit result to the destination operand. When the source
		operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection
		exception (#GP) will be generated.
		
		Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or
		a 64-bit memory location.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		In 64-bit mode, use the REX prefix to access additional registers.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
		zeroed.

	exceptions

	flags

	operation

	meta


phsubsw/vphsubsw=Packed Horizontal Subtract and Saturate 
	forms

	description
		(V)PHSUBSW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the
		most significant word from the least significant word of each pair in the source and destination operands. The
		signed, saturated 16-bit results are packed to the destination operand (first operand). When the source operand is
		a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception
		(#GP) will be generated.
		
		Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a
		64-bit memory location.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		In 64-bit mode, use the REX prefix to access additional registers.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The first source and destination operands are YMM registers. The second source
		operand can be an YMM register or a 256-bit memory location.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pinsrb/vpinsrb=Insert Byte
pinsrd/vpinsrd=Insert Dword
pinsrq/vpinsrq=Insert Qword 
	forms

	description
		Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand
		(first operand) at the location specified with the count operand (third operand). (The other elements in the desti-
		nation register are left untouched.) The source operand can be a general-purpose register or a memory location.
		(When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destina-
		tion operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte]
		location in an an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.L must be 0, other-
		wise the instruction will #UD. Attempt to execute VPINSRQ in non-64-bit mode will cause #UD.

	exceptions

	flags

	operation

	meta


pinsrw/vpinsrw=Insert Word
	forms

	description
		Copies a word from the source operand (second operand) and inserts it in the destination operand (first operand)
		at the location specified with the count operand (third operand). (The other words in the destination register are
		left untouched.) The source operand can be a general-purpose register or a 16-bit memory location. (When the
		source operand is a general-purpose register, the low word of the register is copied.) The destination operand can
		be an MMX technology register or an XMM register. The count operand is an 8-bit immediate. When specifying a
		word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location;
		for an XMM register, the 3 least-significant bits specify the location.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15).
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.L must be 0, other-
		wise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pmaddubsw/vpmaddubsw=Multiply and Add Packed Signed and Unsigned Bytes 
	forms

	description
		(V)PMADDUBSW multiplies vertically each unsigned byte of the destination operand (first operand) with the corre-
		sponding signed byte of the source operand (second operand), producing intermediate signed 16-bit integers. Each
		adjacent pair of signed words is added and the saturated result is packed to the destination operand. For example,
		the lowest-order bytes (bits 7-0) in the source and destination operands are multiplied and the intermediate signed
		word result is added with the corresponding intermediate result from the 2nd lowest-order bytes (bits 15-8) of the
		operands; the sign-saturated result is stored in the lowest word of the destination register (15-0). The same oper-
		ation is performed on the other pairs of adjacent bytes. Both operands can be MMX register or XMM registers. When
		the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a
		general-protection exception (#GP) will be generated.
		
		In 64-bit mode, use the REX prefix to access additional registers.
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The first source and destination operands are YMM registers. The second source
		operand can be an YMM register or a 256-bit memory location.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pmaddwd/vpmaddwd=Multiply and Add Packed Integers 
	forms

	description
		Multiplies the individual signed words of the destination operand (first operand) by the corresponding signed words
		of the source operand (second operand), producing temporary signed, doubleword results. The adjacent double-
		word results are then summed and stored in the destination operand. For example, the corresponding low-order
		words (15-0) and (31-16) in the source and destination operands are multiplied by one another and the double-
		word results are added together and stored in the low doubleword of the destination register (31-0). The same
		operation is performed on the other pairs of adjacent words. (Figure 4-7 shows this operation when using 64-bit operands).
		The (V)PMADDWD instruction wraps around only in one situation: when the 2 pairs of words being operated on in
		a group are all 8000H. In this case, the result wraps around to 80000000H.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE version: The first source and destination operands are MMX registers. The second source operand is an
		MMX register or a 64-bit memory location.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pmaxsb/vpmaxsb=Maximum of Packed Signed Byte Integers 
	forms

	description
		Compares packed signed byte integers in the destination operand (first operand) and the source operand (second
		operand), and returns the maximum for each packed value in the destination operand.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pmaxsd/vpmaxsd=Maximum of Packed Signed Dword Integers 
	forms

	description
		Compares packed signed dword integers in the destination operand (first operand) and the source operand (second
		operand), and returns the maximum for each packed value in the destination operand.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pmaxsw/vpmaxsw=Maximum of Packed Signed Word Integers 
	forms

	description
		Performs a SIMD compare of the packed signed word integers in the destination operand (first operand) and the
		source operand (second operand), and returns the maximum value for each pair of word integers to the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand can be an MMX technology register.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pmaxub/vpmaxub=Maximum of Packed Unsigned Byte Integers 
	forms

	description
		Performs a SIMD compare of the packed unsigned byte integers in the destination operand (first operand) and the
		source operand (second operand), and returns the maximum value for each pair of byte integers to the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand can be an MMX technology register.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pmaxud/vpmaxud=Maximum of Packed Unsigned Dword Integers 
	forms

	description
		Compares packed unsigned dword integers in the destination operand (first operand) and the source operand
		(second operand), and returns the maximum for each packed value in the destination operand.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pmaxuw/vpmaxuw=Maximum of Packed Word Integers 
	forms

	description
		Compares packed unsigned word integers in the destination operand (first operand) and the source operand
		(second operand), and returns the maximum for each packed value in the destination operand.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pminsb/vpminsb=Minimum of Packed Signed Byte Integers 
	forms

	description
		Compares packed signed byte integers in the destination operand (first operand) and the source operand (second
		operand), and returns the minimum for each packed value in the destination operand.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pminsd/vpminsd=Minimum of Packed Dword Integers
	forms

	description
		Compares packed signed dword integers in the destination operand (first operand) and the source operand (second
		operand), and returns the minimum for each packed value in the destination operand.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pminsw/vpminsw=Minimum of Packed Signed Word Integers
	forms

	description
		Performs a SIMD compare of the packed signed word integers in the destination operand (first operand) and the
		source operand (second operand), and returns the minimum value for each pair of word integers to the destination
		operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand can be an MMX technology register.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pminub/vpminub=Minimum of Packed Unsigned Byte Integers 
	forms

	description
		Performs a SIMD compare of the packed unsigned byte integers in the destination operand (first operand) and the
		source operand (second operand), and returns the minimum value for each pair of byte integers to the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand can be an MMX technology register.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pminud/vpminud=Minimum of Packed Dword Integers
	forms

	description
		Compares packed unsigned dword integers in the destination operand (first operand) and the source operand
		(second operand), and returns the minimum for each packed value in the destination operand.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pminuw/vpminuw=Minimum of Packed Word Integers
	forms

	description
		Compares packed unsigned word integers in the destination operand (first operand) and the source operand
		(second operand), and returns the minimum for each packed value in the destination operand.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pmovmskb/vpmovmskb=Move Byte Mask
	forms

	description
		Creates a mask made up of the most significant bit of each byte of the source operand (second operand) and stores
		the result in the low byte or word of the destination operand (first operand).
		
		The byte mask is 8 bits for 64-bit source operand, 16 bits for 128-bit source operand and 32 bits for 256-bit source
		operand. The destination operand is a general-purpose register.
		
		In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R
		prefix. The default operand size is 64-bit in 64-bit mode.
		
		Legacy SSE version: The source operand is an MMX technology register.
		
		128-bit Legacy SSE version: The source operand is an XMM register.
		
		VEX.128 encoded version: The source operand is an XMM register.
		
		VEX.256 encoded version: The source operand is a YMM register.
		
		Note: VEX.vvvv is reserved and must be 1111b.

	exceptions

	flags

	operation

	meta


pmovsxbw/pmovsxbd/pmovsxbq/pmovsxwd/pmovsxwq/pmovsxdq=Packed Move with Sign Extend
vpmovsxbw/vpmovsxbd/vpmovsxbq/vpmovsxwd/vpmovsxwq/vpmovsxdq=Packed Move with Sign Extend
	forms

	description
		Sign-extend the low byte/word/dword values in each word/dword/qword element of the source operand (second
		operand) to word/dword/qword integers and stored as packed data in the destination operand (first operand).
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The destination register is YMM Register.
		
		Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pmovzxbw/pmovzxbd/pmovzxbq/pmovzxwd/pmovzxwq/pmovzxdq=Packed Move with Zero Extend
vpmovzxbw/vpmovzxbd/vpmovzxbq/vpmovzxwd/vpmovzxwq/vpmovzxdq=Packed Move with Zero Extend 
	forms

	description
		Zero-extend the low byte/word/dword values in each word/dword/qword element of the source operand (second
		operand) to word/dword/qword integers and stored as packed data in the destination operand (first operand).
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The destination register is YMM Register.
		
		Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pmuldq/vpmuldq=Multiply Packed Signed Dword Integers
	forms

	description
		Multiplies the first source operand by the second source operand and stores the result in the destination operand.
		For PMULDQ and VPMULDQ (VEX.128 encoded version), the second source operand is two packed signed double-
		word integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. The
		first source operand is two packed signed doubleword integers stored in the first and third doublewords of an XMM
		register. The destination contains two packed signed quadword integers stored in an XMM register. For 128-bit
		memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation.
		
		For VPMULDQ (VEX.256 encoded version), the second source operand is four packed signed doubleword integers
		stored in the first (low), third, fifth and seventh doublewords of an YMM register or a 256-bit memory location. The
		first source operand is four packed signed doubleword integers stored in the first, third, fifth and seventh double-
		words of an XMM register. The destination contains four packed signed quadword integers stored in an YMM
		register. For 256-bit memory operands, 256 bits are fetched from memory, but only the first, third, fifth and
		seventh doublewords are used in the computation.
		
		When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the
		low 64 bits are written to the destination element (that is, the carry is ignored).
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
		zeroed. VEX.L must be 0, otherwise the instruction will #UD.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.

	exceptions

	flags

	operation

	meta


pmulhrsw/vpmulhrsw=Packed Multiply High with Round and Scale 
	forms

	description
		PMULHRSW multiplies vertically each signed 16-bit integer from the destination operand (first operand) with the
		corresponding signed 16-bit integer of the source operand (second operand), producing intermediate, signed 32-
		bit integers. Each intermediate 32-bit integer is truncated to the 18 most significant bits. Rounding is always
		performed by adding 1 to the least significant bit of the 18-bit intermediate result. The final result is obtained by
		selecting the 16 bits immediately to the right of the most significant bit of each 18-bit intermediate result and
		packed to the destination operand.
		
		When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a
		general-protection exception (#GP) will be generated.
		
		In 64-bit mode, use the REX prefix to access additional registers.
		
		Legacy SSE version: Both operands can be MMX registers. The second source operand is an MMX register or a 
		64-bit memory location.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
		zeroed. VEX.L must be 0, otherwise the instruction will #UD.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.

	exceptions

	flags

	operation

	meta


pmulhuw/vpmulhuw=Multiply Packed Unsigned Integers and Store High Result 
	forms

	description
		Performs a SIMD unsigned multiply of the packed unsigned word integers in the destination operand (first operand)
		and the source operand (second operand), and stores the high 16 bits of each 32-bit intermediate results in the
		destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand is an MMX technology register.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
		zeroed. VEX.L must be 0, otherwise the instruction will #UD.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.

	exceptions

	flags

	operation

	meta


pmulhw/vpmulhw=Multiply Packed Signed Integers and Store High Result
	forms

	description
		Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and
		the source operand (second operand), and stores the high 16 bits of each intermediate 32-bit result in the destina-
		tion operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand is an MMX technology register.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
		zeroed. VEX.L must be 0, otherwise the instruction will #UD.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.

	exceptions

	flags

	operation

	meta


pmulld/vpmulld=Multiply Packed Signed Dword Integers and Store Low Result
	forms

	description
		Performs four signed multiplications from four pairs of signed dword integers and stores the lower 32 bits of the
		four 64-bit products in the destination operand (first operand). Each dword element in the destination operand is
		multiplied with the corresponding dword element of the source operand (second operand) to obtain a 64-bit inter-
		mediate product.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pmullw/vpmullw=Multiply Packed Signed Integers and Store Low Result 
	forms

	description
		Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and
		the source operand (second operand), and stores the low 16 bits of each intermediate 32-bit result in the destina-
		tion operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand is an MMX technology register.
		
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
		tion register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
		zeroed. VEX.L must be 0, otherwise the instruction will #UD.
		
		VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
		first source and destination operands are YMM registers.

	exceptions

	flags

	operation

	meta


pmuludq/vpmuludq=Multiply Packed Unsigned Doubleword Integers
	forms

	description
		Multiplies the first operand (destination operand) by the second operand (source operand) and stores the result in
		the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE version: The source operand can be an unsigned doubleword integer stored in the low doubleword of
		an MMX technology register or a 64-bit memory location. The destination operand can be an unsigned doubleword
		integer stored in the low doubleword an MMX technology register. The result is an unsigned quadword integer
		stored in the destination an MMX technology register. When a quadword result is too large to be represented in 64
		bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the
		carry is ignored).
		
		For 64-bit memory operands, 64 bits are fetched from memory, but only the low doubleword is used in the computation.
		128-bit Legacy SSE version: The second source operand is two packed unsigned doubleword integers stored in the
		first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands,
		128 bits are fetched from memory, but only the first and third doublewords are used in the computation.The first
		source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM
		register. The destination contains two packed unsigned quadword integers stored in an XMM register. Bits (VLMAX-
		1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The second source operand is two packed unsigned doubleword integers stored in the
		first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands,
		128 bits are fetched from memory, but only the first and third doublewords are used in the computation.The first
		source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM
		register. The destination contains two packed unsigned quadword integers stored in an XMM register. Bits (VLMAX-
		1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand is four packed unsigned doubleword integers stored in the
		first (low), third, fifth and seventh doublewords of a YMM register or a 256-bit memory location. For 256-bit
		memory operands, 256 bits are fetched from memory, but only the first, third, fifth and seventh doublewords are
		used in the computation.The first source operand is four packed unsigned doubleword integers stored in the first,
		third, fifth and seventh doublewords of an YMM register. The destination contains four packed unaligned quadword
		integers stored in an YMM register.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pop=Pop a Value from the Stack
	forms

	description
		Loads the value from the top of the stack to the location specified with the destination operand (or explicit opcode)
		and then increments the stack pointer. The destination operand can be a general-purpose register, memory loca-
		tion, or segment register.
		
		Address and operand sizes are determined and used as follows:
		
		- Address size. The D flag in the current code-segment descriptor determines the default address size; it may be
			overridden by an instruction prefix (67H).
			The address size is used only when writing to a destination operand in memory.
		
		- Operand size. The D flag in the current code-segment descriptor determines the default operand size; it may
			be overridden by instruction prefixes (66H or REX.W).
			The operand size (16, 32, or 64 bits) determines the amount by which the stack pointer is incremented (2, 4 or 8).
		
		- Stack-address size. Outside of 64-bit mode, the B flag in the current stack-segment descriptor determines the
			size of the stack pointer (16 or 32 bits); in 64-bit mode, the size of the stack pointer is always 64 bits.
			The stack-address size determines the width of the stack pointer when reading from the stack in memory and
			when incrementing the stack pointer. (As stated above, the amount by which the stack pointer is incremented
			is determined by the operand size.)
		
		If the destination operand is one of the segment registers DS, ES, FS, GS, or SS, the value loaded into the register
		must be a valid segment selector. In protected mode, popping a segment selector into a segment register automat-
		ically causes the descriptor information associated with that segment selector to be loaded into the hidden
		(shadow) part of the segment register and causes the selector and the descriptor information to be validated (see
		the "Operation" section below).
		
		A NULL value (0000-0003) may be popped into the DS, ES, FS, or GS register without causing a general protection
		fault. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded
		with a NULL value causes a general protection exception (#GP). In this situation, no memory reference occurs and
		the saved value of the segment register is NULL.
		
		The POP instruction cannot pop a value into the CS register. To load the CS register from the stack, use the RET
		instruction.
		
		If the ESP register is used as a base register for addressing a destination operand in memory, the POP instruction
		computes the effective address of the operand after it increments the ESP register. For the case of a 16-bit stack
		where ESP wraps to 0H as a result of the POP instruction, the resulting location of the memory write is processor-
		family-specific.
		
		The POP ESP instruction increments the stack pointer (ESP) before data at the old top of stack is written into the
		destination.
		
		A POP SS instruction inhibits all interrupts, including the NMI interrupt, until after execution of the next instruction.
		This action allows sequential execution of POP SS and MOV ESP, EBP instructions without the danger of having an
		invalid stack during an interrupt1. However, use of the LSS instruction is the preferred method of loading the SS
		and ESP registers.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). When in
		64-bit mode, POPs using 32-bit operands are not encodable and POPs to DS, ES, SS are not valid.

	exceptions

	flags

	operation

	meta


popa/popad=Pop All General-Purpose Registers
	forms

	description
		Pops doublewords (POPAD) or words (POPA) from the stack into the general-purpose registers. The registers are
		loaded in the following order: EDI, ESI, EBP, EBX, EDX, ECX, and EAX (if the operand-size attribute is 32) and DI,
		SI, BP, BX, DX, CX, and AX (if the operand-size attribute is 16). (These instructions reverse the operation of the
		PUSHA/PUSHAD instructions.) The value on the stack for the ESP or SP register is ignored. Instead, the ESP or SP
		register is incremented after each register is loaded.
		
		The POPA (pop all) and POPAD (pop all double) mnemonics reference the same opcode. The POPA instruction is
		intended for use when the operand-size attribute is 16 and the POPAD instruction for when the operand-size attri-
		bute is 32. Some assemblers may force the operand size to 16 when POPA is used and to 32 when POPAD is used
		(using the operand-size override prefix [66H] if necessary). Others may treat these mnemonics as synonyms
		(POPA/POPAD) and use the current setting of the operand-size attribute to determine the size of values to be
		popped from the stack, regardless of the mnemonic used. (The D flag in the current code segment's segment
		descriptor determines the operand-size attribute.)
		
		This instruction executes as described in non-64-bit modes. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


popcnt=Return the Count of Number of Bits Set to 1 
	forms

	description
		This instruction calculates the number of bits set to 1 in the second operand (source) and returns the count in the
		first operand (a destination register).

	exceptions

	flags

	operation

	meta


popf/popfd/popfq=Pop Stack into EFLAGS Register 
	forms

	description
		Pops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the
		value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and
		stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the
		operation of the PUSHF/PUSHFD instructions.
		
		The POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction
		is intended for use when the operand-size attribute is 16; the POPFD instruction is intended for use when the
		operand-size attribute is 32. Some assemblers may force the operand size to 16 for POPF and to 32 for POPFD.
		Others may treat the mnemonics as synonyms (POPF/POPFD) and use the setting of the operand-size attribute to
		determine the size of values to pop from the stack.
		
		The effect of POPF/POPFD on the EFLAGS register changes, depending on the mode of operation.
		When operating in protected, compatibility, or 64-bit mode at privilege level 0 (or in real-address mode, the equiv-
		alent to privilege level 0), all non-reserved flags in the EFLAGS register except RF1, VIP, VIF, and VM may be modi-
		fied. VIP, VIF and VM remain unaffected.
		
		When operating in protected, compatibility, or 64-bit mode with a privilege level greater than 0, but less than or
		equal to IOPL, all flags can be modified except the IOPL field and RF1, IF, VIP, VIF, and VM; these remain unaf-
		fected. The AC and ID flags can only be modified if the operand-size attribute is 32. The interrupt flag (IF) is altered
		only when executing at a level at least as privileged as the IOPL. If a POPF/POPFD instruction is executed with
		insufficient privilege, an exception does not occur but privileged bits do not change.
		
		When operating in virtual-8086 mode (EFLAGS.VM = 1) without the virtual-8086 mode extensions (CR4.VME = 0),
		the POPF/POPFD instructions can be used only if IOPL = 3; otherwise, a general-protection exception (#GP)
		occurs. If the virtual-8086 mode extensions are enabled (CR4.VME = 1), POPF (but not POPFD) can be executed in
		virtual-8086 mode with IOPL < 3.
		
		In 64-bit mode, use REX.W to pop the top of stack to RFLAGS. The mnemonic assigned is POPFQ (note that the 32-
		bit operand is not encodable). POPFQ pops 64 bits from the stack, loads the lower 32 bits into RFLAGS, and zero
		extends the upper bits of RFLAGS.
		
		@see(flags) for more information about the EFLAGS registers.

	exceptions

	flags

	operation

	meta
		see
			flags => Chapter 3 - "EFLAGS", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


por/vpor=Bitwise Logical OR 
	forms

	description
		Performs a bitwise logical OR operation on the source operand (second operand) and the destination operand (first
		operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the
		corresponding bits of the first and second operands are 1; otherwise, it is set to 0.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand is an MMX technology register.
		
		128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
		source and destination operands can be XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination
		register remain unchanged.
		
		VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
		source and destination operands can be XMM registers. Bits (VLMAX-1:128) of the destination YMM register are
		zeroed.
		
		VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first
		source and destination operands can be YMM registers.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


prefetcht0=Move data closer to the processor using T0 hint
prefetcht1=Move data closer to the processor using T1 hint
prefetcht2=Move data closer to the processor using T2 hint
prefetchnta=Move data closer to the processor using NTA hint
prefetchh=
	forms

	description
		Fetches the line of data from memory that contains the byte specified with the source operand to a location in the
		cache hierarchy specified by a locality hint:
		- T0 (temporal data) - prefetch data into all levels of the cache hierarchy.
			- Pentium III processor - 1st- or 2nd-level cache.
			- Pentium 4 and Intel Xeon processors - 2nd-level cache.
		
		- T1 (temporal data with respect to first level cache) - prefetch data into level 2 cache and higher.
			- Pentium III processor - 2nd-level cache.
			- Pentium 4 and Intel Xeon processors - 2nd-level cache.
		
		- T2 (temporal data with respect to second level cache) - prefetch data into level 2 cache and higher.
			- Pentium III processor - 2nd-level cache.
			- Pentium 4 and Intel Xeon processors - 2nd-level cache.
		
		- NTA (non-temporal data with respect to all cache levels) - prefetch data into non-temporal cache structure and into a location close to the processor, minimizing cache pollution.
			- Pentium III processor - 1st-level cache
			- Pentium 4 and Intel Xeon processors - 2nd-level cache
		
		The source operand is a byte memory location. (The locality hints are encoded into the machine level instruction
		using bits 3 through 5 of the ModR/M byte.)
		
		If the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement
		occurs. Prefetches from uncacheable or WC memory are ignored.
		
		The PREFETCHh instruction is merely a hint and does not affect program behavior. If executed, this instruction
		moves data closer to the processor in anticipation of future use.
		
		The implementation of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a
		processor implementation. The amount of data prefetched is also processor implementation-dependent. It will,
		however, be a minimum of 32 bytes.
		
		It should be noted that processors are free to speculatively fetch and cache data from system memory regions that
		are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). A
		PREFETCHh instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur
		at any time and is not tied to instruction execution, a PREFETCHh instruction is not ordered with respect to the
		fence instructions (@ref(mfence), @ref(sfence), and @ref(lfence)) or locked memory references. A PREFETCHh instruction is also
		unordered with respect to CLFLUSH instructions, other PREFETCHh instructions, or any other general instruction.
		It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


prefetchw=Prefetch Data into Caches in Anticipation of a Write 
	forms

	description
		Fetches the cache line of data from memory that contains the byte specified with the source operand to a location
		in the 1st or 2nd level cache and invalidates all other cached instances of the line.
		The source operand is a byte memory location. If the line selected is already present in the lowest level cache and
		is already in an exclusively owned state, no data movement occurs. Prefetches from non-writeback memory are ignored.
		The PREFETCHW instruction is merely a hint and does not affect program behavior. If executed, this instruction
		moves data closer to the processor and invalidates any other cached copy in anticipation of the line being written
		to in the future.
		
		The characteristic of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a
		processor implementation. The amount of data prefetched is also processor implementation-dependent. It will,
		however, be a minimum of 32 bytes.
		
		It should be noted that processors are free to speculatively fetch and cache data with exclusive ownership from
		system memory regions that permit such accesses (that is, the WB memory type). A PREFETCHW instruction is
		considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not
		tied to instruction execution, a PREFETCHW instruction is not ordered with respect to the fence instructions
		(@ref(mfence), @ref(sfence), and @ref(lfence)) or locked memory references. A PREFETCHW instruction is also unordered with
		respect to CLFLUSH instructions, other PREFETCHW instructions, or any other general instruction
		It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


prefetchwt1=Prefetch Vector Data Into Caches with Intent to Write and T1 Hint 
	forms

	description
		Fetches the line of data from memory that contains the byte specified with the source operand to a location in the
		cache hierarchy specified by an intent to write hint (so that data is brought into 'Exclusive' state via a request for
		ownership) and a locality hint:
		
		- T1 (temporal data with respect to first level cache) - prefetch data into the second level cache.
		
		The source operand is a byte memory location. (The locality hints are encoded into the machine level instruction
		using bits 3 through 5 of the ModR/M byte. Use of any ModR/M value other than the specified ones will lead to
		unpredictable behavior.)
		
		If the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement
		occurs. Prefetches from uncacheable or WC memory are ignored.
		
		The @ref(prefetchh) instruction is merely a hint and does not affect program behavior. If executed, this instruction
		moves data closer to the processor in anticipation of future use.
		
		The implementation of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a
		processor implementation. The amount of data prefetched is also processor implementation-dependent. It will,
		however, be a minimum of 32 bytes.
		
		It should be noted that processors are free to speculatively fetch and cache data from system memory regions that
		are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). 
		A @ref(prefetchh) instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur
		at any time and is not tied to instruction execution, a @ref(prefetchh) instruction is not ordered with respect to the
		fence instructions (@ref(mfence), @ref(sfence), and @ref(lfence)) or locked memory references. A @ref(prefetchh) instruction is also
		unordered with respect to CLFLUSH instructions, other @ref(prefetchh) instructions, or any other general instruction. It
		is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


psadbw/vpsadbw=Compute Sum of Absolute Differences 
	forms

	description
		Computes the absolute value of the difference of 8 unsigned byte integers from the source operand (second
		operand) and from the destination operand (first operand). These 8 differences are then summed to produce an
		unsigned word integer result that is stored in the destination operand. Figure 4-10 shows the operation of the
		PSADBW instruction when using 64-bit operands.
		
		When operating on 64-bit operands, the word integer result is stored in the low word of the destination operand,
		and the remaining bytes in the destination operand are cleared to all 0s.
		
		When operating on 128-bit operands, two packed results are computed. Here, the 8 low-order bytes of the source
		and destination operands are operated on to produce a word result that is stored in the low word of the destination
		operand, and the 8 high-order bytes are operated on to produce a word result that is stored in bits 64 through 79
		of the destination operand. The remaining bytes of the destination operand are cleared.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand is an MMX technology register.
		
		128-bit Legacy SSE version: The first source operand and destination register are XMM registers. The second
		source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The first source operand and destination register are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The first source operand and destination register are YMM registers. The second source
		operand is an YMM register or a 256-bit memory location.
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pshufb/vpshufb=Packed Shuffle Bytes 
	forms

	description
		PSHUFB performs in-place shuffles of bytes in the destination operand (the first operand) according to the shuffle
		control mask in the source operand (the second operand). The instruction permutes the data in the destination
		operand, leaving the shuffle mask unaffected. If the most significant bit (bit[7]) of each byte of the shuffle control
		mask is set, then constant zero is written in the result byte. Each byte in the shuffle control mask forms an index
		to permute the corresponding byte in the destination operand. The value of each index is the least significant 4 bits
		(128-bit operation) or 3 bits (64-bit operation) of the shuffle control byte. When the source operand is a 128-bit
		memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.
		
		In 64-bit mode, use the REX prefix to access additional registers.
		
		Legacy SSE version: Both operands can be MMX registers.
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
		1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The destination operand is the first operand, the first source operand is the second
		operand, the second source operand is the third operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: Bits (255:128) of the destination YMM register stores the 16-byte shuffle result of the
		upper 16 bytes of the first source operand, using the upper 16-bytes of the second source operand as control
		mask. The value of each index is for the high 128-bit lane is the least significant 4 bits of the respective shuffle
		control byte. The index value selects a source data element within each 128-bit lane.
		
		Note: VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pshufd/vpshufd=Shuffle Packed Doublewords 
	forms

	description
		Copies doublewords from source operand (second operand) and inserts them in the destination operand (first
		operand) at the locations selected with the order operand (third operand). 
		
		Each 2-bit field in the order operand selects the contents of one doubleword location within a 128-bit lane and 
		copies to the target element in the destination operand.
		
		For example, bits 0 and 1 of the order operand targets the first doubleword element in the low and high
		128-bit lane of the destination operand for 256-bit VPSHUFD. The encoded value of bits 1:0 of the order operand
		(see the field encoding in Figure 4-12) determines which doubleword element (from the respective 128-bit lane) of
		the source operand will be copied to doubleword 0 of the destination operand.
		
		For 128-bit operation, only the low 128-bit lane are operative. The source operand can be an XMM register or a
		
		128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate.
		
		Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword
		location in the destination operand.

		The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM
		register. The order operand is an 8-bit immediate. Note that this instruction permits a doubleword in the source
		operand to be copied to more than one doubleword location in the destination operand.
		Legacy SSE instructions: In 64-bit mode using a REX prefix in the form of REX.R permits this instruction to access
		additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: Bits (255:128) of the destination stores the shuffled results of the upper 16 bytes of the
		source operand using the immediate byte as the order operand.
		
		Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.

	exceptions

	flags

	operation

	meta


pshufhw/vpshufhw=Shuffle Packed High Words 
	forms

	description
		Copies words from the high quadword of a 128-bit lane of the source operand and inserts them in the high quad-
		word of the destination operand at word locations (of the respective lane) selected with the immediate operand.
		This 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illus-
		trated in Figure 4-12. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate
		operand selects the contents of one word location in the high quadword of the destination operand. The binary
		encodings of the immediate operand fields select words (0, 1, 2 or 3, 4) from the high quadword of the source
		operand to be copied to the destination operand. The low quadword of the source operand is copied to the low
		quadword of the destination operand, for each 128-bit lane.
		
		Note that this instruction permits a word in the high quadword of the source operand to be copied to more than one
		word location in the high quadword of the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM
		register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register
		or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.vvvv is
		reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.
		
		VEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register
		or a 256-bit memory location.
		
		Note: In VEX encoded versions VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


pshuflw/vpshuflw=Shuffle Packed Low Words 
	forms

	description
		Copies words from the low quadword of a 128-bit lane of the source operand and inserts them in the low quadword
		of the destination operand at word locations (of the respective lane) selected with the immediate operand. The
		256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illustrated
		in Figure 4-12. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate
		operand selects the contents of one word location in the low quadword of the destination operand. The binary
		encodings of the immediate operand fields select words (0, 1, 2 or 3) from the low quadword of the source operand
		to be copied to the destination operand. The high quadword of the source operand is copied to the high quadword
		of the destination operand, for each 128-bit lane.
		
		Note that this instruction permits a word in the low quadword of the source operand to be copied to more than one
		word location in the low quadword of the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM
		register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register
		or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register
		or a 256-bit memory location.
		
		Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


pshufw=Shuffle Packed Words 
	forms

	description
		Copies words from the source operand (second operand) and inserts them in the destination operand (first
		operand) at word locations selected with the order operand (third operand). This operation is similar to the opera-
		tion used by the PSHUFD instruction, which is illustrated in Figure 4-12. For the PSHUFW instruction, each 2-bit
		field in the order operand selects the contents of one word location in the destination operand. The encodings of the
		order operand fields select words from the source operand to be copied to the destination operand.
		
		The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an
		MMX technology register. The order operand is an 8-bit immediate. Note that this instruction permits a word in the
		source operand to be copied to more than one word location in the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


psignb/psignw/psignd=Packed SIGN
vpsignb/vpsignw/vpsignd=Packed SIGN 
	forms

	description
		(V)PSIGNB/(V)PSIGNW/(V)PSIGND negates each data element of the destination operand (the first operand) if the
		signed integer value of the corresponding data element in the source operand (the second operand) is less than
		zero. If the signed integer value of a data element in the source operand is positive, the corresponding data
		element in the destination operand is unchanged. If a data element in the source operand is zero, the corre-
		sponding data element in the destination operand is set to zero.
		
		(V)PSIGNB operates on signed bytes. (V)PSIGNW operates on 16-bit signed words. (V)PSIGND operates on signed
		32-bit integers. When the source operand is a 128bit memory operand, the operand must be aligned on a 16-byte
		boundary or a general-protection exception (#GP) will be generated.
		
		Legacy SSE instructions: Both operands can be MMX registers. In 64-bit mode, use the REX prefix to access addi-
		tional registers
		.
		128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
		operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
		zeroed. VEX.L must be 0, otherwise instructions will #UD.
		
		VEX.256 encoded version: The first source and destination operands are YMM registers. The second source
		operand is an YMM register or a 256-bit memory location.

	exceptions

	flags

	operation

	meta


pslldq/vpslldq=Shift Double Quadword Left Logical 
	forms

	description
		Shifts the destination operand (first operand) to the left by the number of bytes specified in the count operand
		(second operand). The empty low-order bytes are cleared (set to all 0s). If the value specified by the count
		operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.
		128-bit Legacy SSE version: The source and destination operands are the same. Bits (VLMAX-1:128) of the corre-
		sponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The source and destination operands are XMM registers. Bits (VLMAX-1:128) of the
		destination YMM register are zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register. The destination operand is a YMM register. The
		count operand applies to both the low and high 128-bit lanes.
		
		Note: VEX.vvvv encodes the destination register, and VEX.B + ModRM.r/m encodes the source register. VEX.L must
		be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


psllw/pslld/psllq=Shift Packed Data Left Logical
vpsllw/vpslld/vpsllq=Shift Packed Data Left Logical 
	forms

	description
		Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first
		operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data
		elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count
		operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand
		is set to all 0s.
		
		The (V)PSLLW instruction shifts each of the words in the destination operand to the left by the number of bits spec-
		ified in the count operand; the (V)PSLLD instruction shifts each of the doublewords in the destination operand; and
		the (V)PSLLQ instruction shifts the quadword (or quadwords) in the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		Legacy SSE instructions: The destination operand is an MMX technology register; the count operand can be either
		an MMX technology register or an 64-bit memory location.
		
		128-bit Legacy SSE version: The destination and first source operands are XMM registers. Bits (VLMAX-1:128) of
		the corresponding YMM destination register remain unchanged. The count operand can be either an XMM register
		or a 128-bit memory location or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded
		but the upper 64 bits are ignored.
		
		VEX.128 encoded version: The destination and first source operands are XMM registers. Bits (VLMAX-1:128) of the
		destination YMM register are zeroed. The count operand can be either an XMM register or a 128-bit memory loca-
		tion or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.
		
		VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be
		either an XMM register or a 128-bit memory location or an 8-bit immediate.
		
		Note: For shifts with an immediate count (VEX.128.66.0F 71-73 /6), VEX.vvvv encodes the destination register,
		and VEX.B + ModRM.r/m encodes the source register. VEX.L must be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


psraw/psrad=Shift Packed Data Right Arithmetic
vpsraw/vpsrad=Shift Packed Data Right Arithmetic
	forms

	description
		Shifts the bits in the individual data elements (words or doublewords) in the destination operand (first operand) to
		the right by the number of bits specified in the count operand (second operand). As the bits in the data elements
		are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element. If the
		value specified by the count operand is greater than 15 (for words) or 31 (for doublewords), each destination data
		element is filled with the initial value of the sign bit of the element.
		
		Note that only the first 64-bits of a 128-bit count operand are checked to compute the count. If the second source
		operand is a memory address, 128 bits are loaded.
		
		The (V)PSRAW instruction shifts each of the words in the destination operand to the right by the number of bits
		specified in the count operand, and the (V)PSRAD instruction shifts each of the doublewords in the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		Legacy SSE instructions: The destination operand is an MMX technology register; the count operand can be either
		an MMX technology register or an 64-bit memory location.
		
		128-bit Legacy SSE version: The destination and first source operands are XMM registers. Bits (VLMAX-1:128) of
		the corresponding YMM destination register remain unchanged. The count operand can be either an XMM register
		or a 128-bit memory location or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded
		but the upper 64 bits are ignored.
		
		VEX.128 encoded version: The destination and first source operands are XMM registers. Bits (VLMAX-1:128) of the
		destination YMM register are zeroed. The count operand can be either an XMM register or a 128-bit memory loca-
		tion or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.
		
		VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be
		either an XMM register or a 128-bit memory location or an 8-bit immediate.
		
		Note: For shifts with an immediate count (VEX.128.66.0F 71-73 /4), VEX.vvvv encodes the destination register,
		and VEX.B + ModRM.r/m encodes the source register. VEX.L must be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


psrldq/vpsrldq=Shift Double Quadword Right Logical
	forms

	description
		Shifts the destination operand (first operand) to the right by the number of bytes specified in the count operand
		(second operand). The empty high-order bytes are cleared (set to all 0s). If the value specified by the count
		operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The source and destination operands are the same. Bits (VLMAX-1:128) of the corre-
		sponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The source and destination operands are XMM registers. Bits (VLMAX-1:128) of the
		destination YMM register are zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register. The destination operand is a YMM register. The
		count operand applies to both the low and high 128-bit lanes.
		
		Note: VEX.vvvv encodes the destination register, and VEX.B + ModRM.r/m encodes the source register. VEX.L must be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


psrlw/psrld/psrlq=Shift Packed Data Right Logical
vpsrlw/vpsrld/vpsrlq=Shift Packed Data Right Logical 
	forms

	description
		Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first
		operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data
		elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count
		operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand
		is set to all 0s.
		
		Note that only the first 64-bits of a 128-bit count operand are checked to compute the count.
		The (V)PSRLW instruction shifts each of the words in the destination operand to the right by the number of bits
		specified in the count operand; the (V)PSRLD instruction shifts each of the doublewords in the destination operand;
		and the PSRLQ instruction shifts the quadword (or quadwords) in the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE instructions: The destination operand is an MMX technology register; the count operand can be either
		an MMX technology register or an 64-bit memory location.
		
		128-bit Legacy SSE version: The destination operand is an XMM register; the count operand can be either an XMM
		register or a 128-bit memory location, or an 8-bit immediate. If the count operand is a memory address, 128 bits
		are loaded but the upper 64 bits are ignored. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The destination operand is an XMM register; the count operand can be either an XMM
		register or a 128-bit memory location, or an 8-bit immediate. If the count operand is a memory address, 128 bits
		are loaded but the upper 64 bits are ignored. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be
		either an YMM register or a 128-bit memory location or an 8-bit immediate.
		
		Note: For shifts with an immediate count (VEX.128.66.0F 71-73 /2), VEX.vvvv encodes the destination register,
		and VEX.B + ModRM.r/m encodes the source register. VEX.L must be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


psubb/psubw/psubd=Subtract Packed Integers 
vpsubb/vpsubw/vpsubd=Subtract Packed Integers 
	forms

	description
		Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers
		of the destination operand (first operand), and stores the packed integer results in the destination operand. See
		
		Overflow is handled with wraparound, as described in the following paragraphs.
		The (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be
		represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.
		The (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be
		represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.
		The (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small
		to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.
		Note that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's
		complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow
		and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE version: When operating on 64-bit operands, the destination operand must be an MMX technology
		register and the source operand can be either an MMX technology register or a 64-bit memory location.
		
		128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
		source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
		source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first
		source operand and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


psubq/vpsubq=Subtract Packed Quadword Integers 
	forms

	description
		Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result
		in the destination operand. When packed quadword operands are used, a SIMD subtract is performed. When a
		quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64
		bits are written to the destination element (that is, the carry is ignored).
		
		Note that the (V)PSUBQ instruction can operate on either unsigned or signed (two's complement notation) inte-
		gers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected
		overflow conditions, software must control the ranges of the values upon which it operates.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE version: The source operand can be a quadword integer stored in an MMX technology register or a 64-bit memory location.
		
		128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
		source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
		source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first
		source operand and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


psubsb/psubsw=Subtract Packed Signed Integers with Signed Saturation
vpsubsb/vpsubsw=Subtract Packed Signed Integers with Signed Saturation
	forms

	description
		Performs a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed
		signed integers of the destination operand (first operand), and stores the packed integer results in the destination
		operand. Overflow is handled with signed saturation, as described in the following paragraphs.
		
		The (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the
		range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H,
		respectively, is written to the destination operand.
		
		The (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the
		range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or
		8000H, respectively, is written to the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		Legacy SSE version: When operating on 64-bit operands, the destination operand must be an MMX technology
		register and the source operand can be either an MMX technology register or a 64-bit memory location.
		
		128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
		source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-
		nation register remain unchanged.
		
		VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
		source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first
		source operand and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


psubusb/psubusw=Subtract Packed Unsigned Integers with Unsigned Saturation
vpsubusb/vpsubusw=Subtract Packed Unsigned Integers with Unsigned Saturation
	forms

	description
		Performs a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the
		packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer
		results in the destination operand. Overflow is handled with unsigned saturation, as described in the following paragraphs.
		
		These instructions can operate on either 64-bit or 128-bit operands.
		The (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than
		zero, the saturated value of 00H is written to the destination operand.
		The (V)PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than
		zero, the saturated value of 0000H is written to the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		Legacy SSE version: When operating on 64-bit operands, the destination operand must be an MMX technology
		register and the source operand can be either an MMX technology register or a 64-bit memory location.
		
		128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
		source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-
		nation register remain unchanged.
		
		VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
		source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first
		source operand and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


ptest/vptest=Packed Logical Compare
	forms

	description
		PTEST and VPTEST set the ZF flag if all bits in the result are 0 of the bitwise AND of the first source operand (first
		operand) and the second source operand (second operand). VPTEST sets the CF flag if all bits in the result are 0 of
		the bitwise AND of the second source operand (second operand) and the logical NOT of the destination operand.
		The first source register is specified by the ModR/M reg field.
		
		128-bit versions: The first source register is an XMM register. The second source register can be an XMM register
		or a 128-bit memory location. The destination register is not modified.
		
		VEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM
		register or a 256-bit memory location. The destination register is not modified.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


punpckhbw/punpckhwd/punpckhdq/punpckhqdq=Unpack High Data
vpunpckhbw/vpunpckhwd/vpunpckhdq/vpunpckhqdq=Unpack High Data 
	forms

	description
		Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destina-
		tion operand (first operand) and source operand (second operand) into the destination operand. The low-order data elements are ignored.
		
		When the source data comes from a 64-bit memory operand, the full 64-bit operand is accessed from memory, but
		the instruction uses only the high-order 32 bits. When the source data comes from a 128-bit memory operand, an
		implementation may fetch only the appropriate 64 bits; however, alignment to a 16-byte boundary and normal
		segment checking will still be enforced.
		
		The (V)PUNPCKHBW instruction interleaves the high-order bytes of the source and destination operands, the
		(V)PUNPCKHWD instruction interleaves the high-order words of the source and destination operands, the
		(V)PUNPCKHDQ instruction interleaves the high-order doubleword (or doublewords) of the source and destination
		operands, and the (V)PUNPCKHQDQ instruction interleaves the high-order quadwords of the source and destina-
		tion operands.
		
		These instructions can be used to convert bytes to words, words to doublewords, doublewords to quadwords, and
		quadwords to double quadwords, respectively, by placing all 0s in the source operand. Here, if the source operand
		contains all 0s, the result (stored in the destination operand) contains zero extensions of the high-order data
		elements from the original value in the destination operand. For example, with the (V)PUNPCKHBW instruction the
		high-order bytes are zero extended (that is, unpacked into unsigned word integers), and with the (V)PUNPCKHWD
		instruction, the high-order words are zero extended (unpacked into unsigned doubleword integers).
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE versions: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand is an MMX technology register.
		
		128-bit Legacy SSE versions: The second source operand is an XMM register or a 128-bit memory location. The
		first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded versions: The second source operand is an XMM register or a 128-bit memory location. The first
		source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first
		source operand and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


punpcklbw/punpcklwd/punpckldq/punpcklqdq=Unpack Low Data
vpunpcklbw/vpunpcklwd/vpunpckldq/vpunpcklqdq=Unpack Low Data
	forms

	description
		Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destina-
		tion operand (first operand) and source operand (second operand) into the destination operand. The high-order data elements are ignored.
		
		When the source data comes from a 128-bit memory operand, an implementation may fetch only the appropriate
		64 bits; however, alignment to a 16-byte boundary and normal segment checking will still be enforced.
		The (V)PUNPCKLBW instruction interleaves the low-order bytes of the source and destination operands, the
		(V)PUNPCKLWD instruction interleaves the low-order words of the source and destination operands, the
		(V)PUNPCKLDQ instruction interleaves the low-order doubleword (or doublewords) of the source and destination
		operands, and the (V)PUNPCKLQDQ instruction interleaves the low-order quadwords of the source and destination operands.
		
		These instructions can be used to convert bytes to words, words to doublewords, doublewords to quadwords, and
		quadwords to double quadwords, respectively, by placing all 0s in the source operand. Here, if the source operand
		contains all 0s, the result (stored in the destination operand) contains zero extensions of the high-order data
		elements from the original value in the destination operand. For example, with the (V)PUNPCKLBW instruction the
		high-order bytes are zero extended (that is, unpacked into unsigned word integers), and with the (V)PUNPCKLWD
		instruction, the high-order words are zero extended (unpacked into unsigned doubleword integers).
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE versions: The source operand can be an MMX technology register or a 32-bit memory location. The
		destination operand is an MMX technology register.
		
		128-bit Legacy SSE versions: The second source operand is an XMM register or a 128-bit memory location. The
		first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
		destination register remain unchanged.
		
		VEX.128 encoded versions: The second source operand is an XMM register or a 128-bit memory location. The first
		source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first
		source operand and destination operands are YMM registers.
		
		Note: VEX.L must be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


push=Push Word, Doubleword or Quadword Onto the Stack 
	forms

	description
		Decrements the stack pointer and then stores the source operand on the top of the stack. Address and operand
		sizes are determined and used as follows:
		- Address size. The D flag in the current code-segment descriptor determines the default address size; it may be overridden by an instruction prefix (67H).
			The address size is used only when referencing a source operand in memory.
		
		- Operand size. The D flag in the current code-segment descriptor determines the default operand size; it may
			be overridden by instruction prefixes (66H or REX.W).
			The operand size (16, 32, or 64 bits) determines the amount by which the stack pointer is decremented (2, 4 or 8).
			If the source operand is an immediate of size less than the operand size, a sign-extended value is pushed on
			the stack. If the source operand is a segment register (16 bits) and the operand size is 64-bits, a zero-
			extended value is pushed on the stack; if the operand size is 32-bits, either a zero-extended value is pushed
			on the stack or the segment selector is written on the stack using a 16-bit move. For the last case, all recent
			Core and Atom processors perform a 16-bit move, leaving the upper portion of the stack location unmodified.
		
		- Stack-address size. Outside of 64-bit mode, the B flag in the current stack-segment descriptor determines the
			size of the stack pointer (16 or 32 bits); in 64-bit mode, the size of the stack pointer is always 64 bits.
			The stack-address size determines the width of the stack pointer when writing to the stack in memory and
			when decrementing the stack pointer. (As stated above, the amount by which the stack pointer is decremented is determined by the operand size.)
			If the operand size is less than the stack-address size, the PUSH instruction may result in a misaligned stack
			pointer (a stack pointer that is not aligned on a doubleword or quadword boundary).
		
		The PUSH ESP instruction pushes the value of the ESP register as it existed before the instruction was executed. If
		a PUSH instruction uses a memory operand in which the ESP register is used for computing the operand address,
		the address of the operand is computed before the ESP register is decremented.
		
		If the ESP or SP register is 1 when the PUSH instruction is executed in real-address mode, a stack-fault exception
		(#SS) is generated (because the limit of the stack segment is violated). Its delivery encounters a second stack-
		fault exception (for the same reason), causing generation of a double-fault exception (#DF).
		Delivery of the double-fault exception encounters a third stack-fault exception, and the logical processor enters shutdown mode.
		@see(fault)
		
		For IA-32 processors from the Intel 286 on, the PUSH ESP instruction pushes the value of the ESP register as it
		existed before the instruction was executed. (This is also true for Intel 64 architecture, real-address and virtual-
		8086 modes of IA-32 architecture.) For the Intel 8086 processor, the PUSH SP instruction pushes the new value
		of the SP register (that is the value after it has been decremented by 2).

	exceptions

	flags

	operation

	meta
		see
			fault => Chapter 6 - "Double Fault", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A


pusha/pushad=Push All General-Purpose Registers 
	forms

	description
		Pushes the contents of the general-purpose registers onto the stack. The registers are stored on the stack in the
		following order: EAX, ECX, EDX, EBX, ESP (original value), EBP, ESI, and EDI (if the current operand-size attribute
		is 32) and AX, CX, DX, BX, SP (original value), BP, SI, and DI (if the operand-size attribute is 16). These instruc-
		tions perform the reverse operation of the POPA/POPAD instructions. The value pushed for the ESP or SP register
		is its value before prior to pushing the first register.
		
		The PUSHA (push all) and PUSHAD (push all double) mnemonics reference the same opcode. The PUSHA instruc-
		tion is intended for use when the operand-size attribute is 16 and the PUSHAD instruction for when the operand-
		size attribute is 32. Some assemblers may force the operand size to 16 when PUSHA is used and to 32 when
		PUSHAD is used. Others may treat these mnemonics as synonyms (PUSHA/PUSHAD) and use the current setting
		of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.
		In the real-address mode, if the ESP or SP register is 1, 3, or 5 when PUSHA/PUSHAD executes: an #SS exception
		is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates a
		#DF exception and enters a shutdown state as described in the #DF documentation, @see(fault).
		
		This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta
		see
			fault => Chapter 6 - "Double Fault", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A

pushf/pushfd=Push EFLAGS Register onto the Stack 
	forms

	description
		Decrements the stack pointer by 4 (if the current operand-size attribute is 32) and pushes the entire contents of
		the EFLAGS register onto the stack, or decrements the stack pointer by 2 (if the operand-size attribute is 16) and
		pushes the lower 16 bits of the EFLAGS register (that is, the FLAGS register) onto the stack. These instructions
		reverse the operation of the POPF/POPFD instructions.
		
		When copying the entire EFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead,
		the values for these flags are cleared in the EFLAGS image stored on the stack. See Chapter 3 of the Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1, for more information about the EFLAGS register.
		The PUSHF (push flags) and PUSHFD (push flags double) mnemonics reference the same opcode. The PUSHF
		instruction is intended for use when the operand-size attribute is 16 and the PUSHFD instruction for when the
		operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHF is used and to 32
		when PUSHFD is used. Others may treat these mnemonics as synonyms (PUSHF/PUSHFD) and use the current
		setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the
		mnemonic used.
		
		In 64-bit mode, the instruction's default operation is to decrement the stack pointer (RSP) by 8 and pushes RFLAGS
		on the stack. 16-bit operation is supported using the operand size override prefix 66H. 32-bit operand size cannot
		be encoded in this mode. When copying RFLAGS to the stack, the VM and RF flags (bits 16 and 17) are not copied;
		instead, values for these flags are cleared in the RFLAGS image stored on the stack.
		When in virtual-8086 mode and the I/O privilege level (IOPL) is less than 3, the PUSHF/PUSHFD instruction causes
		a general protection exception (#GP).
		
		In the real-address mode, if the ESP or SP register is 1 when PUSHF/PUSHFD instruction executes: an #SS excep-
		tion is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates
		a #DF exception and enters a shutdown state as described in the #DF documentation, @see(fault)

	exceptions

	flags

	operation

	meta
		see
			fault => Chapter 6 - "Double Fault", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A


pxor/vpxor=Packed Logical Exclusive OR
	forms

	description
		Performs a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destina-
		tion operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corre-
		sponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
		destination operand is an MMX technology register.
		
		128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
		source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-
		nation register remain unchanged.
		
		VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
		source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		
		VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first
		source operand and destination operands are YMM registers.
		Note: VEX.L must be 0, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


rcl/rcr/rol/ror=Rotate 
	forms

	description
		Shifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the
		second operand (count operand) and stores the result in the destination operand. The destination operand can be
		a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in
		the CL register. In legacy and compatibility mode, the processor restricts the count to a number between 0 and 31
		by masking all the bits in the count operand except the 5 least-significant bits.
		
		The rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit
		positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right
		(ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except
		for the least-significant bit, which is rotated to the most-significant bit location.
		
		The RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the
		least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the
		most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the orig-
		inal value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from
		one end to the other.
		
		The OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions
		only: a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR
		of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the
		exclusive OR of the two most-significant bits of the result.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Use of
		REX.W promotes the first operand to 64 bits and causes the count operand to become a 6-bit counter.
		
		The 8086 does not mask the rotation count. However, all other IA-32 processors (starting with the Intel 286
		processor) do mask the rotation count to 5 bits, resulting in a maximum count of 31. This masking is done in all
		operating modes (including the virtual-8086 mode) to reduce the maximum execution time of the instructions.

	exceptions

	flags

	operation

	meta


rcpps/vrcpps=Compute Reciprocals of Packed Single-Precision Floating-Point Values 
	forms

	description
		Performs a SIMD computation of the approximate reciprocals of the four packed single-precision floating-point
		values in the source operand (second operand) stores the packed single-precision floating-point results in the
		destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination
		operand is an XMM register.
		
		The relative error for this approximation is:
		
			|Relative Error| <= 1.5 * 2^-12
		
		The RCPPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a
		0.0, an infinity of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign).
		
		Tiny results (@see(underflow)) are always flushed to 0.0, with the sign of the operand. (Input values greater
		than or equal to |1.11111111110100000000000B*2^125| are guaranteed to not produce tiny results; input values
		less than or equal to |1.00000000000110000000001B*2^126| are guaranteed to produce tiny results, which are in
		turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the
		implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not 
		distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta
		see
			underflow => Section 4.9.1.5 - "Numeric Underflow Exception (#U)", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


rcpss/vrcpss=Compute Reciprocal of Scalar Single-Precision Floating-Point Values 
	forms

	description
		Computes of an approximate reciprocal of the low single-precision floating-point value in the source operand
		(second operand) and stores the single-precision floating-point result in the destination operand. The source
		operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The
		three high-order doublewords of the destination operand remain unchanged.
		
		The relative error for this approximation is:
		
			|Relative Error| <= 1.5 * 2^-12
		
		The RCPSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a
		0.0, an infinity of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign).
		
		Tiny results (@see(underflow)) are always flushed to 0.0, with the sign of the operand. (Input values greater
		than or equal to |1.11111111110100000000000B * 2^125| are guaranteed to not produce tiny results; input values
		less than or equal to |1.00000000000110000000001B * 2^126| are guaranteed to produce tiny results, which are in
		turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the
		implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
		1:32) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta
		see
			underflow => Section 4.9.1.5 - "Numeric Underflow Exception (#U)", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


rdfsbase=Read FS Segment Base
rdgsbase=Read GS Segment Base
	forms

	description
		Loads the general-purpose register indicated by the modR/M:r/m field with the FS or GS segment base address.
		
		The destination operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates
		the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source
		base address (for FS or GS) are ignored and upper 32 bits of the destination register are cleared.
		
		This instruction is supported only in 64-bit mode.

	exceptions

	flags

	operation

	meta


rdmsr=Read from Model Specific Register 
	forms

	description
		Reads the contents of a 64-bit model specific register (MSR) specified in the ECX register into registers EDX:EAX.
		(On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register
		is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On
		processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If
		fewer than 64 bits are implemented in the MSR being read, the values returned to EDX:EAX in unimplemented bit
		locations are undefined.
		
		This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection
		exception #GP(0) will be generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a
		general protection exception.
		
		The MSRs control functions for testability, execution tracing, performance-monitoring, and machine check errors.
		@see(msrs) for a list of all the MSRs that can be read with this instruction and their addresses. Note that each
		processor family has its own set of MSRs.
		
		The CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before
		using this instruction.
		
		The MSRs and the ability to read them with the RDMSR instruction were introduced into the IA-32 Architecture with
		the Pentium processor. Execution of this instruction by an IA-32 processor earlier than the Pentium processor
		results in an invalid opcode exception #UD.

	exceptions

	flags

	operation

	meta
		see
			msrs => Chapter 35 - "Model-Specific Registers (MSRs),", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3C


rdpkru=Read Protection Key Rights for User Pages 
	forms

	description
		The RDPKRU instruction loads the value of PKRU into EAX and clears EDX. ECX must be 0 when RDPKRU is
		executed; otherwise, a general-protection exception (#GP) occurs.
		
		RDPKRU can be executed only if CR4.PKE = 1; otherwise, a general-protection exception (#GP) occurs. Software
		can discover the value of CR4.PKE by examining CPUID.(EAX=07H,ECX=0H):ECX.OSPKE [bit 4].
		
		In 64-bit mode, bits 63:32 of RCX are ignored, and RDPKRU clears bits 63:32 of each of RDX and RAX.

	exceptions

	flags

	operation

	meta


rdpmc=Read Performance-Monitoring Counters
	forms

	description
		The EAX register is loaded with the low-order 32 bits. The EDX register is loaded with the supported high-order bits
		of the counter. The number of high-order bits loaded into EDX is implementation specific on processors that do no
		support architectural performance monitoring. The width of fixed-function and general-purpose performance coun-
		ters on processors supporting architectural performance monitoring are reported by CPUID 0AH leaf. See below for
		the treatment of the EDX register for "fast" reads.
		
		The ECX register selects one of two type of performance counters, specifies the index relative to the base of each
		counter type, and selects "fast" read mode if supported. The two counter types are :
		
		- General-purpose or special-purpose performance counters: The number of general-purpose counters is model
			specific if the processor does not support architectural performance monitoring, see Chapter 30 of Intel 64
			and IA-32 Architectures Software Developer's Manual, Volume 3B. Special-purpose counters are available only
			in selected processor members, see Section 30.13, 30.14 of Intel 64 and IA-32 Architectures Software
			Developer's Manual, Volume 3B. This counter type is selected if ECX[30] is clear.
		
		- Fixed-function performance counter. The number fixed-function performance counters is enumerated by CPUID
			0AH leaf. This counter type is selected if ECX[30] is set. @see(cpuid)
		
		ECX[29:0] specifies the index. The width of general-purpose performance counters are 40-bits for processors that
		do not support architectural performance monitoring counters.The width of special-purpose performance counters
		are implementation specific. The width of fixed-function performance counters and general-purpose performance
		counters on processor supporting architectural performance monitoring are reported by CPUID 0AH leaf.
		
		The Pentium 4 and Intel Xeon processors also support "fast" (32-bit) and "slow" (40-bit) reads on the first 18
		performance counters. Selected this option using ECX[31]. If bit 31 is set, RDPMC reads only the low 32 bits of the
		selected performance counter. If bit 31 is clear, all 40 bits are read. A 32-bit result is returned in EAX and EDX is
		set to 0. A 32-bit read executes faster on Pentium 4 processors and Intel Xeon processors than a full 40-bit read.
		
		On 64-bit Intel Xeon processors with L3, performance counters with indices 18-25 are 32-bit counters. EDX is
		cleared after executing RDPMC for these counters. On Intel Xeon processor 7100 series with L3, performance coun-
		ters with indices 18-25 are also 32-bit counters.
		
		In Intel Core 2 processor family, Intel Xeon processor 3000, 5100, 5300 and 7400 series, the fixed-function perfor-
		mance counters are 40-bits wide; they can be accessed by RDMPC with ECX between from 4000_0000H and 4000_0002H.
		On Intel Xeon processor 7400 series, there are eight 32-bit special-purpose counters addressable with indices 2-9, ECX[30]=0.
		When in protected or virtual 8086 mode, the performance-monitoring counters enabled (PCE) flag in register CR4
		restricts the use of the RDPMC instruction as follows. When the PCE flag is set, the RDPMC instruction can be
		executed at any privilege level; when the flag is clear, the instruction can only be executed at privilege level 0.
		(When in real-address mode, the RDPMC instruction is always enabled.)
		
		The performance-monitoring counters can also be read with the @ref(rdmsr) instruction, when executing at privilege level 0.
		
		The performance-monitoring counters are event counters that can be programmed to count events such as the
		number of instructions decoded, number of interrupts received, or number of cache loads. Chapter 19, "Perfor-
		mance Monitoring Events," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3B, lists
		the events that can be counted for various processors in the Intel 64 and IA-32 architecture families.
		
		The RDPMC instruction is not a serializing instruction; that is, it does not imply that all the events caused by the
		preceding instructions have been completed or that events caused by subsequent instructions have not begun. If
		an exact event count is desired, software must insert a serializing instruction (such as the CPUID instruction)
		before and/or after the RDPMC instruction.
		
		In the Pentium 4 and Intel Xeon processors, performing back-to-back fast reads are not guaranteed to be mono-
		tonic. To guarantee monotonicity on back-to-back reads, a serializing instruction must be placed between the two RDPMC instructions.
		
		The RDPMC instruction can execute in 16-bit addressing mode or virtual-8086 mode; however, the full contents of
		the ECX register are used to select the counter, and the event count is stored in the full EAX and EDX registers. The
		RDPMC instruction was introduced into the IA-32 Architecture in the Pentium Pro processor and the Pentium
		processor with MMX technology. The earlier Pentium processors have performance-monitoring counters, but they
		must be read with the @ref(rdmsr) instruction.

	exceptions

	flags

	operation

	meta
		see
			cpuid => Chapter 30 - "CPUID", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3B


rdrand=Read Random Number 
	forms

	description
		Loads a hardware generated random value and store it in the destination register. The size of the random value is
		determined by the destination register size and operating mode. The Carry Flag indicates whether a random value
		is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. 
		Otherwise CF=0 and the data in the destination operand will be returned as zeros for the specified width. 
		All other flags are forced to 0 in either situation. Software must check the state of CF=1 for determining if a valid random value
		has been returned, otherwise it is expected to loop and retry execution of RDRAND (@see(random)).
		
		This instruction is available at all privilege levels.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.B permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit operands.

	exceptions

	flags

	operation

	meta
		see
			random => Section 7.3.17 - "Random Number Generator Instructions", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1,


rdseed=Read Random SEED 
	forms

	description
		Loads a hardware generated random value and store it in the destination register. The random value is generated
		from an Enhanced NRBG (Non Deterministic Random Bit Generator) that is compliant to NIST SP800-90B and NIST
		SP800-90C in the XOR construction mode. The size of the random value is determined by the destination register
		size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction
		is executed. CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination
		operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. Software
		must check the state of CF=1 for determining if a valid random seed value has been returned, otherwise it is
		expected to loop and retry execution of RDSEED.
		
		The RDSEED instruction is available at all privilege levels. The RDSEED instruction executes normally either inside
		or outside a transaction region.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.B permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit operands.

	exceptions

	flags

	operation

	meta


rdtsc=Read Time-Stamp Counter 
	forms

	description
		Loads the current value of the processor's time-stamp counter (a 64-bit MSR) into the EDX:EAX registers. The EDX
		register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits.
		(On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.)
		The processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever
		the processor is reset. @see(tsc) for specific details of the time stamp counter behavior.
		
		The time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSC instruction as follows. When the
		flag is clear, the RDTSC instruction can be executed at any privilege level; when the flag is set, the instruction can
		only be executed at privilege level 0.
		
		The time-stamp counter can also be read with the RDMSR instruction, when executing at privilege level 0.
		The RDTSC instruction is not a serializing instruction. It does not necessarily wait until all previous instructions
		have been executed before reading the counter. Similarly, subsequent instructions may begin execution before the
		read operation is performed. If software requires RDTSC to be executed only after all previous instructions have
		completed locally, it can either use @ref(rdtscp) (if the processor supports that instruction) or execute the sequence
		
			LFENCE; RDTSC
		
		This instruction was introduced by the Pentium processor.

	exceptions

	flags

	operation

	meta
		see
			tsc => Chapter 17 - "Time Stamp Counter", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3B,


rdtscp=Read Time-Stamp Counter and Processor ID 
	forms

	description
		Loads the current value of the processor's time-stamp counter (a 64-bit MSR) into the EDX:EAX registers and also
		loads the IA32_TSC_AUX MSR (address C000_0103H) into the ECX register. The EDX register is loaded with the
		high-order 32 bits of the IA32_TSC MSR; the EAX register is loaded with the low-order 32 bits of the IA32_TSC
		MSR; and the ECX register is loaded with the low-order 32-bits of IA32_TSC_AUX MSR. On processors that support
		the Intel 64 architecture, the high-order 32 bits of each of RAX, RDX, and RCX are cleared.
		
		The processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever
		the processor is reset. @see(tsc) for specific details of the time stamp counter behavior.
		
		The time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSCP instruction as follows. When the
		flag is clear, the RDTSCP instruction can be executed at any privilege level; when the flag is set, the instruction can
		only be executed at privilege level 0.
		
		The RDTSCP instruction waits until all previous instructions have been executed before reading the counter.
		However, subsequent instructions may begin execution before the read operation is performed.
		The presence of the RDTSCP instruction is indicated by @ref(cpuid) leaf 80000001H, EDX bit 27. If the bit is set to 1 then
		RDTSCP is present on the processor.

	exceptions

	flags

	operation

	meta
		see
			tsc => Chapter 17 - "Time Stamp Counter", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3B,


rep/repe/repz/repne/repnz=Repeat String Operation Prefix
	forms

	description
		Repeats a string instruction the number of times specified in the count register or until the indicated condition of
		the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ
		(repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the
		string instructions. The REP prefix can be added to the @ref(ins), @ref(outs), @ref(movs), @ref(lods), and @ref(stos) instructions, and the
		REPE, REPNE, REPZ, and REPNZ prefixes can be added to the @ref(cmps) and @ref(scas) instructions. (The REPZ and REPNZ
		prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.)
		
		The F3H prefix is defined for the following instructions and undefined for the rest:
		
		- F3H as REP/REPE/REPZ for string and input/output instruction.
		- F3H is a mandatory prefix for POPCNT, LZCNT, and ADOX.
		
		The REP prefixes apply only to one string instruction at a time. To repeat a block of instructions, use the LOOP
		instruction or another looping construct. All of these repeat prefixes cause the associated instruction to be
		repeated until the count in register is decremented to 0.
		
		The REPE, REPNE, REPZ, and REPNZ prefixes also check the state of the ZF flag after each iteration and terminate
		the repeat loop if the ZF flag is not in the specified state. When both termination conditions are tested, the cause
		of a repeat termination can be determined either by testing the count register with a JECXZ instruction or by testing
		the ZF flag (with a JZ, JNZ, or JNE instruction).
		
		When the REPE/REPZ and REPNE/REPNZ prefixes are used, the ZF flag does not require initialization because both
		the CMPS and SCAS instructions affect the ZF flag according to the results of the comparisons they make.
		A repeating string operation can be suspended by an exception or interrupt. When this happens, the state of the
		registers is preserved to allow the string operation to be resumed upon a return from the exception or interrupt
		handler. The source and destination registers point to the next string elements to be operated on, the EIP register
		points to the string instruction, and the ECX register has the value it held following the last successful iteration of
		the instruction. This mechanism allows long string operations to proceed without affecting the interrupt response
		time of the system.
		
		When a fault occurs during the execution of a CMPS or SCAS instruction that is prefixed with REPE or REPNE, the
		EFLAGS value is restored to the state prior to the execution of the instruction. Since the SCAS and CMPS instructions 
		do not use EFLAGS as an input, the processor can resume the instruction after the page fault handler.
		
		Use the REP INS and REP OUTS instructions with caution. Not all I/O ports can handle the rate at which these
		instructions execute. Note that a REP STOS instruction is the fastest way to initialize a large block of memory.
		
		In 64-bit mode, the operand size of the count register is associated with the address size attribute. Thus the default
		count register is RCX; REX.W has no effect on the address size and the count register. In 64-bit mode, if 67H is used
		to override address size attribute, the count register is ECX and any implicit source/destination operand will use the
		corresponding 32-bit index register. See the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


ret=Return from Procedure
	forms

	description
		Transfers program control to a return address located on the top of the stack. The address is usually placed on the
		stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.
		The optional source operand specifies the number of stack bytes to be released after the return address is popped;
		the default is none. This operand can be used to release parameters from the stack that were passed to the called
		procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure
		uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET
		instruction must specify the same number of bytes as is specified in the word count field of the call gate.
		The RET instruction can be used to execute three different types of returns:
		
		- Near return: a return to a calling procedure within the current code segment (the segment currently pointed
		to by the CS register), sometimes referred to as an intrasegment return.
		
		- Far return: a return to a calling procedure located in a different segment than the current code segment, sometimes referred to as an intersegment return.
		- Inter-privilege-level far return: a far return to a different privilege level than that of the currently executing program or procedure.
		
		The inter-privilege-level return type can only be executed in protected mode. 
		@see(call) for detailed information on near, far, and inter-privilege-level returns.
		
		When executing a near return, the processor pops the return instruction pointer (offset) from the top of the stack
		into the EIP register and begins program execution at the new instruction pointer. The CS register is unchanged.
		When executing a far return, the processor pops the return instruction pointer from the top of the stack into the EIP
		register, then pops the segment selector from the top of the stack into the CS register. The processor then begins
		program execution in the new code segment at the new instruction pointer.
		
		The mechanics of an inter-privilege-level far return are similar to an intersegment return, except that the processor
		examines the privilege levels and access rights of the code and stack segments being returned to determine if the
		control transfer is allowed to be made. The DS, ES, FS, and GS segment registers are cleared by the RET instruction
		during an inter-privilege-level return if they refer to segments that are not allowed to be accessed at the new priv-
		ilege level. Since a stack switch also occurs on an inter-privilege level return, the ESP and SS registers are loaded
		from the stack.
		
		If parameters are passed to the called procedure during an inter-privilege level call, the optional source operand
		must be used with the RET instruction to release the parameters on the return. Here, the parameters are released
		both from the called procedure's stack and the calling procedure's stack (that is, the stack being returned to).
		In 64-bit mode, the default operation size of this instruction is the stack-address size, i.e. 64 bits. This applies to
		near returns, not far returns; the default operation size of far returns is 32 bits.

	exceptions

	flags

	operation

	meta
		see
			call => Chapter 6 - "Calling Procedures Using Call and RET", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


rorx=Rotate Right Logical Without Affecting Flags 
	forms

	description
		Rotates the bits of second operand right by the count value specified in imm8 without affecting arithmetic flags.
		The RORX instruction does not read or write the arithmetic flags.
		
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. 
		An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


roundpd/vroundpd=Round Packed Double Precision Floating-Point Values 
	forms

	description
		Round the 2 double-precision floating-point values in the source operand (second operand) using the rounding
		mode specified in the immediate operand (third operand) and place the results in the destination operand (first
		operand). The rounding process rounds each input floating-point value to an integer value and returns the integer
		result as a single-precision floating-point value.
		
		The immediate operand specifies control fields for the rounding operation.
		Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the
		source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-15 lists the encoded
		values for rounding-mode field).
		
		The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an
		SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before rounding.
		
		128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destina-
		tion is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM
		register destination are unmodified.
		
		VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destina-
		tion operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination
		operand is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


roundps/vroundps=Round Packed Single Precision Floating-Point Values 
	forms

	description
		Round the 4 single-precision floating-point values in the source operand (second operand) using the rounding
		mode specified in the immediate operand (third operand) and place the results in the destination operand (first
		operand). The rounding process rounds each input floating-point value to an integer value and returns the integer
		result as a single-precision floating-point value.
		
		The immediate operand specifies control fields for the rounding operation.
		Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the
		source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value.
		
		The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an
		SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before rounding.
		
		128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destina-
		tion is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM
		register destination are unmodified.
		
		VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destina-
		tion operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination
		operand is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


roundsd/vroundsd=Round Scalar Double Precision Floating-Point Values 
	forms

	description
		Round the DP FP value in the lower qword of the source operand (second operand) using the rounding mode spec-
		ified in the immediate operand (third operand) and place the result in the destination operand (first operand). The
		rounding process rounds a double-precision floating-point input to an integer value and returns the integer result
		as a double precision floating-point value in the lowest position. The upper double precision floating-point value in
		the destination is retained.
		
		The immediate operand specifies control fields for the rounding operation.
		Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the
		source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value.
		
		The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an
		SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before rounding.
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same. 
		Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


roundss/vroundss=Round Scalar Single Precision Floating-Point Values
	forms

	description
		Round the single-precision floating-point value in the lowest dword of the source operand (second operand) using
		the rounding mode specified in the immediate operand (third operand) and place the result in the destination
		operand (first operand). The rounding process rounds a single-precision floating-point input to an integer value
		and returns the result as a single-precision floating-point value in the lowest position. The upper three single-preci-
		sion floating-point values in the destination are retained.
		
		The immediate operand specifies control fields for the rounding operation.
		Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the
		source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value.
		
		The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an
		SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before rounding.
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
		1:32) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


rsm=Resume from System Management Mode
	forms

	description
		Returns program control from system management mode (SMM) to the application program or operating-system
		procedure that was interrupted when the processor received an SMM interrupt. The processor's state is restored
		from the dump created upon entering SMM. If the processor detects invalid state information during state restora-
		tion, it enters the shutdown state. The following invalid information can cause a shutdown:
		- Any reserved bit of CR4 is set to 1.
		- Any illegal combination of bits in CR0, such as (PG=1 and PE=0) or (NW=1 and CD=0).
		- (Intel Pentium and Intel 486 processors only.) The value stored in the state dump base field is not a 32-KByte aligned address.
		
		The contents of the model-specific registers are not affected by a return from SMM.
		
		The SMM state map used by RSM supports resuming processor context for non-64-bit modes and 64-bit mode.
		See @see(smm) for more information about SMM and the behavior of the RSM instruction.

	exceptions

	flags

	operation

	meta
		see
			smm => Chapter 34 - "System Management Mode,", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3C,


rsqrtps/vrsqrtps=Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values 
	forms

	description
		Performs a SIMD computation of the approximate reciprocals of the square roots of the four packed single-preci-
		sion floating-point values in the source operand (second operand) and stores the packed single-precision floating-
		point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location.
		The destination operand is an XMM register.
		
		The relative error for this approximation is:
		
			|Relative Error| <= 1.5 * 2^-12
		
		The RSQRTPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is
		a 0.0, an infinity of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same
		sign). When a source value is a negative value (other than -0.0), a floating-point indefinite is returned. When a
		source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location.
		The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


rsqrtss/vrsqrtss=Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value 
	forms

	description
		Computes an approximate reciprocal of the square root of the low single-precision floating-point value in the
		source operand (second operand) stores the single-precision floating-point result in the destination operand. The
		source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register.
		The three high-order doublewords of the destination operand remain unchanged.
		
		The relative error for this approximation is:
		
			|Relative Error| <= 1.5 * 2^-12
		
		The RSQRTSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is
		a 0.0, an infinity of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same
		sign). When a source value is a negative value (other than -0.0), a floating-point indefinite is returned. When a
		source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
		1:32) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


sahf=Store AH into Flags
	forms

	description
		Loads the SF, ZF, AF, PF, and CF flags of the EFLAGS register with values from the corresponding bits in the AH
		register (bits 7, 6, 4, 2, and 0, respectively). Bits 1, 3, and 5 of register AH are ignored; the corresponding reserved
		bits (1, 3, and 5) in the EFLAGS register remain untouched.
		
		This instruction executes as described above in compatibility mode and legacy mode. It is valid in 64-bit mode only
		if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1.

	exceptions

	flags

	operation

	meta


sal=Arithmetically shifts bits to the left
sar=Arithmetically shifts bits to the right
shl=Logically shifts bits to the left
shr=Logically shifts bits to the right
	forms

	description
		Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the
		second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF
		flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination operand.
		
		The destination operand can be a register or a memory location. The count operand can be an immediate value or
		the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is
		limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used). A special opcode encoding is provided for a count of 1.
		
		The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the
		bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most
		significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared.
		The shift arithmetic right (SAR) and shift logical right (SHR) instructions shift the bits of the destination operand to
		the right (toward less significant bit locations). For each shift count, the least significant bit of the destination
		operand is shifted into the CF flag, and the most significant bit is either set or cleared depending on the instruction
		type. The SHR instruction clears the most significant bit; the SAR instruction sets or clears the most significant bit to correspond
		to the sign (most significant bit) of the original value in the destination operand. In effect, the SAR instruction fills
		the empty bit position's shifted value with the sign of the unshifted value.
		
		The SAR and SHR instructions can be used to perform signed or unsigned division, respectively, of the destination
		operand by powers of 2. For example, using the SAR instruction to shift a signed integer 1 bit to the right divides the value by 2.
		Using the SAR instruction to perform a division operation does not produce the same result as the IDIV instruction.
		The quotient from the IDIV instruction is rounded toward zero, whereas the "quotient" of the SAR instruction is
		rounded toward negative infinity. This difference is apparent only for negative numbers. For example, when the
		IDIV instruction is used to divide -9 by 4, the result is -2 with a remainder of -1. If the SAR instruction is used to
		shift -9 right by two bits, the result is -3 and the "remainder" is +3; however, the SAR instruction stores only the
		most significant bit of the remainder (in the CF flag).
		
		The OF flag is affected only on 1-bit shifts. For left shifts, the OF flag is set to 0 if the most-significant bit of the
		result is the same as the CF flag (that is, the top two bits of the original operand were the same); otherwise, it is
		set to 1. For the SAR instruction, the OF flag is cleared for all 1-bit shifts. For the SHR instruction, the OF flag is set
		to the most-significant bit of the original operand.
		
		In 64-bit mode, the instruction's default operation size is 32 bits and the mask width for CL is 5 bits. Using a REX
		prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W
		promotes operation to 64-bits and sets the mask width for CL to 6 bits. See the summary chart at the beginning of
		this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


sarx=Arithmetically shift right without affecting flags
shlx=Logically shift left without affecting flags
shrx=Logically shift right without affecting flags
	forms

	description
		Shifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in the third operand.
		The result is written to the the first operand.
		
		The shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand
		to the right (toward less significant bit locations), SARX keeps and propagates the most significant bit (sign bit)
		while shifting.
		
		The logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit locations).
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.
		
		If the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.
		SARX, SHRX, and SHLX instructions do not update flags.

	exceptions

	flags

	operation

	meta


sbb=Integer Subtraction with Borrow 
	forms

	description
		Adds the source operand (second operand) and the carry (CF) flag, and subtracts the result from the destination
		operand (first operand). The result of the subtraction is stored in the destination operand. The destination operand
		can be a register or a memory location; the source operand can be an immediate, a register, or a memory location.
		(However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a borrow
		from a previous subtraction.
		
		When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.
		
		The SBB instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates
		the result for both data types and sets the OF and CF flags to indicate a borrow in the signed or unsigned result,
		respectively. The SF flag indicates the sign of the signed result.
		
		The SBB instruction is usually executed as part of a multibyte or multiword subtraction in which a SUB instruction
		is followed by a SBB instruction.
		
		This instruction can be used with a @ref(lock) prefix to allow the instruction to be executed atomically.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
		the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


scas/scasb/scasw/scasd=Scan String 
	forms

	description
		In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword
		specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording
		the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute
		of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.
		
		At the assembly-code level, two forms of this instruction are allowed. The explicit-operand form and the no-oper-
		ands form. The explicit-operand form (specified using the SCAS mnemonic) allows a memory operand to be spec-
		ified explicitly. The memory operand must be a symbol that indicates the size and location of the operand value.
		The register operand is then automatically selected to match the size of the memory operand (AL register for byte
		comparisons, AX for word comparisons, EAX for doubleword comparisons). The explicit-operand form is provided
		to allow documentation. Note that the documentation provided by this form can be misleading. That is, the
		memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword) but it
		does not have to specify the correct location. The location is always specified by ES:(E)DI.
		
		The no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI is assumed to be the memory
		operand and AL, AX, or EAX is assumed to be the register operand. The size of operands is selected by the
		mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).
		
		After the comparison, the (E)DI register is incremented or decremented automatically according to the setting of
		the DF flag in the EFLAGS register. If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI
		register is decremented. The register is incremented or decremented by 1 for byte operations, by 2 for word oper-
		ations, and by 4 for doubleword operations.
		
		SCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the @ref(rep) prefix for block comparisons of ECX bytes,
		words, doublewords, or quadwords. Often, however, these instructions will be used in a LOOP construct that takes
		some action based on the setting of status flags. See @ref(rep) for a description of the REP prefix.
		
		In 64-bit mode, the instruction's default address size is 64-bits, 32-bit address size is supported using the prefix
		67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The 64-bit no-
		operand mnemonic is SCASQ. Address of the memory operand is specified in either RDI or EDI, and
		AL/AX/EAX/RAX may be used as the register operand. After a comparison, the destination register is incremented
		or decremented by the current operand size (depending on the value of the DF flag). See the summary chart at the
		beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


setcc=Set Byte on Condition 
	forms

	description
		Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
		EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
		(cc) indicates the condition being tested for.
		
		The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
		integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
		between two signed integer values.
		
		Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
		SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
		OF. These alternate mnemonics are provided to make code more intelligible. @see(flags) shows the alternate
		mnemonics for various test conditions.
		
		Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
		choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
		test for overflow, use the SETNO instruction, then decrement the result.
		
		In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte
		registers. Otherwise, this instruction's operation is the same as in legacy mode and compatibility mode.

	exceptions

	flags

	operation

	meta
		see
			flags => Appendix B - "EFLAGS Condition Codes,", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


sfence=Store Fence
	forms

	description
		Performs a serializing operation on all store-to-memory instructions that were issued prior the SFENCE instruction.
		This serializing operation guarantees that every store instruction that precedes the SFENCE instruction in program
		order becomes globally visible before any store instruction that follows the SFENCE instruction. The SFENCE
		instruction is ordered with respect to store instructions, other SFENCE instructions, any @ref(lfence) and @ref(mfence)
		instructions, and any serializing instructions (such as the @ref(cpuid) instruction). It is not ordered with respect to load
		instructions.
		
		Weakly ordered memory types can be used to achieve higher processor performance through such techniques as
		out-of-order issue, write-combining, and write-collapsing. The degree to which a consumer of data recognizes or
		knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data.
		The SFENCE instruction provides a performance-efficient way of ensuring store ordering between routines that
		produce weakly-ordered results and routines that consume this data.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.
		
		Specification of the instruction's opcode above indicates a ModR/M byte of F8. For this instruction, the processor
		ignores the r/m field of the ModR/M byte. Thus, SFENCE is encoded by any opcode of the form 0F AE Fx, where x is
		in the range 8-F.

	exceptions

	flags

	operation

	meta


sgdt=Store Global Descriptor Table Register
	forms

	description
		Stores the content of the global descriptor table register (GDTR) in the destination operand. The destination
		operand specifies a memory location.
		
		In legacy or compatibility mode, the destination operand is a 6-byte memory location. If the operand-size attribute
		is 16 bits, the limit is stored in the low 2 bytes and the 24-bit base address is stored in bytes 3-5, and byte 6 is
		zero-filled. If the operand-size attribute is 32 bits, the 16-bit limit field of the register is stored in the low 2 bytes
		of the memory location and the 32-bit base address is stored in the high 4 bytes.
		
		In IA-32e mode, the operand size is fixed at 8+2 bytes. The instruction stores an 8-byte base and a 2-byte limit.
		
		SGDT is useful only by operating-system software. However, it can be used in application programs without causing
		an exception to be generated.
		
		See @ref(lgdt) for information on loading the GDTR and IDTR.

	exceptions

	flags

	operation

	meta


shld=Double Precision Shift Left
	forms

	description
		The SHLD instruction is used for multi-precision shifts of 64 bits or more.
		The instruction shifts the first operand (destination operand) to the left the number of bits specified by the third
		operand (count operand). The second operand (source operand) provides bits to shift in from the right (starting
		with bit 0 of the destination operand).
		
		The destination operand can be a register or a memory location; the source operand is a register. The count
		operand is an unsigned integer that can be stored in an immediate byte or in the CL register. If the count operand
		is CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode; only
		bits 0 through 4 of the count are used. This masks the count to a value between 0 and 31. If a count is greater than
		the operand size, the result is undefined.
		
		If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit
		shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not affected.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits
		(upgrading the count mask to 6 bits).

	exceptions

	flags

	operation

	meta


shrd=Double Precision Shift Right 
	forms

	description
		The SHRD instruction is useful for multi-precision shifts of 64 bits or more.
		The instruction shifts the first operand (destination operand) to the right the number of bits specified by the third
		operand (count operand). The second operand (source operand) provides bits to shift in from the left (starting with
		the most significant bit of the destination operand).
		
		The destination operand can be a register or a memory location; the source operand is a register. The count
		operand is an unsigned integer that can be stored in an immediate byte or the CL register. If the count operand is
		CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode, the
		width of the count mask is 5 bits. Only bits 0 through 4 of the count register are used (masking the count to a value
		between 0 and 31). If the count is greater than the operand size, the result is undefined.
		
		If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit
		shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not affected.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits
		(upgrading the count mask to 6 bits). 

	exceptions

	flags

	operation

	meta


shufpd/vshufpd=Shuffle Packed Double-Precision Floating-Point Values 
	forms

	description
		Moves either of the two packed double-precision floating-point values from destination operand (first operand) into
		the low quadword of the destination operand; moves either of the two packed double-precision floating-point
		values from the source operand into to the high quadword of the destination operand. The select
		operand (third operand) determines which values are moved to the destination operand.
		
		The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM
		register. The select operand is an 8-bit immediate: bit 0 selects which value is moved from the destination operand
		to the result (where 0 selects the low quadword and 1 selects the high quadword) and bit 1 selects which value is
		moved from the source operand to the result. Bits 2 through 7 of the select operand are reserved and must be set
		to 0.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The source can be an XMM register or an 128-bit memory location. The destination is
		not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM
		register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


shufps/vshufps=Shuffle Packed Single-Precision Floating-Point Values 
	forms

	description
		Moves two of the four packed single-precision floating-point values from the destination operand (first operand)
		into the low quadword of the destination operand; moves two of the four packed single-precision floating-point
		values from the source operand (second operand) into to the high quadword of the destination operand.
		The select operand (third operand) determines which values are moved to the destination operand.
		
		The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM
		register. The select operand is an 8-bit immediate: bits 0 and 1 select the value to be moved from the destination
		operand to the low doubleword of the result, bits 2 and 3 select the value to be moved from the destination operand
		to the second doubleword of the result, bits 4 and 5 select the value to be moved from the source operand to the
		third doubleword of the result, and bits 6 and 7 select the value to be moved from the source operand to the high
		doubleword of the result.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source can be an XMM register or an 128-bit memory location. The destination is
		not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM
		register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


sidt=Store Interrupt Descriptor Table Register 
	forms

	description
		Stores the content the interrupt descriptor table register (IDTR) in the destination operand. The destination
		operand specifies a 6-byte memory location.
		
		In non-64-bit modes, if the operand-size attribute is 32 bits, the 16-bit limit field of the register is stored in the low
		2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes. If the operand-size attri-
		bute is 16 bits, the limit is stored in the low 2 bytes and the 24-bit base address is stored in the third, fourth, and
		fifth byte, with the sixth byte filled with 0s.
		
		In 64-bit mode, the operand size fixed at 8+2 bytes. The instruction stores 8-byte base and 2-byte limit values.
		SIDT is only useful in operating-system software; however, it can be used in application programs without causing
		an exception to be generated. See @ref(lidt) for information on loading the GDTR.
		and IDTR.

	exceptions

	flags

	operation

	meta


sldt=Store Local Descriptor Table Register
	forms

	description
		Stores the segment selector from the local descriptor table register (LDTR) in the destination operand. The desti-
		nation operand can be a general-purpose register or a memory location. The segment selector stored with this
		instruction points to the segment descriptor (located in the GDT) for the current LDT. This instruction can only be
		executed in protected mode.
		
		Outside IA-32e mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into
		the low-order 16 bits of the register. The high-order 16 bits of the register are cleared for the Pentium 4, Intel Xeon,
		and P6 family processors. They are undefined for Pentium, Intel486, and Intel386 processors. When the destina-
		tion operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size.
		
		In compatibility mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into
		the low-order 16 bits of the register. The high-order 16 bits of the register are cleared. When the destination
		operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). The
		behavior of SLDT with a 64-bit register is to zero-extend the 16-bit selector and store it in the register. If the desti-
		nation is memory and operand size is 64, SLDT will write the 16-bit selector to memory as a 16-bit quantity,
		regardless of the operand size.

	exceptions

	flags

	operation

	meta


smsw=Store Machine Status Word 
	forms

	description
		Stores the machine status word (bits 0 through 15 of control register CR0) into the destination operand. The desti-
		nation operand can be a general-purpose register or a memory location.
		
		In non-64-bit modes, when the destination operand is a 32-bit register, the low-order 16 bits of register CR0 are
		copied into the low-order 16 bits of the register and the high-order 16 bits are undefined. When the destination
		operand is a memory location, the low-order 16 bits of register CR0 are written to memory as a 16-bit quantity,
		regardless of the operand size.
		
		In 64-bit mode, the behavior of the SMSW instruction is defined by the following examples:
		- SMSW r16 operand size 16, store CR0[15:0] in r16
		- SMSW r32 operand size 32, zero-extend CR0[31:0], and store in r32
		- SMSW r64 operand size 64, zero-extend CR0[63:0], and store in r64
		- SMSW m16 operand size 16, store CR0[15:0] in m16
		- SMSW m16 operand size 32, store CR0[15:0] in m16 (not m32)
		- SMSW m16 operands size 64, store CR0[15:0] in m16 (not m64)
		
		SMSW is only useful in operating-system software. However, it is not a privileged instruction and can be used in
		application programs. The is provided for compatibility with the Intel 286 processor. Programs and procedures
		intended to run on the Pentium 4, Intel Xeon, P6 family, Pentium, Intel486, and Intel386 processors should use the
		@ref(mov) (control registers) instruction to load the machine status word.

	exceptions

	flags

	operation

	meta


sqrtpd/vsqrtpd=Compute Square Roots of Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


sqrtps/vsqrtps=Compute Square Roots of Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


sqrtsd/vsqrtsd=Compute Square Root of Scalar Double-Precision Floating-Point Value
	forms

	description

	exceptions

	flags

	operation

	meta


sqrtss/vsqrtss=Compute Square Root of Scalar Single-Precision Floating-Point Value
	forms

	description

	exceptions

	flags

	operation

	meta


stac=Set AC Flag in EFLAGS Register 
	forms

	description

	exceptions

	flags

	operation

	meta


stc=Set Carry Flag 
	forms

	description

	exceptions

	flags

	operation

	meta


std=Set Direction Flag
	forms

	description

	exceptions

	flags

	operation

	meta


sti=Set Interrupt Flag
	forms

	description

	exceptions

	flags

	operation

	meta


stmxcsr=Store MXCSR Register State 
	forms

	description

	exceptions

	flags

	operation

	meta


stos/stosb/stosw/stosd/stosq=Store String 
	forms

	description

	exceptions

	flags

	operation

	meta


str=Store Task Register
	forms

	description

	exceptions

	flags

	operation

	meta


sub=Subtract 
	forms

	description

	exceptions

	flags

	operation

	meta


subpd=Subtract Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


subps=Subtract Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


subsd=Subtract Scalar Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


subss=Subtract Scalar Single-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


swapgs=Swap GS Base Register 
	forms

	description

	exceptions

	flags

	operation

	meta


syscall=Fast System Call 
	forms

	description

	exceptions

	flags

	operation

	meta


sysenter=Fast System Call
	forms

	description

	exceptions

	flags

	operation

	meta


sysexit=Fast Return from Fast System Call 
	forms

	description

	exceptions

	flags

	operation

	meta


sysret=Return From Fast System Call 
	forms

	description

	exceptions

	flags

	operation

	meta


test=Logical Compare 
	forms

	description

	exceptions

	flags

	operation

	meta


tzcnt=Count the Number of Trailing Zero Bits 
	forms

	description

	exceptions

	flags

	operation

	meta


ucomisd=Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS 
	forms

	description

	exceptions

	flags

	operation

	meta


ucomiss=Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS 
	forms

	description

	exceptions

	flags

	operation

	meta


ud2=Undefined Instruction
	forms

	description

	exceptions

	flags

	operation

	meta


unpckhpd=Unpack and Interleave High Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


unpckhps=Unpack and Interleave High Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


unpcklpd=Unpack and Interleave Low Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


unpcklps=Unpack and Interleave Low Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vbroadcast=Broadcast Floating-Point Data 
	forms

	description

	exceptions

	flags

	operation

	meta


vcvtph2ps=Convert 16-bit FP Values to Single-Precision FP Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vcvtps2ph=Convert Single-Precision FP value to 16-bit FP value 
	forms

	description

	exceptions

	flags

	operation

	meta


verr/verw=Verify a Segment for Reading or Writing 
	forms

	description

	exceptions

	flags

	operation

	meta


vextractf128=Extract Packed Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vextracti128=Extract packed Integer Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmadd132pd/vfnmadd213pd/vfnmadd231pd=Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmadd132ps/vfnmadd213ps/vfnmadd231ps=Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmadd132sd/vfnmadd213sd/vfnmadd231sd=Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmadd132ss/vfnmadd213ss/vfnmadd231ss=Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmsub132pd/vfnmsub213pd/vfnmsub231pd=Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmsub132ps/vfnmsub213ps/vfnmsub231ps=Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmsub132sd/vfnmsub213sd/vfnmsub231sd=Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmsub132ss/vfnmsub213ss/vfnmsub231ss=Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vgatherdpd=Gather Packed DP FP Values Using Signed Dword Indices
vgatherqpd=Gather Packed DP FP Values Using Signed Qword Indices
	forms

	description

	exceptions

	flags

	operation

	meta


vgatherdps=Gather Packed SP FP values Using Signed Dword Indices
vgatherqps=Gather Packed SP FP values Using Signed Qword Indices
	forms

	description

	exceptions

	flags

	operation

	meta


vpgatherdd=Gather Packed Dword Values Using Signed Dword Indices 
vpgatherqd=Gather Packed Dword Values Using Signed Qword Indices 
	forms

	description

	exceptions

	flags

	operation

	meta


vpgatherdq=Gather Packed Qword Values Using Signed Dword Indices
vpgatherqq=Gather Packed Qword Values Using Signed Qword Indices 
	forms

	description

	exceptions

	flags

	operation

	meta


vinsertf128=Insert Packed Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


vinserti128=Insert Packed Integer Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vmaskmov=Conditional SIMD Packed Loads and Stores 
	forms

	description

	exceptions

	flags

	operation

	meta


vpblendd=Blend Packed Dwords 
	forms

	description

	exceptions

	flags

	operation

	meta


vpbroadcast=Broadcast Integer Data
	forms

	description

	exceptions

	flags

	operation

	meta


vpermd=Full Doublewords Element Permutation
	forms

	description

	exceptions

	flags

	operation

	meta


vpermpd=Permute Double-Precision Floating-Point Elements 
	forms

	description

	exceptions

	flags

	operation

	meta


vpermps=Permute Single-Precision Floating-Point Elements 
	forms

	description

	exceptions

	flags

	operation

	meta


vpermq=Qwords Element Permutation 
	forms

	description

	exceptions

	flags

	operation

	meta


vperm2i128=Permute Integer Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vpermilpd=Permute Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vpermilps=Permute Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vperm2f128=Permute Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


vpmaskmov=Conditional SIMD Integer Packed Loads and Stores 
	forms

	description

	exceptions

	flags

	operation

	meta


vpsllvd/vpsllvq=Variable Bit Shift Left Logical
	forms

	description

	exceptions

	flags

	operation

	meta


vpsravd=Variable Bit Shift Right Arithmetic 
	forms

	description

	exceptions

	flags

	operation

	meta


vpsrlvd/vpsrlvq=Variable Bit Shift Right Logical 
	forms

	description

	exceptions

	flags

	operation

	meta


vtestpd/vtestps=Packed Bit Test
	forms

	description

	exceptions

	flags

	operation

	meta


vzeroall=Zero All YMM Registers 
	forms

	description

	exceptions

	flags

	operation

	meta


vzeroupper=Zero Upper Bits of YMM Registers 
	forms

	description

	exceptions

	flags

	operation

	meta


wait/fwait=Wait 
	forms

	description

	exceptions

	flags

	operation

	meta


wbinvd=Write Back and Invalidate Cache 
	forms

	description

	exceptions

	flags

	operation

	meta


wrfsbase=Write FS Segment Base 
wrgsbase=Write GS Segment Base 
	forms

	description

	exceptions

	flags

	operation

	meta


wrmsr=Write to Model Specific Register 
	forms

	description

	exceptions

	flags

	operation

	meta


wrpkru=Write Data to User Page Key Register
	forms

	description

	exceptions

	flags

	operation

	meta


xacquire/xrelease=Hardware Lock Elision Prefix Hints 
	forms

	description

	exceptions

	flags

	operation

	meta


xabort=Transactional Abort 
	forms

	description

	exceptions

	flags

	operation

	meta


xadd=Exchange and Add 
	forms

	description

	exceptions

	flags

	operation

	meta


xbegin=Transactional Begin 
	forms

	description

	exceptions

	flags

	operation

	meta


xchg=Exchange Register/Memory with Register 
	forms

	description

	exceptions

	flags

	operation

	meta


xend=Transactional End 
	forms

	description

	exceptions

	flags

	operation

	meta


xgetbv=Get Value of Extended Control Register 
	forms

	description

	exceptions

	flags

	operation

	meta


xlat/xlatb=Table Look-up Translation 
	forms

	description

	exceptions

	flags

	operation

	meta


xor=Logical Exclusive OR 
	forms

	description

	exceptions

	flags

	operation

	meta


xorpd=Bitwise Logical XOR for Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


xorps=Bitwise Logical XOR for Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


xrstor=Restore Processor Extended States 
	forms

	description

	exceptions

	flags

	operation

	meta


xrstors=Restore Processor Extended States Supervisor 
	forms

	description

	exceptions

	flags

	operation

	meta


xsave=Save Processor Extended States 
	forms

	description

	exceptions

	flags

	operation

	meta


xsavec=Save Processor Extended States with Compaction
	forms

	description

	exceptions

	flags

	operation

	meta


xsaveopt=Save Processor Extended States Optimized 
	forms

	description

	exceptions

	flags

	operation

	meta


xsaves=Save Processor Extended States Supervisor 
	forms

	description

	exceptions

	flags

	operation

	meta


xsetbv=Set Extended Control Register 
	forms

	description

	exceptions

	flags

	operation

	meta


xtest=Test If In Transactional Execution
	forms

	description

	exceptions

	flags

	operation

	meta


