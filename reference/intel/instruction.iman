aaa=ASCII Adjust After Addition
	forms

	description
		Adjusts the sum of two unpacked BCD values to create an unpacked BCD result. The AL register is the implied
		source and destination operand for this instruction. The AAA instruction is only useful when it follows an ADD
		instruction that adds (binary addition) two unpacked BCD values and stores a byte result in the AL register. The
		AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.
		If the addition produces a decimal carry, the AH register increments by 1, and the CF and AF flags are set. If there
		was no decimal carry, the CF and AF flags are cleared and the AH register is unchanged. In either case, bits 4
		through 7 of the AL register are set to 0.
		
		This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


aad=ASCII Adjust AX Before Division 
	forms

	description
		Adjusts two unpacked BCD digits (the least-significant digit in the AL register and the most-significant digit in the
		AH register) so that a division operation performed on the result will yield a correct unpacked BCD value. The AAD
		instruction is only useful when it precedes a DIV instruction that divides (binary division) the adjusted value in the
		AX register by an unpacked BCD value.
		
		The AAD instruction sets the value in the AL register to (AL + (10 * AH)), and then clears the AH register to 00H.
		The value in the AX register is then equal to the binary equivalent of the original unpacked two-digit (base 10)
		number in registers AH and AL.
		
		The generalized version of this instruction allows adjustment of two unpacked digits of any number base (see the
		"Operation" section below), by setting the imm8 byte to the selected number base (for example, 08H for octal, 0AH
		for decimal, or 0CH for base 12 numbers). The AAD mnemonic is interpreted by all assemblers to mean adjust
		ASCII (base 10) values. To adjust values in another number base, the instruction must be hand coded in machine
		code (D5 imm8).
		
		This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


aam=ASCII Adjust AX After Multiply 
	forms

	description
		Adjusts the result of the multiplication of two unpacked BCD values to create a pair of unpacked (base 10) BCD
		values. The AX register is the implied source and destination operand for this instruction. The AAM instruction is
		only useful when it follows an MUL instruction that multiplies (binary multiplication) two unpacked BCD values and
		stores a word result in the AX register. The AAM instruction then adjusts the contents of the AX register to contain
		the correct 2-digit unpacked (base 10) BCD result.
		
		The generalized version of this instruction allows adjustment of the contents of the AX to create two unpacked
		digits of any number base (see the "Operation" section below). Here, the imm8 byte is set to the selected number
		base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAM mnemonic is interpreted
		by all assemblers to mean adjust to ASCII (base 10) values. To adjust to values in another number base, the
		instruction must be hand coded in machine code (D4 imm8).
		
		This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


aas=ASCII Adjust AL After Subtraction
	forms

	description
		Adjusts the result of the subtraction of two unpacked BCD values to create a unpacked BCD result. The AL register
		is the implied source and destination operand for this instruction. The AAS instruction is only useful when it follows
		a SUB instruction that subtracts (binary subtraction) one unpacked BCD value from another and stores a byte
		result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-
		digit unpacked BCD result
		
		If the subtraction produced a decimal carry, the AH register decrements by 1, and the CF and AF flags are set. If no
		decimal carry occurred, the CF and AF flags are cleared, and the AH register is unchanged. In either case, the AL
		register is left with its top four bits set to 0.
		
		This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


adc=Add with Carry 
	forms

	description
		Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and
		stores the result in the destination operand. The destination operand can be a register or a memory location; the
		source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be
		used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate
		value is used as an operand, it is sign-extended to the length of the destination operand format.
		The ADC instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates
		the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result,
		respectively. The SF flag indicates the sign of the signed result.
		
		The ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is
		followed by an ADC instruction.
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
		the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


adcx=Unsigned Integer Addition of Two Operands with Carry Flag
	forms

	description
		Performs an unsigned addition of the destination operand (first operand), the source operand (second operand)
		and the carry-flag (CF) and stores the result in the destination operand. The destination operand is a general-
		purpose register, whereas the source operand can be a general-purpose register or memory location. The state of
		CF can represent a carry from a previous addition. The instruction sets the CF flag with the carry generated by the
		unsigned addition of the operands.
		
		The ADCX instruction is executed in the context of multi-precision addition, where we add a series of operands with
		a carry-chain. At the beginning of a chain of additions, we need to make sure the CF is in a desired initial state.
		Often, this initial state needs to be 0, which can be achieved with an instruction to zero the CF (e.g. XOR).
		This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.
		
		In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional
		registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64 bits. 
		ADCX executes normally either inside or outside a transaction region.
		
		Note: ADCX defines the OF flag differently than the ADD/ADC instructions

	exceptions

	flags

	operation

	meta


add=Add 
	forms

	description
		Adds the destination operand (first operand) and the source operand (second operand) and then stores the result
		in the destination operand. The destination operand can be a register or a memory location; the source operand
		can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one
		instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination
		operand format.
		
		The ADD instruction performs integer addition. It evaluates the result for both signed and unsigned integer oper-
		ands and sets the OF and CF flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The
		SF flag indicates the sign of the signed result.
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX a REX prefix in the form of REX.W promotes operation to 64 bits. 

	exceptions

	flags

	operation

	meta


addpd/vaddpd=Add Packed Double-Precision Floating-Point Values 
	forms

	description
		Performs a SIMD add of the two packed double-precision floating-point values from the source operand (second
		operand) and the destination operand (first operand), and stores the packed double-precision floating-point results
		in the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


addps/vaddps=Add Packed Single-Precision Floating-Point Values 
	forms

	description
		Performs a SIMD add of the four packed single-precision floating-point values from the source operand (second
		operand) and the destination operand (first operand), and stores the packed single-precision floating-point results
		in the destination operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


addsd/vaddsd=Add Scalar Double-Precision Floating-Point Values 
	forms

	description
		Adds the low double-precision floating-point values from the source operand (second operand) and the destination
		operand (first operand), and stores the double-precision floating-point result in the destination operand.
		The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.
		VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


addss/vaddss=Add Scalar Single-Precision Floating-Point Values 
	forms

	description
		Adds the low single-precision floating-point values from the source operand (second operand) and the destination
		operand (first operand), and stores the single-precision floating-point result in the destination operand.
		The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:32) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


addsubpd/vaddsubpd=Packed Double-FP Add/Subtract 
	forms

	description
		Adds odd-numbered double-precision floating-point values of the first source operand (second operand) with the
		corresponding double-precision floating-point values from the second source operand (third operand); stores the
		result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered
		double-precision floating-point values from the second source operand from the corresponding double-precision
		floating values in the first source operand; stores the result into the even-numbered values of the destination
		operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination 
		is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


addsubps/vaddsubps=Packed Single-FP Add/Subtract 
	forms

	description
		Adds odd-numbered single-precision floating-point values of the first source operand (second operand) with the
		corresponding single-precision floating-point values from the second source operand (third operand); stores the
		result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered
		single-precision floating-point values from the second source operand from the corresponding single-precision
		floating values in the first source operand; stores the result into the even-numbered values of the destination
		operand.
		
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified. See Figure 3-4.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


adox=Unsigned Integer Addition of Two Operands with Overflow Flag
	forms

	description
		Performs an unsigned addition of the destination operand (first operand), the source operand (second operand)
		and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a general-
		purpose register, whereas the source operand can be a general-purpose register or memory location. The state of
		OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the
		unsigned addition of the operands.
		
		The ADOX instruction is executed in the context of multi-precision addition, where we add a series of operands with
		a carry-chain. At the beginning of a chain of additions, we execute an instruction to zero the OF (e.g. XOR).
		This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit
		mode.
		
		In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to addi-
		tional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64-bits.
		ADOX executes normally either inside or outside a transaction region.
		
		Note: ADOX defines the CF and OF flags differently than the ADD/ADC instructions

	exceptions

	flags

	operation

	meta


aesdec/vaesdec=Perform One Round of an AES Decryption Flow 
	forms

	description
		This instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, with the
		round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and
		store the result in the destination operand.
		Use the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDE-CLAST instruction.
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an
		XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-
		1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM
		register are zeroed.

	exceptions

	flags

	operation

	meta


aesdeclast/vaesdeclast=Perform Last Round of an AES Decryption Flow 
	forms

	description
		This instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, with the
		round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and
		store the result in the destination operand.
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an
		XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128)
		of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM
		register are zeroed.

	exceptions

	flags

	operation

	meta


aesenc/vaesenc=Perform One Round of an AES Encryption Flow 
	forms

	description
		This instruction performs a single round of an AES encryption flow using a round key from the second source
		operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand.
		Use the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENC-CLAST instruction.
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an
		XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-
		1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM
		register are zeroed.

	exceptions

	flags

	operation

	meta


aesenclast/vaesenclast=Perform Last Round of an AES Encryption Flow
	forms

	description
		This instruction performs the last round of an AES encryption flow using a round key from the second source
		operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand.
		
		128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an
		XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-
		1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM
		register are zeroed.

	exceptions

	flags

	operation

	meta


aesimc/vaesimc=Perform the AES InvMixColumn Transformation
	forms

	description
		Perform the InvMixColumns transformation on the source operand and store the result in the destination operand.
		The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.
		Note: the AESIMC instruction should be applied to the expanded AES round keys (except for the first and last round
		key) in order to prepare them for decryption using the "Equivalent Inverse Cipher" (defined in FIPS 197).
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


aeskeygenassist/vaeskeygenassist=AES Round Key Generation Assist
	forms

	description
		Assist in expanding the AES cipher key, by computing steps towards generating a round key for encryption, using
		128-bit data specified in the source operand and an 8-bit round constant specified as an immediate, store the
		result in the destination operand.
		The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.
		
		128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


and=Logical AND 
	forms

	description
		Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in
		the destination operand location. The source operand can be an immediate, a register, or a memory location; the
		destination operand can be a register or a memory location. (However, two memory operands cannot be used in
		one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1;
		otherwise, it is set to 0.
		
		This instruction can be used with a LOCK prefix to allow the it to be executed atomically.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


andn=Logical AND NOT 
	forms

	description
		Performs a bitwise logical AND of inverted second operand (the first source operand) with the third operand (the
		second source operand). The result is stored in the first operand (destination operand).
		
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


andpd/vandpd=Bitwise Logical AND of Packed Double-Precision Floating-Point Values 
	forms

	description
		Performs a bitwise logical AND of the two packed double-precision floating-point values from the source operand
		(second operand) and the destination operand (first operand), and stores the result in the destination operand.
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


andps/vandps=Bitwise Logical AND of Packed Single-Precision Floating-Point Values 
	forms

	description
		Performs a bitwise logical AND of the four or eight packed single-precision floating-point values from the first
		source operand and the second source operand, and stores the result in the destination operand.
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


andnpd/vandnpd=Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values 
	forms

	description
		Performs a bitwise logical AND NOT of the two or four packed double-precision floating-point values from the first
		source operand and the second source operand, and stores the result in the destination operand.
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


andnps/vandnps=Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values 
	forms

	description
		Inverts the bits of the four packed single-precision floating-point values in the destination operand (first operand),
		performs a bitwise logical AND of the four packed single-precision floating-point values in the source operand
		(second operand) and the temporary inverted result, and stores the result in the destination operand.
		In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
		(XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


arpl=Adjust RPL Field of Segment Selector 
	forms

	description
		Compares the RPL fields of two segment selectors. The first operand (the destination operand) contains one
		segment selector and the second operand (source operand) contains the other. (The RPL field is located in bits 0
		and 1 of each operand.) If the RPL field of the destination operand is less than the RPL field of the source operand,
		the ZF flag is set and the RPL field of the destination operand is increased to match that of the source operand.
		Otherwise, the ZF flag is cleared and no change is made to the destination operand. (The destination operand can
		be a word register or a memory location; the source operand must be a word register.)
		
		The ARPL instruction is provided for use by operating-system procedures (however, it can also be used by applica-
		tions). It is generally used to adjust the RPL of a segment selector that has been passed to the operating system
		by an application program to match the privilege level of the application program. Here the segment selector
		passed to the operating system is placed in the destination operand and segment selector for the application
		program's code segment is placed in the source operand. (The RPL field in the source operand represents the priv-
		ilege level of the application program.) Execution of the ARPL instruction then ensures that the RPL of the segment
		selector received by the operating system is no lower (does not have a higher privilege) than the privilege level of
		the application program (the segment selector for the application program's code segment can be read from the
		stack following a procedure call).
		
		This instruction executes as described in compatibility mode and legacy mode. It is not encodable in 64-bit mode.

	exceptions

	flags

	operation

	meta


blendpd/vblendpd=Blend Packed Double Precision Floating-Point Values
	forms

	description
		Double-precision floating-point values from the second source operand (third operand) are conditionally merged
		with values from the first source operand (second operand) and written to the destination operand (first operand).
		The immediate bits [3:0] determine whether the corresponding double-precision floating-point value in the desti-
		nation is copied from the second source or first source. If a bit in the mask, corresponding to a word, is "1", then
		the double-precision floating-point value in the second source operand is copied, else the value in the first source
		operand is copied.
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register. The second source operand is an XMM
		register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
		the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


bextr=Bit Field Extract 
	forms

	description
		Extracts contiguous bits from the first source operand (the second operand) using an index value and length value
		specified in the second source operand (the third operand). Bit 7:0 of the second source operand specifies the
		starting bit position of bit extraction. A START value exceeding the operand size will not extract any bits from the
		second source operand. Bit 15:8 of the second source operand specifies the maximum number of bits (LENGTH)
		beginning at the START position to extract. Only bit positions up to (OperandSize -1) of the first source operand are
		extracted. The extracted bits are written to the destination register, starting from the least significant bit. All higher
		order bits in the destination operand (starting at bit position LENGTH) are zeroed. The destination register is
		cleared if no bits are extracted.
		
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


blendps/vblendps=Blend Packed Single Precision Floating-Point Values
	forms

	description
		Packed single-precision floating-point values from the second source operand (third operand) are conditionally
		merged with values from the first source operand (second operand) and written to the destination operand (first
		operand). The immediate bits [7:0] determine whether the corresponding single precision floating-point value in
		the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is "1",
		then the single-precision floating-point value in the second source operand is copied, else the value in the first
		source operand is copied.
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: The first source operand an XMM register. The second source operand is an XMM register
		or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the
		corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


blendvpd/vblendvpd=Variable Blend Packed Double Precision Floating-Point Values
	forms

	description
		Conditionally copy each quadword data element of double-precision floating-point value from the second source
		operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits
		are the most significant bit in each quadword element of the mask register.
		
		Each quadword element of the destination operand is copied from:
		- the corresponding quadword element in the second source operand, If a mask bit is "1"; or
		- the corresponding quadword element in the first source operand, If a mask bit is "0"
		
		The register assignment of the implicit mask operand for BLENDVPD is defined to be the architectural register XMM0.
		128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (VLMAX-1:128)
		of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined
		to be the architectural register XMM0. An attempt to execute BLENDVPD with a VEX prefix will cause #UD.
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and
		encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
		ignored. The upper bits (VLMAX-1:128) of the corresponding YMM register (destination register) are zeroed.
		VEX.W must be 0, otherwise, the instruction will #UD.
		
		VEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source
		operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and
		encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
		ignored. VEX.W must be 0, otherwise, the instruction will #UD.
		
		VBLENDVPD permits the mask to be any XMM or YMM register. In contrast, BLENDVPD treats XMM0 implicitly as the
		mask and do not support non-destructive destination operation.

	exceptions

	flags

	operation

	meta


blendvps/vblendvps=Variable Blend Packed Single Precision Floating-Point Values 
	forms

	description
		Conditionally copy each dword data element of single-precision floating-point value from the second source
		operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits
		are the most significant bit in each dword element of the mask register.
		
		Each quadword element of the destination operand is copied from:
		- the corresponding dword element in the second source operand, If a mask bit is "1"; or
		- the corresponding dword element in the first source operand, If a mask bit is "0"
		
		The register assignment of the implicit mask operand for BLENDVPS is defined to be the architectural register XMM0.
		128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (VLMAX-1:128)
		of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined
		to be the architectural register XMM0. An attempt to execute BLENDVPS with a VEX prefix will cause #UD.
		VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
		source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and
		encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
		ignored. The upper bits (VLMAX-1:128) of the corresponding YMM register (destination register) are zeroed.
		VEX.W must be 0, otherwise, the instruction will #UD.
		
		VEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source
		operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and
		encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
		ignored. VEX.W must be 0, otherwise, the instruction will #UD.
		
		VBLENDVPS permits the mask to be any XMM or YMM register. In contrast, BLENDVPS treats XMM0 implicitly as the
		mask and do not support non-destructive destination operation.

	exceptions

	flags

	operation

	meta


blsi=Extract Lowest Set Isolated Bit 
	forms

	description
		Extracts the lowest set bit from the source operand and set the corresponding bit in the destination register. All
		other bits in the destination operand are zeroed. If no bits are set in the source operand, BLSI sets all the bits in
		the destination to 0 and sets ZF and CF.
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


blsmsk=Get Mask Up to Lowest Set Bit 
	forms

	description
		Sets all the lower bits of the destination operand to "1" up to and including lowest set bit (=1) in the source
		operand. If source operand is zero, BLSMSK sets all bits of the destination operand to 1 and also sets CF to 1.
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


blsr=Reset Lowest Set Bit 
	forms

	description
		Copies all bits from the source operand to the destination operand and resets (=0) the bit position in the destina-
		tion operand that corresponds to the lowest set bit of the source operand. If the source operand is zero BLSR sets CF.
		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


bound=Check Array Index Against Bounds 
	forms

	description
		BOUND determines if the first operand (array index) is within the bounds of an array specified the second operand
		(bounds operand). The array index is a signed integer located in a register. The bounds operand is a memory loca-
		tion that contains a pair of signed doubleword-integers (when the operand-size attribute is 32) or a pair of signed
		word-integers (when the operand-size attribute is 16). The first doubleword (or word) is the lower bound of the
		array and the second doubleword (or word) is the upper bound of the array. The array index must be greater than
		or equal to the lower bound and less than or equal to the upper bound plus the operand size in bytes. If the index
		is not within bounds, a BOUND range exceeded exception (#BR) is signaled. When this exception is generated, the
		saved return instruction pointer points to the BOUND instruction.
		
		The bounds limit data structure (two words or doublewords containing the lower and upper limits of the array) is
		usually placed just before the array itself, making the limits addressable via a constant offset from the beginning of
		the array. Because the address of the array already will be present in a register, this practice avoids extra bus cycles
		to obtain the effective address of the array bounds.
		
		This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


bsf=Bit Scan Forward 
	forms

	description
		Searches the source operand (second operand) for the least significant set bit (1 bit). If a least significant 1 bit is
		found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a
		memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source
		operand. If the content of the source operand is 0, the content of the destination operand is undefined.
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


bsr=Bit Scan Reverse 
	forms

	description
		Searches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is
		found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a
		memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source
		operand. If the content source operand is 0, the content of the destination operand is undefined.
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


bswap=Byte Swap 
	forms

	description
		Reverses the byte order of a 32-bit or 64-bit (destination) register. This instruction is provided for converting little-
		endian values to big-endian format and vice versa. To swap bytes in a word value (16-bit register), use the XCHG
		instruction. When the BSWAP instruction references a 16-bit register, the result is undefined.
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
		the summary chart at the beginning of this section for encoding data and limits.
		
		The BSWAP instruction is not supported on IA-32 processors earlier than the Intel 486 processor family. For
		compatibility with this instruction, software should include functionally equivalent code for execution on Intel
		processors earlier than the Intel486 processor family.


	exceptions

	flags

	operation

	meta


bt=Bit Test 
	forms

	description
		Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by
		the bit offset (specified by the second operand) and stores the value of the bit in the CF flag. The bit base operand
		can be a register or a memory location; the bit offset operand can be a register or an immediate value:
		
		- If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset
		operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit mode).
		
		- If the bit base operand specifies a memory location, the operand represents the address of the byte in memory
		that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be
		referenced by the offset operand depends on the operand size.
		
		Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-
		tion with the displacement field of the memory operand. In this case, the low-order 3 or 5 bits (3 for 16-bit oper-
		ands, 5 for 32-bit operands) of the immediate bit offset are stored in the immediate bit offset field, and the high-
		order bits are shifted and combined with the byte displacement in the addressing mode by the assembler. The
		processor will ignore the high order bits if they are not zero.
		When accessing a bit in memory, the processor may access 4 bytes starting from the memory address for a 32-bit
		operand size, using by the following relationship:
		
		Effective Address + (4 * (BitOffset DIV 32))
		
		Or, it may access 2 bytes starting from the memory address for a 16-bit operand, using this relationship:
		
		Effective Address + (2 * (BitOffset DIV 16))
		
		It may do so even when only a single byte needs to be accessed to reach the given bit. When using this bit
		addressing mechanism, software should avoid referencing areas of memory close to address space holes. In partic-
		ular, it should avoid references to memory-mapped I/O registers. Instead, software should use the MOV instruc-
		tions to load from or store to these addresses, and use the register form of these instructions to manipulate the data.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit oper-
		ands.

	exceptions

	flags

	operation

	meta


btc=Bit Test and Complement 
	forms

	description
		Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by
		the bit offset operand (second operand), stores the value of the bit in the CF flag, and complements the selected
		bit in the bit string. The bit base operand can be a register or a memory location; the bit offset operand can be a
		register or an immediate value:
		
		- If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset
		operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit
		mode). This allows any bit position to be selected.
		
		- If the bit base operand specifies a memory location, the operand represents the address of the byte in memory
		that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be
		referenced by the offset operand depends on the operand size.
		
		Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-
		tion with the displacement field of the memory operand.
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


btr=Bit Test and Reset
	forms

	description
		Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by
		the bit offset operand (second operand), stores the value of the bit in the CF flag, and clears the selected bit in the
		bit string to 0. The bit base operand can be a register or a memory location; the bit offset operand can be a register
		or an immediate value:
		
		- If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset
		operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit
		mode). This allows any bit position to be selected.
		
		- If the bit base operand specifies a memory location, the operand represents the address of the byte in memory
		that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be
		referenced by the offset operand depends on the operand size.
		
		Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-
		tion with the displacement field of the memory operand.
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


bts=Bit Test and Set 
	forms

	description
		Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by
		the bit offset operand (second operand), stores the value of the bit in the CF flag, and sets the selected bit in the
		bit string to 1. The bit base operand can be a register or a memory location; the bit offset operand can be a register
		or an immediate value:
		
		- If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset
		operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit
		mode). This allows any bit position to be selected.
		
		- If the bit base operand specifies a memory location, the operand represents the address of the byte in memory
		that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be
		referenced by the offset operand depends on the operand size.
		
		Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-
		tion with the displacement field of the memory operand.
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
		access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
		the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


bzhi=Zero High Bits Starting with Specified Bit Position 
	forms

	description
		BZHI copies the bits of the first source operand (the second operand) into the destination operand (the first
		operand) and clears the higher bits in the destination according to the INDEX value specified by the second source
		operand (the third operand). The INDEX is specified by bits 7:0 of the second source operand. The INDEX value is
		saturated at the value of OperandSize -1. CF is set, if the number contained in the 8 low bits of the third operand
		is greater than OperandSize -1.

		This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
		64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
		attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.

	exceptions

	flags

	operation

	meta


call=Call Procedure 
	forms

	description
		Saves procedure linking information on the stack and branches to the called procedure specified using the target
		operand. The target operand specifies the address of the first instruction in the called procedure. The operand can
		be an immediate value, a general-purpose register, or a memory location.
		This instruction can be used to execute four types of calls:
		
		- Near Call: a call to a procedure in the current code segment (the segment currently pointed to by the CS
		register), sometimes referred to as an intra-segment call.
		- Far Call: a call to a procedure located in a different segment than the current code segment, sometimes
		referred to as an inter-segment call.
		- Inter-privilege-level far call: a far call to a procedure in a segment at a different privilege level 
		than that of the currently executing program or procedure.
		- Task switch: a call to a procedure located in a different task.
		
		The latter two call types (inter-privilege-level call and task switch) can only be executed in protected mode. See
		"Calling Procedures Using Call and RET" in Chapter 6 of the Intel 64 and IA-32 Architectures Software Devel-
		oper's Manual, Volume 1, for additional information on near, far, and inter-privilege-level calls. See Chapter 7,
		"Task Management," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, for infor-
		mation on performing task switches with the CALL instruction.
		
		~Near Call
			When executing a near call, the processor pushes the value of the EIP register (which contains the offset
			of the instruction following the CALL instruction) on the stack (for use later as a return-instruction pointer). The
			processor then branches to the address in the current code segment specified by the target operand. The target
			operand specifies either an absolute offset in the code segment (an offset from the base of the code segment) or a
			relative offset (a signed displacement relative to the current value of the instruction pointer in the EIP register; this
			value points to the instruction following the CALL instruction). The CS register is not changed on near calls.
			For a near call absolute, an absolute offset is specified indirectly in a general-purpose register or a memory location
			(r/m16, r/m32, or r/m64). The operand-size attribute determines the size of the target operand (16, 32 or 64 bits).
			When in 64-bit mode, the operand size for near call (and all near branches) is forced to 64-bits. Absolute offsets
			are loaded directly into the EIP(RIP) register. If the operand size attribute is 16, the upper two bytes of the EIP
			register are cleared, resulting in a maximum instruction pointer size of 16 bits. When accessing an absolute offset
			indirectly using the stack pointer [ESP] as the base register, the base value used is the value of the ESP before the
			instruction executes.
			
			A relative offset (rel16 or rel32) is generally specified as a label in assembly code. But at the machine code level, it
			is encoded as a signed, 16- or 32-bit immediate value. This value is added to the value in the EIP(RIP) register. In
			64-bit mode the relative offset is always a 32-bit immediate value which is sign extended to 64-bits before it is
			added to the value in the RIP register for the target calculation. As with absolute offsets, the operand-size attribute
			determines the size of the target operand (16, 32, or 64 bits). In 64-bit mode the target operand will always be 64-
			bits because the operand size is forced to 64-bits for near branches.
		
		~Far Calls in Real-Address or Virtual-8086 Mode
			When executing a far call in real- address or virtual-8086 mode, the processor pushes the current value of both 
			the CS and EIP registers on the stack for use as a return-instruction pointer. 
			The processor then performs a "far branch" to the code segment and offset specified with the target
			operand for the called procedure. The target operand specifies an absolute far address either directly with a pointer
			(ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). With the pointer method, the
			segment and offset of the called procedure is encoded in the instruction using a 4-byte (16-bit operand size) or 6-
			byte (32-bit operand size) far address immediate. With the indirect method, the target operand specifies a memory
			location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The operand-size
			attribute determines the size of the offset (16 or 32 bits) in the far address. The far address is loaded directly into
			the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.
		
		~Far Calls in Protected Mode
			When the processor is operating in protected mode, the CALL instruction can be used to perform the following types of far calls:
			
			- Far call to the same privilege level
			- Far call to a different privilege level (inter-privilege level call)
			- Task switch (far call to another task)
			
			In protected mode, the processor always uses the segment selector part of the far address to access the corre-
			sponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access
			rights determine the type of call operation to be performed.
			
			If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is
			performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming,
			a general-protection exception is generated.) A far call to the same privilege level in protected mode is very similar
			to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either
			directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The
			operand- size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment
			selector and its descriptor are loaded into CS register; the offset from the instruction is loaded into the EIP register.
			A call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same
			privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making
			calls between 16-bit and 32-bit code segments.
			
			When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed
			through a call gate. The segment selector specified by the target operand identifies the call gate. The target
			operand can specify the call gate segment selector either directly with a pointer (ptr16:16 or ptr16:32) or indirectly
			with a memory location (m16:16 or m16:32). The processor obtains the segment selector for the new code
			segment and the new instruction pointer (offset) from the call gate descriptor. (The offset from the target operand
			is ignored when a call gate is used.)
			
			On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The
			segment selector for the new stack segment is specified in the TSS for the currently running task. The branch to
			the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a
			segment at the same privilege level, no stack switch occurs.) On the new stack, the processor pushes the segment
			selector and stack pointer for the calling procedure's stack, an optional set of parameters from the calling proce-
			dures stack, and the segment selector and instruction pointer for the calling procedure's code segment. (A value in
			the call gate descriptor determines how many parameters to copy to the new stack.) Finally, the processor
			branches to the address of the procedure being called within the new code segment.
			Executing a task switch with the CALL instruction is similar to executing a call through a call gate. The target
			operand specifies the segment selector of the task gate for the new task activated by the switch (the offset in the
			target operand is ignored). The task gate in turn points to the TSS for the new task, which contains the segment
			selectors for the task's code and stack segments. Note that the TSS also contains the EIP value for the next instruc-
			tion that was to be executed before the calling task was suspended. This instruction pointer value is loaded into the
			EIP register to re-start the calling task.
			
			The CALL instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of
			the task gate. See Chapter 7, "Task Management," in the Intel 64 and IA-32 Architectures Software Developer's
			Manual, Volume 3A, for information on the mechanics of a task switch.
			
			When you execute at task switch with a CALL instruction, the nested task flag (NT) is set in the EFLAGS register
			and the new TSS's previous task link field is loaded with the old task's TSS selector. Code is expected to suspend
			this nested task by executing an IRET instruction which, because the NT flag is set, automatically uses the previous
			task link to return to the calling task. (See "Task Linking" in Chapter 7 of the Intel 64 and IA-32 Architectures
			Software Developer's Manual, Volume 3A, for information on nested tasks.) Switching tasks with the CALL instruc-
			tion differs in this regard from JMP instruction. JMP does not set the NT flag and therefore does not expect an IRET
			instruction to suspend the task.
		
		~Mixing 16-Bit and 32-Bit Calls
			When making far calls between 16-bit and 32-bit code segments, use a call gate. If
			the far call is from a 32-bit code segment to a 16-bit code segment, the call should be made from the first 64
			KBytes of the 32-bit code segment. This is because the operand-size attribute of the instruction is set to 16, so only
			a 16-bit return address offset can be saved. Also, the call should be made using a 16-bit call gate so that 16-bit
			values can be pushed on the stack. See Chapter 21, "Mixing 16-Bit and 32-Bit Code," in the Intel 64 and IA-32
			Architectures Software Developer's Manual, Volume 3B, for more information.
		
		~Far Calls in Compatibility Mode
			When the processor is operating in compatibility mode, the CALL instruction can be
			used to perform the following types of far calls:
			
			- Far call to the same privilege level, remaining in compatibility mode
			- Far call to the same privilege level, transitioning to 64-bit mode
			- Far call to a different privilege level (inter-privilege level call), transitioning to 64-bit mode
			
			Note that a CALL instruction can not be used to cause a task switch in compatibility mode since task switches are
			not supported in IA-32e mode.

			In compatibility mode, the processor always uses the segment selector part of the far address to access the corre-
			sponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate) and access rights determine
			the type of call operation to be performed.
			
			If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is
			performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming,
			a general-protection exception is generated.) A far call to the same privilege level in compatibility mode is very
			similar to one carried out in protected mode. The target operand specifies an absolute far address either directly
			with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The operand-size
			attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its
			descriptor are loaded into CS register and the offset from the instruction is loaded into the EIP register. The differ-
			ence is that 64-bit mode may be entered. This specified by the L bit in the new code segment descriptor.
			
			Note that a 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code
			segment at the same privilege level. However, using this mechanism requires that the target code segment
			descriptor have the L bit set, causing an entry to 64-bit mode.
			When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed
			through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target
			operand can specify the call gate segment selector either directly with a pointer (ptr16:16 or ptr16:32) or indirectly
			with a memory location (m16:16 or m16:32). The processor obtains the segment selector for the new code
			segment and the new instruction pointer (offset) from the 16-byte call gate descriptor. (The offset from the target
			operand is ignored when a call gate is used.)
			
			On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The
			segment selector for the new stack segment is set to NULL. The new stack pointer is specified in the TSS for the
			currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using
			a call gate to perform a far call to a segment at the same privilege level, an implicit stack switch occurs as a result
			of entering 64-bit mode. The SS selector is unchanged, but stack segment accesses use a segment base of 0x0, the
			limit is ignored, and the default stack size is 64-bits. The full value of RSP is used for the offset, of which the upper
			32-bits are undefined.) On the new stack, the processor pushes the segment selector and stack pointer for the
			calling procedure's stack and the segment selector and instruction pointer for the calling procedure's code
			segment. (Parameter copy is not supported in IA-32e mode.) Finally, the processor branches to the address of the
			procedure being called within the new code segment.
		
		~Near/(Far) Calls in 64-bit Mode
			When the processor is operating in 64-bit mode, the CALL instruction can be used to perform the following types of far calls:
			
			- Far call to the same privilege level, transitioning to compatibility mode
			- Far call to the same privilege level, remaining in 64-bit mode
			- Far call to a different privilege level (inter-privilege level call), remaining in 64-bit mode
			
			Note that in this mode the CALL instruction can not be used to cause a task switch in 64-bit mode since task
			switches are not supported in IA-32e mode.
			
			In 64-bit mode, the processor always uses the segment selector part of the far address to access the corresponding
			descriptor in the GDT or LDT. The descriptor type (code segment, call gate) and access rights determine the type of
			call operation to be performed.
			
			If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is
			performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming,
			a general-protection exception is generated.) A far call to the same privilege level in 64-bit mode is very similar to
			one carried out in compatibility mode. The target operand specifies an absolute far address indirectly with a
			memory location (m16:16, m16:32 or m16:64). The form of CALL with a direct specification of absolute far
			address is not defined in 64-bit mode. The operand-size attribute determines the size of the offset (16, 32, or 64
			bits) in the far address. The new code segment selector and its descriptor are loaded into the CS register; the offset
			from the instruction is loaded into the EIP register. The new code segment may specify entry either into compati-
			bility or 64-bit mode, based on the L bit value.
			
			A 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the
			same privilege level. However, using this mechanism requires that the target code segment descriptor have the L-bit set.
			When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed
			through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target
			operand can only specify the call gate segment selector indirectly with a memory location (m16:16, m16:32 or
			m16:64). The processor obtains the segment selector for the new code segment and the new instruction pointer
			(offset) from the 16-byte call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)
			On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The
			segment selector for the new stack segment is set to NULL. The new stack pointer is specified in the TSS for the
			currently running task. The branch to the new code segment occurs after the stack switch.
			
			Note that when using a call gate to perform a far call to a segment at the same privilege level, an implicit stack
			switch occurs as a result of entering 64-bit mode. The SS selector is unchanged, but stack segment accesses use a
			segment base of 0x0, the limit is ignored, and the default stack size is 64-bits. (The full value of RSP is used for the offset.) 
			On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure's
			stack and the segment selector and instruction pointer for the calling procedure's code segment. (Parameter copy
			is not supported in IA-32e mode.) Finally, the processor branches to the address of the procedure being called
			within the new code segment.

	exceptions

	flags

	operation

	meta


cbw=Convert Byte to Word
cwde=Convert Word to Doubleword
cdqe=Convert Doubleword to Quadword
	forms

	description
		Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction
		copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-
		word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.
		CBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attri-
		bute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the
		operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the
		operand-size attribute to determine the size of values to be converted.
		
		In 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes
		this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit 31)
		of the doubleword in the EAX register into the high 32 bits of RAX.

	exceptions

	flags

	operation

	meta


clac=Clear AC Flag in EFLAGS Register 
	forms

	description
		Clears the AC flag bit in EFLAGS register. This disables any alignment checking of user-mode data accesses. If the
		SMAP bit is set in the CR4 register, this disallows explicit supervisor-mode data accesses to user-mode pages.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute CLAC when CPL > 0 cause #UD.

	exceptions

	flags

	operation

	meta


clc=Clear Carry Flag 
	forms

	description
		Clears the CF flag in the EFLAGS register. Operation is the same in all modes.

	exceptions

	flags

	operation

	meta


cld=Clear Direction Flag 
	forms

	description
		Clears the DF flag in the EFLAGS register. When the DF flag is set to 0, string operations increment the index registers (ESI and/or EDI). 
		Operation is the same in all modes.

	exceptions

	flags

	operation

	meta


clflush=Flush Cache Line 
	forms

	description
		Invalidates the cache line that contains the linear address specified with the source operand from all levels of the
		processor cache hierarchy (data and instruction). The invalidation is broadcast throughout the cache coherence
		domain. If, at any level of the cache hierarchy, the line is inconsistent with memory (dirty) it is written to memory
		before invalidation. The source operand is a byte memory location.
		
		The availability of CLFLUSH is indicated by the presence of the CPUID feature flag CLFSH (bit 19 of the EDX register,
		see "CPUID-CPU Identification" in this chapter). The aligned cache line size affected is also indicated with the
		CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).
		The memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It
		should be noted that processors are free to speculatively fetch and cache data from system memory regions
		assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh
		instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative
		fetching can occur at any time and is not tied to instruction execution, the CLFLUSH instruction is not ordered with
		respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be specula-
		tively loaded into a cache line just before, during, or after the execution of a CLFLUSH instruction that references
		the cache line).
		
		CLFLUSH is only ordered by the MFENCE instruction. It is not guaranteed to be ordered by any other fencing or seri-
		alizing instructions or by another CLFLUSH instruction. For example, software can use an MFENCE instruction to
		ensure that previous stores are included in the write-back.
		
		The CLFLUSH instruction can be used at all privilege levels and is subject to all permission checking and faults asso-
		ciated with a byte load (and in addition, a CLFLUSH instruction is allowed to flush a linear address in an execute-only segment). 
		Like a load, the CLFLUSH instruction sets the A bit but not the D bit in the page tables.
		The CLFLUSH instruction was introduced with the SSE2 extensions; however, because it has its own CPUID feature
		flag, it can be implemented in IA-32 processors that do not include the SSE2 extensions. Also, detecting the presence 
		of the SSE2 extensions with the CPUID instruction does not guarantee that the CLFLUSH instruction is implemented in the processor.
		
		CLFLUSH operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


cli=Clear Interrupt Flag 
	forms

	description
		If protected-mode virtual interrupts are not enabled, CLI clears the IF flag in the EFLAGS register. No other flags
		are affected. Clearing the IF flag causes the processor to ignore maskable external interrupts. The IF flag and the
		CLI and STI instruction have no affect on the generation of exceptions and NMI interrupts.
		
		When protected-mode virtual interrupts are enabled, CPL is 3, and IOPL is less than 3; CLI clears the VIF flag in the
		EFLAGS register, leaving IF unaffected. Table 3-6 indicates the action of the CLI instruction depending on the
		processor operating mode and the CPL/IOPL of the running program or procedure.
		
		Operation is the same in all modes.

	exceptions

	flags

	operation

	meta


clts=Clear Task-Switched Flag in CR0 
	forms

	description
		Clears the task-switched (TS) flag in the CR0 register. This instruction is intended for use in operating-system
		procedures. It is a privileged instruction that can only be executed at a CPL of 0. It is allowed to be executed in real-
		address mode to allow initialization for protected mode.
		
		The processor sets the TS flag every time a task switch occurs. The flag is used to synchronize the saving of FPU
		context in multitasking applications. See the description of the TS flag in the section titled "Control Registers" in
		Chapter 2 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, for more information
		about this flag.
		
		CLTS operation is the same in non-64-bit modes and 64-bit mode.
		
		See Chapter 25, "VMX Non-Root Operation," of the Intel 64 and IA-32 Architectures Software Developer's
		Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.

	exceptions

	flags

	operation

	meta


cmc=Complement Carry Flag 
	forms

	description
		Complements the CF flag in the EFLAGS register. 
		CMC operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


cmovcc=Conditional Move 
	forms

	description
		The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
		and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
		associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
		is not performed and execution continues with the instruction following the CMOVcc instruction.
		
		These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
		general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
		The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
		and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for unsigned integers.
		
		Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
		defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
		(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
		
		The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
		supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
		the processor's feature information with the CPUID instruction.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional
		registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


cmp=Compare Two Operands 
	forms

	description
		Compares the first source operand with the second source operand and sets the status flags in the EFLAGS register
		according to the results. The comparison is performed by subtracting the second operand from the first operand
		and then setting the status flags in the same manner as the SUB instruction. When an immediate value is used as
		an operand, it is sign-extended to the length of the first operand.
		
		The condition codes used by the Jcc, CMOVcc, and SETcc instructions are based on the results of a CMP instruction.
		Appendix B, "EFLAGS Condition Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual,
		Volume 1, shows the relationship of the status flags and the condition codes.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
		tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


cmppd/vcmppd=Compare Packed Double-Precision Floating-Point Values 
	forms

	description
		Performs a SIMD compare of the packed double-precision floating-point values in the source operand (second
		operand) and the destination operand (first operand) and returns the results of the comparison to the destination
		operand. The comparison predicate operand (third operand) specifies the type of comparison performed on each of
		the pairs of packed values. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s
		(comparison false). The sign of zero is ignored for comparisons, so that -0.0 is equal to +0.0.
		
		128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The
		second source operand (second operand) can be an XMM register or 128-bit memory location. The comparison
		predicate operand is an 8-bit immediate, bits 2:0 of the immediate define the type of comparison to be performed.
		Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.
		Two comparisons are performed with results written to bits 127:0 of the destination operand.

	exceptions

	flags

	operation

	meta


cmpps/vcmpps=Compare Packed Single-Precision Floating-Point Values 
	forms

	description
		Performs a SIMD compare of the packed single-precision floating-point values in the source operand (second
		operand) and the destination operand (first operand) and returns the results of the comparison to the destination
		operand. The comparison predicate operand (third operand) specifies the type of comparison performed on each of
		the pairs of packed values. The result of each comparison is a doubleword mask of all 1s (comparison true) or all
		0s (comparison false). The sign of zero is ignored for comparisons, so that -0.0 is equal to +0.0.
		128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The
		second source operand (second operand) can be an XMM register or 128-bit memory location. The comparison
		predicate operand is an 8-bit immediate, bits 2:0 of the immediate define the type of comparison to be performed
		(see Table 3-7). Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:128) of the corresponding YMM destination
		register remain unchanged. Four comparisons are performed with results written to bits 127:0 of the destination operand.
		
		The unordered relationship is true when at least one of the two source operands being compared is a NaN; the
		ordered relationship is true when neither source operand is a NaN.
		A subsequent computational instruction that uses the mask result in the destination operand as an input operand
		will not generate a fault, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s
		corresponds to a QNaN.
		
		Note that processors with "CPUID.1H:ECX.AVX =0" do not implement the "greater-than", "greater-than-or-equal",
		"not-greater than", and "not-greater-than-or-equal relations" predicates. These comparisons can be made either
		by using the inverse relationship (that is, use the "not-less-than-or-equal" to make a "greater-than" comparison)
		or by using software emulation. When using software emulation, the program must swap the operands (copying
		registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate.
		
		Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand
		CMPPS instruction, for processors with "CPUID.1H:ECX.AVX =0". Compilers should treat reserved Imm8 values as illegal syntax.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cmps/cmpsb/cmpsw/cmpsd/cmpsq=Compare String Operands 
	forms

	description
		Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word,
		doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register
		according to the results.
		
		Both source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI
		or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the
		second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the
		instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.
		
		At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
		operands" form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands
		to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the
		source values. This explicit-operand form is provided to allow documentation. However, note that the documenta-
		tion provided by this form can be misleading. That is, the source operand symbols must specify the correct type
		(size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-
		tion. Locations of the source operands are always specified by the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) regis-
		ters, which must be loaded correctly before the compare string instruction is executed.
		
		The no-operands form provides "short forms" of the byte, word, and doubleword versions of the CMPS instructions.
		Here also the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers are assumed by the processor to specify the loca-
		tion of the source operands. The size of the source operands is selected with the mnemonic:
		
		CMPSB - byte comparison
		CMPSW - word comparison
		CMPSD - doubleword comparison
		CMPSQ - quadword comparison using REX.W
		
		After the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the
		setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E/R)SI and (E/R)DI register increment; if the
		DF flag is 1, the registers decrement.) The registers increment or decrement by 1 for byte operations, by 2 for word
		operations, 4 for doubleword operations. If operand size is 64, RSI and RDI registers increment by 8 for quadword operations.
		
		The CMPS, CMPSB, CMPSW, CMPSD, and CMPSQ instructions can be preceded by the REP prefix for block compar-
		isons. More often, however, these instructions will be used in a LOOP construct that takes some action based on the
		setting of the status flags before the next comparison is made. 
		
		In 64-bit mode, the instruction's default address size is 64 bits, 32 bit address size is supported using the prefix
		67H. Use of the REX.W prefix promotes doubleword operation to 64 bits (see CMPSQ).

	exceptions

	flags

	operation

	meta


cmpsd/vcmpsd=Compare Scalar Double-Precision Floating-Point Values 
	forms

	description
		Compares the low double-precision floating-point values in the source operand (second operand) and the destination
		operand (first operand) and returns the results of the comparison to the destination operand. The comparison
		predicate operand (third operand) specifies the type of comparison performed. The comparison result is a quad-
		word mask of all 1s (comparison true) or all 0s (comparison false). The sign of zero is ignored for comparisons, so
		that -0.0 is equal to +0.0.
		
		128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The
		second source operand (second operand) can be an XMM register or 64-bit memory location. The comparison pred-
		icate operand is an 8-bit immediate, bits 2:0 of the immediate define the type of comparison to be performed. 
		Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.
		
		The unordered relationship is true when at least one of the two source operands being compared is a NaN; the
		ordered relationship is true when neither source operand is a NaN.
		A subsequent computational instruction that uses the mask result in the destination operand as an input operand
		will not generate a fault, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s
		corresponds to a QNaN.
		
		Note that processors with "CPUID.1H:ECX.AVX = 0" do not implement the "greater-than", "greater-than-or-equal",
		"not-greater than", and "not-greater-than-or-equal relations" predicates. These comparisons can be made either
		by using the inverse relationship (that is, use the "not-less-than-or-equal" to make a "greater-than" comparison)
		or by using software emulation. When using software emulation, the program must swap the operands (copying
		registers when necessary to protect the data that will now be in the destination operand), and then perform the
		compare using a different predicate. 
		
		Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand
		CMPSD instruction, for processors with "CPUID.1H:ECX.AVX = 0". Compilers should treat reserved imm8 values as illegal syntax.
		
		The greater-than relations not implemented in the processor require more than one instruction to emulate in soft-
		ware and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the
		operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to
		the correct destination register and that the source operand is left intact.)
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		
		~Enhanced Comparison Predicate for VEX-Encoded VCMPSD
			VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source
			operand (third operand) can be an XMM register or a 64-bit memory location. Bits (VLMAX-1:128) of the destination 
			YMM register are zeroed. The comparison predicate operand is an 8-bit immediate:
			
			- For instructions encoded using the VEX prefix, bits 4:0 define the type of comparison to be performed. Bits 5 through 7 of the immediate are reserved.
			
			Processors with "CPUID.1H:ECX.AVX =1" implement the full complement of 32 predicates, software emulation is no longer needed. 
			Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPSD instruction. 
			Compilers should treat reserved Imm8 values as illegal syntax. 
			Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic interface.


	exceptions

	flags

	operation

	meta


cmpss/vcmpss=Compare Scalar Single-Precision Floating-Point Values 
	forms

	description
		Compares the low single-precision floating-point values in the source operand (second operand) and the destination
		operand (first operand) and returns the results of the comparison to the destination operand. The comparison
		predicate operand (third operand) specifies the type of comparison performed. The comparison result is a double-
		word mask of all 1s (comparison true) or all 0s (comparison false). The sign of zero is ignored for comparisons, so
		that -0.0 is equal to +0.0.
		
		128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The
		second source operand (second operand) can be an XMM register or 64-bit memory location. The comparison pred-
		icate operand is an 8-bit immediate, bits 2:0 of the immediate define the type of comparison to be performed.
		Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.
		
		The unordered relationship is true when at least one of the two source operands being compared is a NaN; the
		ordered relationship is true when neither source operand is a NaN.
		
		A subsequent computational instruction that uses the mask result in the destination operand as an input operand
		will not generate a fault, since a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s
		corresponds to a QNaN.
		
		Note that processors with "CPUID.1H:ECX.AVX =0" do not implement the "greater-than", "greater-than-or-equal",
		"not-greater than", and "not-greater-than-or-equal relations" predicates. These comparisons can be made either
		by using the inverse relationship (that is, use the "not-less-than-or-equal" to make a "greater-than" comparison)
		or by using software emulation. When using software emulation, the program must swap the operands (copying
		registers when necessary to protect the data that will now be in the destination operand), and then perform the
		compare using a different predicate. 
		
		Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand
		CMPSS instruction, for processors with "CPUID.1H:ECX.AVX =0". See Table 3-15. Compilers should treat reserved Imm8 values as illegal syntax.
		
		The greater-than relations not implemented in the processor require more than one instruction to emulate in soft-
		ware and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the
		operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to
		the correct destination register and that the source operand is left intact.)
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		
		~Enhanced Comparison Predicate for VEX-Encoded VCMPSD
			VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source
			operand (third operand) can be an XMM register or a 32-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed. 
			The comparison predicate operand is an 8-bit immediate:
			
			- For instructions encoded using the VEX prefix, bits 4:0 define the type of comparison to be performed. Bits 5 through 7 of the immediate are reserved.
			
			Processors with "CPUID.1H:ECX.AVX =1" implement the full complement of 32 predicates, software emulation is no longer needed.
			Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPSS instruction.
			Compilers should treat reserved Imm8 values as illegal syntax.
			Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic interface.

	exceptions

	flags

	operation

	meta


cmpxchg=Compare and Exchange
	forms

	description
		Compares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two
		values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the
		destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode.
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the
		interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the
		comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is
		written into the destination. (The processor never produces a locked read without also producing a locked write.)
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). 
		Use of the REX.W prefix promotes operation to 64 bits.
		
		This instruction is not supported on Intel processors earlier than the Intel 486 processors.

	exceptions

	flags

	operation

	meta


cmpxchg8b/cmpxchg16b=Compare and Exchange Bytes 
	forms

	description
		Compares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand
		(destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored
		in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX).
		The destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For
		the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the
		low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-
		order 64 bits and RAX and RBX contain the low-order 64bits of a 128-bit value.
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the
		interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the
		comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is
		written into the destination. (The processor never produces a locked read without also producing a locked write.)
		
		In 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. Note that
		CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned. See the summary chart at the
		beginning of this section for encoding data and limits.
		
		This instruction encoding is not supported on Intel processors earlier than the Pentium processors.

	exceptions

	flags

	operation

	meta


comisd/vcomisd=Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS 
	forms

	description
		Compares the double-precision floating-point values in the low quadwords of operand 1 (first operand) and
		operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result 
		(unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. 
		The unordered result is returned if either source operand is a NaN (QNaN or SNaN). The sign of zero is ignored for
		comparisons, so that -0.0 is equal to +0.0.
		
		Operand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory location.
		The COMISD instruction differs from the UCOMISD instruction in that it signals a SIMD floating-point invalid oper-
		ation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISD instruction signals an invalid
		numeric exception only if a source operand is an SNaN.
		The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


comiss/vcomiss=Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS 
	forms

	description
		Compares the single-precision floating-point values in the low doublewords of operand 1 (first operand) and
		operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result 
		(unordered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. 
		The unordered result is returned if either source operand is a NaN (QNaN or SNaN). The sign of zero is ignored for
		comparisons, so that -0.0 is equal to +0.0.
		
		Operand 1 is an XMM register; Operand 2 can be an XMM register or a 32 bit memory location.
		The COMISS instruction differs from the UCOMISS instruction in that it signals a SIMD floating-point invalid opera-
		tion exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISS instruction signals an invalid
		numeric exception only if a source operand is an SNaN.
		
		The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cpuid=CPU Identification
	forms

	description
		CPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers.1 The
		instruction's output is dependent on the contents of the EAX register upon execution (in some cases, ECX as well).
		
		Two types of information are returned: basic and extended function information. If a value entered for CPUID.EAX
		is higher than the maximum input value for basic or extended function for that processor then the data for the
		highest basic information leaf is returned.
		
		The ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can
		set and clear this flag, the processor executing the procedure supports the CPUID instruction. 
		
		If a value entered for CPUID.EAX is less than or equal to the maximum input value and the leaf is not supported on
		that processor then 0 is returned in all the registers.
		
		When CPUID returns the highest basic leaf information as a result of an invalid input EAX value, any dependence
		on input ECX value in the basic leaf is honored.
		CPUID can be executed at any privilege level to serialize instruction execution. Serializing instruction execution
		guarantees that any modifications to flags, registers, and memory for previous instructions are completed before
		the next instruction is fetched and executed.
		
		This instruction operates the same in non-64-bit modes and 64-bit mode.
		
		When CPUID executes with EAX set to 0, the processor returns the highest value the CPUID recognizes for
		returning basic processor information. The value is returned in the EAX register (see Table 3-18) and is processor
		specific.
		A vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is "GenuineIntel" and is expressed:
		EBX = 756e6547h (* "Genu", with G in the low eight bits of BL *)
		EDX = 49656e69h (* "ineI", with i in the low eight bits of DL *)
		ECX = 6c65746eh (* "ntel", with n in the low eight bits of CL *)
		
		When CPUID executes with EAX set to 80000000H, the processor returns the highest value the processor recognizes 
		for returning extended processor information. The value is returned in the EAX register and is processor specific.

	exceptions

	flags

	operation

	meta
		see
			"Serializing Instructions", Chapter 8 - "Multiple-Processor Management", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A
			"Caching Translation Information", Chapter 4 - "Paging", Intel64 and IA-32 Architectures Software Developer's Manual, Volume 3A


crc32=Accumulate CRC32 Value 
	forms

	description
		Starting with an initial value in the first operand (destination operand), accumulates a CRC32 (polynomial
		11EDC6F41H) value for the second operand (source operand) and stores the result in the destination operand. The
		source operand can be a register or a memory location. The destination operand must be an r32 or r64 register. If
		the destination is an r64 register, then the 32-bit result is stored in the least significant double word and
		00000000H is stored in the most significant double word of the r64 register.
		
		The initial value supplied in the destination operand is a double word integer stored in the r32 register or the least
		significant double word of the r64 register. To incrementally accumulate a CRC32 value, software retains the result
		of the previous CRC32 operation in the destination operand, then executes the CRC32 instruction again with new
		input data in the source operand. Data contained in the source operand is processed in reflected bit order.
		This means that the most significant bit of the source operand is treated as the least significant bit of the quotient, 
		and so on, for all the bits of the source operand. Likewise, the result of the CRC operation is stored in the destination
		operand in reflected bit order. This means that the most significant bit of the resulting CRC (bit 31) is stored in the
		least significant bit of the destination operand (bit 0), and so on, for all the bits of the CRC.

	exceptions

	flags

	operation

	meta


cvtdq2pd/vcvtdq2pd=Convert Packed Dword Integers to Packed Double-Precision FP Values 
	forms

	description
		Converts two packed signed doubleword integers in the source operand (second operand) to two packed double-
		precision floating-point values in the destination operand (first operand).
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding XMM register destination are
		unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 128- bit memory location. The destination
		operation is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtdq2ps/vcvtdq2ps=Convert Packed Dword Integers to Packed Single-Precision FP Values 
	forms

	description
		Converts four packed signed doubleword integers in the source operand (second operand) to four packed single-
		precision floating-point values in the destination operand (first operand).
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding XMM register destination are unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
		operation is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtpd2dq/vcvtpd2dq=Convert Packed Double-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts two packed double-precision floating-point values in the source operand (second operand) to two packed
		signed doubleword integers in the destination operand (first operand).
		The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM
		register. The result is stored in the low quadword of the destination operand and the high quadword is cleared to all 0s.
		
		When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
		register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid
		exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper bits
		(VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is a YMM register. The upper bits (VLMAX-1:64) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
		operation is an XMM register. The upper bits (255:128) of the corresponding YMM register destination are zeroed.
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtpd2pi/vcvtpd2pi=Convert Packed Double-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts two packed double-precision floating-point values in the source operand (second operand) to two packed
		signed doubleword integers in the destination operand (first operand).
		The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.
		
		When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
		register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid
		exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.
		This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
		pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
		floating-point exception is pending, the exception is handled before the CVTPD2PI instruction is executed.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cvtpd2ps/vcvtpd2ps=Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values 
	forms

	description
		Converts two packed double-precision floating-point values in the source operand (second operand) to two packed
		single-precision floating-point values in the destination operand (first operand).
		
		When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper bits
		(VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is a YMM register. The upper bits (VLMAX-1:64) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
		operation is an XMM register. The upper bits (255:128) of the corresponding YMM register destination are zeroed.
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtpi2pd=Convert Packed Dword Integers to Packed Double-Precision FP Values 
	forms

	description
		Converts two packed signed doubleword integers in the source operand (second operand) to two packed double-
		precision floating-point values in the destination operand (first operand).
		The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an
		XMM register. In addition, depending on the operand configuration:

		- For operands xmm, mm: the instruction causes a transition from x87 FPU to MMX technology operation (that
		is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this
		instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before
		the CVTPI2PD instruction is executed.
		
		- For operands xmm, m64: the instruction does not cause a transition to MMX technology and does not take
		x87 FPU exceptions.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cvtpi2ps=Convert Packed Dword Integers to Packed Single-Precision FP Values 
	forms

	description
		Converts two packed signed doubleword integers in the source operand (second operand) to two packed single-
		precision floating-point values in the destination operand (first operand).
		
		The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an
		XMM register. The results are stored in the low quadword of the destination operand, and the high quadword
		remains unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control
		bits in the MXCSR register.
		
		This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
		pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
		floating-point exception is pending, the exception is handled before the CVTPI2PS instruction is executed.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cvtps2dq/vcvtps2dq=Convert Packed Single-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts four or eight packed single-precision floating-point values in the source operand to four or eight signed
		doubleword integers in the destination operand.
		
		When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
		register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid
		exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is a YMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
		operation is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtps2pd/vcvtps2pd=Convert Packed Single-Precision FP Values to Packed Double-Precision FP Values 
	forms

	description
		Converts two or four packed single-precision floating-point values in the source operand (second operand) to two
		or four packed double-precision floating-point values in the destination operand (first operand).
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination
		operation is a YMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtps2pi=Convert Packed Single-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts two packed single-precision floating-point values in the source operand (second operand) to two packed
		signed doubleword integers in the destination operand (first operand).
		
		The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX tech-
		nology register. When the source operand is an XMM register, the two single-precision floating-point values are
		contained in the low quadword of the register. When a conversion is inexact, the value returned is rounded
		according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum
		signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indef-
		inite integer value (80000000H) is returned.
		
		CVTPS2PI causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer
		is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-
		point exception is pending, the exception is handled before the CVTPS2PI instruction is executed.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cvtsd2si/vcvtsd2si=Convert Scalar Double-Precision FP Value to Integer 
	forms

	description
		Converts a double-precision floating-point value in the source operand (second operand) to a signed doubleword
		integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory
		location. The destination operand is a general-purpose register. When the source operand is an XMM register, the
		double-precision floating-point value is contained in the low quadword of the register.
		When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.
		
		If a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode
		with REX.W/VEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite
		integer value (80000000H) is returned.
		
		If a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W = 1),
		the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value
		(8000000000000000H) is returned.
		
		Legacy SSE instructions: Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary
		chart at the beginning of this section for encoding data and limits.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvtsd2ss/vcvtsd2ss=Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value 
	forms

	description
		Converts a double-precision floating-point value in the source operand (second operand) to a single-precision
		floating-point value in the destination operand (first operand).
		
		The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM
		register. When the source operand is an XMM register, the double-precision floating-point value is contained in the
		low quadword of the register. The result is stored in the low doubleword of the destination operand, and the upper
		3 doublewords are left unchanged. When the conversion is inexact, the value returned is rounded according to the
		rounding control bits in the MXCSR register.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:32) of the
		corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


cvtsi2sd/vcvtsi2sd=Convert Dword Integer to Scalar Double-Precision FP Value 
	forms

	description
		Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the second source
		operand to a double-precision floating-point value in the destination operand. The result is stored in the low quad-
		word of the destination operand, and the high quadword left unchanged. When conversion is inexact, the value
		returned is rounded according to the rounding control bits in the MXCSR register.
		
		Legacy SSE instructions: Use of the REX.W prefix promotes the instruction to 64-bit operands. See the summary
		chart at the beginning of this section for encoding data and limits.
		The second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and
		destination operands are XMM registers.
		
		128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:64) of the
		corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


cvtsi2ss/vcvtsi2ss=Convert Dword Integer to Scalar Single-Precision FP Value 
	forms

	description
		Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the source operand
		(second operand) to a single-precision floating-point value in the destination operand (first operand). The source
		operand can be a general-purpose register or a memory location. The destination operand is an XMM register. The
		result is stored in the low doubleword of the destination operand, and the upper three doublewords are left
		unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in
		the MXCSR register.
		
		Legacy SSE instructions: In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15)
		when used with a REX.R prefix. Use of the REX.W prefix promotes the instruction to 64-bit operands. See the
		summary chart at the beginning of this section for encoding data and limits.
		
		128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:32) of the
		corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:32) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


cvtss2sd/vcvtss2sd=Convert Scalar Single-Precision FP Value to Scalar Double-Precision FP Value 
	forms

	description
		Converts a single-precision floating-point value in the source operand (second operand) to a double-precision
		floating-point value in the destination operand (first operand). The source operand can be an XMM register or a 32-
		bit memory location. The destination operand is an XMM register. When the source operand is an XMM register, the
		single-precision floating-point value is contained in the low doubleword of the register. The result is stored in the
		low quadword of the destination operand, and the high quadword is left unchanged.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:64) of the
		corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the
		first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


cvtss2si/vcvtss2si=Convert Scalar Single-Precision FP Value to Dword Integer 
	forms

	description
		Converts a single-precision floating-point value in the source operand (second operand) to a signed doubleword
		integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The
		source operand can be an XMM register or a memory location. The destination operand is a general-purpose
		register. When the source operand is an XMM register, the single-precision floating-point value is contained in the
		low doubleword of the register.
		
		When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
		register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid
		exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.
		In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R
		prefix. Use of the REX.W prefix promotes the instruction to 64-bit operands. See the summary chart at the begin-
		ning of this section for encoding data and limits.
		
		Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operands. See
		the summary chart at the beginning of this section for encoding data and limits.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvttpd2dq/vcvttpd2dq=Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts two or four packed double-precision floating-point values in the source operand (second operand) to two
		or four packed signed doubleword integers in the destination operand (first operand).
		When a conversion is inexact, a truncated (round toward zero) value is returned.If a converted result is larger than
		the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is
		masked, the indefinite integer value (80000000H) is returned.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is a YMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
		operation is an XMM register. The upper bits (255:128) of the corresponding YMM register destination are zeroed.
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvttpd2pi=Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts two packed double-precision floating-point values in the source operand (second operand) to two packed
		signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register
		or a 128-bit memory location. The destination operand is an MMX technology register.
		
		When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than
		the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is
		masked, the indefinite integer value (80000000H) is returned.
		
		This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
		pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
		floating-point exception is pending, the exception is handled before the CVTTPD2PI instruction is executed.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cvttps2dq/vcvttps2dq=Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts four or eight packed single-precision floating-point values in the source operand to four or eight signed
		doubleword integers in the destination operand.
		When a conversion is inexact, a truncated (round toward zero) value is returned.If a converted result is larger than
		the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is
		masked, the indefinite integer value (80000000H) is returned.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		unmodified.
		
		VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
		operation is a YMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
		operation is a YMM register.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvttps2pi=Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers 
	forms

	description
		Converts two packed single-precision floating-point values in the source operand (second operand) to two packed
		signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register
		or a 64-bit memory location. The destination operand is an MMX technology register. When the source operand is
		an XMM register, the two single-precision floating-point values are contained in the low quadword of the register.
		When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger
		than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is
		masked, the indefinite integer value (80000000H) is returned.
		
		This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
		pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
		floating-point exception is pending, the exception is handled before the CVTTPS2PI instruction is executed.
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).

	exceptions

	flags

	operation

	meta


cvttsd2si/vcvttsd2si=Convert with Truncation Scalar Double-Precision FP Value to Signed Integer 
	forms

	description
		Converts a double-precision floating-point value in the source operand (second operand) to a signed doubleword
		integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The
		source operand can be an XMM register or a 64-bit memory location. The destination operand is a general purpose
		register. When the source operand is an XMM register, the double-precision floating-point value is contained in the
		low quadword of the register.
		
		When a conversion is inexact, a truncated (round toward zero) result is returned.
		If a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode
		with REX.W/VEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite
		integer value (80000000H) is returned.
		
		If a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W = 1),
		the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value
		(8000000000000000H) is returned.
		
		Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See
		the summary chart at the beginning of this section for encoding data and limits.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cvttss2si/vcvttss2si=Convert with Truncation Scalar Single-Precision FP Value to Dword Integer 
	forms

	description
		Converts a single-precision floating-point value in the source operand (second operand) to a signed doubleword
		integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The
		source operand can be an XMM register or a 32-bit memory location. The destination operand is a general-purpose
		register. When the source operand is an XMM register, the single-precision floating-point value is contained in the
		low doubleword of the register.
		
		When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than
		the maximum signed doubleword integer, the floating-point invalid exception is raised. If this exception is masked,
		the indefinite integer value (80000000H) is returned.
		
		Legacy SSE instructions: In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15)
		when used with a REX.R prefix. Use of the REX.W prefix promotes the instruction to 64-bit operation. See the
		summary chart at the beginning of this section for encoding data and limits.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


cwd=Convert Word to Doubleword
cdq=Convert Doubleword to Quadword
cqo=Convert Quadword to Octword
	forms

	description
		Doubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign
		extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction
		copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction
		copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruc-
		tion (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position
		in the RDX register.
		
		The CWD instruction can be used to produce a doubleword dividend from a word before word division. The CDQ
		instruction can be used to produce a quadword dividend from a doubleword before doubleword division. The CQO
		instruction can be used to produce a double quadword dividend from a quadword before a quadword division.
		The CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the
		operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers
		may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these
		mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the
		size of values to be converted, regardless of the mnemonic used.
		
		In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same
		opcode as CWD/CDQ. See the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


daa=Decimal Adjust AL after Addition 
	forms

	description
		Adjusts the sum of two packed BCD values to create a packed BCD result. The AL register is the implied source and
		destination operand. The DAA instruction is only useful when it follows an ADD instruction that adds (binary addi-
		tion) two 2-digit, packed BCD values and stores a byte result in the AL register. The DAA instruction then adjusts
		the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal carry is detected, the
		CF and AF flags are set accordingly.
		
		This instruction executes as described above in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


das=Decimal Adjust AL after Subtraction 
	forms

	description
		Adjusts the result of the subtraction of two packed BCD values to create a packed BCD result. The AL register is the
		implied source and destination operand. The DAS instruction is only useful when it follows a SUB instruction that
		subtracts (binary subtraction) one 2-digit, packed BCD value from another and stores a byte result in the AL register.
		The DAS instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result.
		If a decimal borrow is detected, the CF and AF flags are set accordingly.
		
		This instruction executes as described above in compatibility mode and legacy mode. It is not valid in 64-bit mode.

	exceptions

	flags

	operation

	meta


dec=Decrement by 1
	forms

	description
		Subtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be
		a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag.
		(To perform a decrement operation that updates the CF flag, use a SUB instruction with an immediate operand of 1.)
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		
		In 64-bit mode, DEC r16 and DEC r32 are not encodable (because opcodes 48H through 4FH are REX prefixes).
		
		Otherwise, the instruction's 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to
		additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.
		See the summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta


div=Unsigned Divide 
	forms

	description
		Divides unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers (dividend) by the source operand
		(divisor) and stores the result in the AX (AH:AL), DX:AX, EDX:EAX, or RDX:RAX registers. The source operand can
		be a general-purpose register or a memory location. The action of this instruction depends on the operand size
		(dividend/divisor). Division using 64-bit operand is available only in 64-bit mode.
		
		Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude.
		Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional 
		registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied,
		the instruction divides the unsigned value in RDX:RAX by the source operand and stores the quotient in RAX, the remainder in RDX.

	exceptions

	flags

	operation

	meta


divpd/vdivpd=Divide Packed Double-Precision Floating-Point Values 
	forms

	description
		Performs an SIMD divide of the two or four packed double-precision floating-point values in the first source operand
		by the two or four packed double-precision floating-point values in the second source operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


divps/vdivps=Divide Packed Single-Precision Floating-Point Values
	forms

	description
		Performs an SIMD divide of the four or eight packed single-precision floating-point values in the first source
		operand by the four or eight packed single-precision floating-point values in the second source operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


divsd/vdivsd=Divide Scalar Double-Precision Floating-Point Values
	forms

	description
		Divides the low double-precision floating-point value in the first source operand by the low double-precision
		floating-point value in the second source operand, and stores the double-precision floating-point result in the desti-
		nation operand. The second source operand can be an XMM register or a 64-bit memory location. The first source
		and destination hyperons are XMM registers. The high quadword of the destination operand is copied from the high
		quadword of the first source operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
		1:64) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


divss/vdivss=Divide Scalar Single-Precision Floating-Point Values 
	forms

	description
		Divides the low single-precision floating-point value in the first source operand by the low single-precision floating-
		point value in the second source operand, and stores the single-precision floating-point result in the destination
		operand. The second source operand can be an XMM register or a 32-bit memory location. The first source and
		destination operands are XMM registers. The three high-order doublewords of the destination are copied from the
		same dwords of the first source operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
		1:32) of the corresponding YMM destination register remain unchanged.
		
		VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.

	exceptions

	flags

	operation

	meta


dppd/vdppd=Dot Product of Packed Double Precision Floating-Point Values 
	forms

	description
		Conditionally multiplies the packed double-precision floating-point values in the destination operand (first operand)
		with the packed double-precision floating-point values in the source (second operand) depending on a mask
		extracted from bits [5:4] of the immediate operand (third operand). If a condition mask bit is zero, the corre-
		sponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1.
		
		The two resulting double-precision values are summed into an intermediate result. The intermediate result is
		conditionally broadcasted to the destination using a broadcast mask specified by bits [1:0] of the immediate byte.
		If a broadcast mask bit is "1", the intermediate result is copied to the corresponding qword element in the destina-
		tion operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.
		DPPD follows the NaN forwarding rules stated in the Software Developer's Manual, vol. 1, table 4.7. These rules do
		not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of
		those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally gener-
		ated NaNs will have at least one NaN propagated to the destination.
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		If VDPPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an
		#UD exception.

	exceptions

	flags

	operation

	meta


dpps/vdpps=Dot Product of Packed Single Precision Floating-Point Values 
	forms

	description
		Conditionally multiplies the packed single precision floating-point values in the destination operand (first operand)
		with the packed single-precision floats in the source (second operand) depending on a mask extracted from the
		high 4 bits of the immediate byte (third operand). If a condition mask bit in Imm8[7:4] is zero, the corresponding
		multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel 64 and IA-32 Archi-
		tectures Software Developer's Manual, Volume 1.
		
		The four resulting single-precision values are summed into an intermediate result. The intermediate result is condi-
		tionally broadcasted to the destination using a broadcast mask specified by bits [3:0] of the immediate byte.
		If a broadcast mask bit is "1", the intermediate result is copied to the corresponding dword element in the destina-
		tion operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.
		DPPS follows the NaN forwarding rules stated in the Software Developer's Manual, vol. 1, table 4.7. These rules do
		not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of
		those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally gener-
		ated NaNs will have at least one NaN propagated to the destination.
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


emms=Empty MMX Technology State 
	forms

	description
		Sets the values of all the tags in the x87 FPU tag word to empty (all 1s). This operation marks the x87 FPU data
		registers (which are aliased to the MMX technology registers) as available for use by x87 FPU floating-point instructions. 
		All other MMX instructions (other than the EMMS instruction) set all the tags in x87 FPU tag word to valid (all 0s).
		
		The EMMS instruction must be used to clear the MMX technology state at the end of all MMX technology procedures
		or subroutines and before calling other procedures or subroutines that may execute x87 floating-point instructions.
		If a floating-point instruction loads one of the registers in the x87 FPU data register stack before the x87 FPU tag
		word has been reset by the EMMS instruction, an x87 floating-point register stack overflow can occur that will
		result in an x87 floating-point exception or incorrect result.
		
		EMMS operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


enter=Make Stack Frame for Procedure Parameters 
	forms

	description
		Creates a stack frame for a procedure. The first operand (size operand) specifies the size of the stack frame (that
		is, the number of bytes of dynamic storage allocated on the stack for the procedure). The second operand (nesting
		level operand) gives the lexical nesting level (0 to 31) of the procedure. The nesting level determines the number
		of stack frame pointers that are copied into the "display area" of the new stack frame from the preceding frame.
		Both of these operands are immediate values.
		
		The stack-size attribute determines whether the BP (16 bits), EBP (32 bits), or RBP (64 bits) register specifies the
		current frame pointer and whether SP (16 bits), ESP (32 bits), or RSP (64 bits) specifies the stack pointer. In 64-bit mode, 
		stack-size attribute is always 64-bits.
		
		The ENTER and companion LEAVE instructions are provided to support block structured languages. The ENTER
		instruction (when used) is typically the first instruction in a procedure and is used to set up a new stack frame for
		a procedure. The LEAVE instruction is then used at the end of the procedure (just before the RET instruction) to
		release the stack frame.
		
		If the nesting level is 0, the processor pushes the frame pointer from the BP/EBP/RBP register onto the stack,
		copies the current stack pointer from the SP/ESP/RSP register into the BP/EBP/RBP register, and loads the
		SP/ESP/RSP register with the current stack-pointer value minus the value in the size operand. For nesting levels of
		1 or greater, the processor pushes additional frame pointers on the stack before adjusting the stack pointer. These
		additional frame pointers provide the called procedure with access points to other nested frames on the stack. See
		"Procedure Calls for Block-Structured Languages" in Chapter 6 of the Intel 64 and IA-32 Architectures Software
		Developer's Manual, Volume 1, for more information about the actions of the ENTER instruction.
		The ENTER instruction causes a page fault whenever a write using the final value of the stack pointer (within the
		current stack segment) would do so.
		
		In 64-bit mode, default operation size is 64 bits; 32-bit operation size cannot be encoded.

	exceptions

	flags

	operation

	meta


extractps/vextractps=Extract Packed Single Precision Floating-Point Value
	forms

	description
		Extracts a single-precision floating-point value from the source operand (second operand) at the 32-bit offset specified from imm8. 
		Immediate bits higher than the most significant offset for the vector length are ignored.
		The extracted single-precision floating-point value is stored in the low 32-bits of the destination operand
		In 64-bit mode, destination register operand has default operand size of 64 bits. The upper 32-bits of the register
		are filled with zero. REX.W is ignored.
		
		128-bit Legacy SSE version: When a REX.W prefix is used in 64-bit mode with a general purpose register (GPR) as
		a destination operand, the packed single quantity is zero extended to 64 bits.
		
		VEX.128 encoded version: When VEX.128.66.0F3A.W1 17 form is used in 64-bit mode with a general purpose
		register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits. VEX.vvvv is
		reserved and must be 1111b otherwise instructions will #UD.
		
		The source register is an XMM register. Imm8[1:0] determine the starting DWORD offset from which to extract the
		32-bit floating-point value.
		
		If VEXTRACTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause
		an #UD exception.

	exceptions

	flags

	operation

	meta


f2xm1=Compute 2^^x-1 
	forms

	description
		Computes the exponential value of 2 to the power of the source operand minus 1. The source operand is located in
		register ST(0) and the result is also stored in ST(0). The value of the source operand must lie in the range -1.0 to
		+1.0. If the source value is outside this range, the result is undefined.

	exceptions

	flags

	operation

	meta


fabs=Absolute Value 
	forms

	description
		Clears the sign bit of ST(0) to create the absolute value of the operand.

	exceptions

	flags

	operation

	meta


fadd/faddp/fiadd=Add Floating-Point Values
	forms

	description
		Adds the destination and source operands and stores the sum in the destination location. The destination operand
		is always an FPU register; the source operand can be a register or a memory location. Source operands in memory
		can be in single-precision or double-precision floating-point format or in word or doubleword integer format.
		The no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-
		operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents
		of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice
		versa. The value in ST(0) can be doubled by coding:
		
		FADD ST(0), ST(0);
		
		The FADDP instructions perform the additional operation of popping the FPU register stack after storing the result.
		To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
		by 1. (The no-operand version of the floating-point add instructions always results in the register stack being
		popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)
		
		The FIADD instructions convert an integer source operand to double extended-precision floating-point format
		before performing the addition.
		
		When the sum of two operands with opposite signs is 0, the result is +0, except for the round toward -infinity mode, in
		which case the result is -0. When the source operand is an integer 0, it is treated as a +0.
		When both operand are infinities of the same sign, the result is infinity of the expected sign. 
		If both operands are infinities of opposite signs, an invalid-operation exception is generated. 

	exceptions

	flags

	operation

	meta


fbld=Load Binary Coded Decimal 
	forms

	description
		Converts the BCD source operand into double extended-precision floating-point format and pushes the value onto
		the FPU stack. The source operand is loaded without rounding errors. The sign of the source operand is preserved,
		including that of -0.
		
		The packed BCD digits are assumed to be in the range 0 through 9; the instruction does not check for invalid digits
		(AH through FH). Attempting to load an invalid encoding produces an undefined result.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fbstp=Store BCD Integer and Pop 
	forms

	description
		Converts the value in the ST(0) register to an 18-digit packed BCD integer, stores the result in the destination
		operand, and pops the register stack. If the source value is a non-integral value, it is rounded to an integer value,
		according to rounding mode specified by the RC field of the FPU control word. To pop the register stack, the
		processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
		
		The destination operand specifies the address where the first byte destination value is to be stored. The BCD value
		(including its sign bit) requires 10 bytes of space in memory.
		
		If the converted value is too large for the destination format, or if the source operand is an infinity, SNaN, QNAN, or is in
		an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is
		not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination
		operand. If the invalid-operation exception is masked, the packed BCD indefinite value is stored in memory.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fchs=Change Sign 
	forms

	description
		Complements the sign bit of ST(0). This operation changes a positive value into a negative value of equal magnitude or vice versa.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fclex/fnclex=Clear Exceptions 
	forms

	description
		Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception summary status flag (ES), the
		stack fault flag (SF), and the busy flag (B) in the FPU status word. The FCLEX instruction checks for and handles
		any pending unmasked floating-point exceptions before clearing the exception flags; the FNCLEX instruction does
		not.
		
		The assembler issues two instructions for the FCLEX instruction (an FWAIT instruction followed by an FNCLEX
		instruction), and the processor executes each of these instructions separately. If an exception is generated for
		either of these instructions, the save EIP points to the instruction that caused the exception.
		
		When operating a Pentium or Intel486 processor in MS-DOS* compatibility mode, it is possible (under unusual
		circumstances) for an FNCLEX instruction to be interrupted prior to being executed to handle a pending FPU excep-
		tion. See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the Intel
		64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a description of these circumstances. An
		FNCLEX instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.
		This instruction affects only the x87 FPU floating-point exception flags. It does not affect the SIMD floating-point
		exception flags in the MXCRS register.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fcmovb=Floating-Point Move If Below
fcmove=Floating-Point Move If Equal
fcmovbe=Floating-Point Move If Below Or Equal
fcmovu=Floating-Point Move If Unordered
fcmovnb=Floating-Point Move If Not Below
fcmovne=Floating-Point Move If Not Equal
fcmovnbe=Floating-Point Move If Not Below Or Equal
fcmovnu=Floating-Point Move If Not Unordered
	forms

	description
		Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
		operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
		tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1.
		The source operand is always in the ST(i) register and the destination operand is always ST(0).
		
		The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
		overhead for IF operations and the possibility of branch mispredictions by the processor.
		A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
		supported by checking the processor's feature information with the CPUID instruction. If both the CMOV and FPU
		feature bits are set, the FCMOVcc instructions are supported.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fcom/fcomp/fcompp=Compare Floating Point Values 
	forms

	description
		Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU
		status word according to the results. The source operand can be a data register or a memory
		location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is
		ignored, so that -0.0 is equal to +0.0.
		
		This instruction checks the class of the numbers being compared (see "FXAM-Examine ModR/M" in this chapter).
		If either operand is a NaN or is in an unsupported format, an invalid-arithmetic-operand exception (#IA) is raised
		and, if the exception is masked, the condition flags are set to "unordered." 
		If the invalid-arithmetic-operand exception is unmasked, the condition code flags are not set.
		
		The FCOMP instruction pops the register stack following the comparison operation and the FCOMPP instruction
		pops the register stack twice following the comparison operation. To pop the register stack, the processor marks
		the ST(0) register as empty and increments the stack pointer (TOP) by 1.
		
		The FCOM instructions perform the same operation as the FUCOM instructions. The only difference is how they
		handle QNaN operands. The FCOM instructions raise an invalid-arithmetic-operand exception (#IA) when either or
		both of the operands is a NaN value or is in an unsupported format. The FUCOM instructions perform the same
		operation as the FCOM instructions, except that they do not generate an invalid-arithmetic-operand exception for
		QNaNs.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fcomi/fcomip/fucomi/fucomip=Compare Floating Point Values and Set EFLAGS
	forms

	description
		Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and
		CF in the EFLAGS register according to the results. The sign of zero is ignored for comparisons, so that -0.0 is equal to +0.0.
		
		An unordered comparison checks the class of the numbers being compared (see "FXAM-Examine ModR/M" in this
		chapter). The FUCOMI/FUCOMIP instructions perform the same operations as the FCOMI/FCOMIP instructions. The
		only difference is that the FUCOMI/FUCOMIP instructions raise the invalid-arithmetic-operand exception (#IA) only
		when either or both operands are an SNaN or are in an unsupported format; QNaNs cause the condition code flags
		to be set to unordered, but do not cause an exception to be generated. The FCOMI/FCOMIP instructions raise an
		invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format.
		
		If the operation results in an invalid-arithmetic-operand exception being raised, the status flags in the EFLAGS
		register are set only if the exception is masked.
		
		The FCOMI/FCOMIP and FUCOMI/FUCOMIP instructions set the OF, SF and AF flags to zero in the EFLAGS register
		(regardless of whether an invalid-operation exception is detected).
		
		The FCOMIP and FUCOMIP instructions also pop the register stack following the comparison operation. To pop the
		register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fcos= Cosine 
	forms

	description
		Computes the approximate cosine of the source operand in register ST(0) and stores the result in ST(0). The
		source operand must be given in radians and must be within the range -2^^63 to +2^^63.
		
		If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in
		register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of
		range. It is up to the program to check the C2 flag for out-of-range conditions.
		Source values outside the range -2^^63 to +2^^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2*PI.
		
		However, even within the range -2^^63 to +2^^63, inaccurate results can occur because the finite approximation of PI
		used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply
		FCOS only to arguments reduced accurately in software, to a value smaller in absolute value than 3*PI/8. See the
		sections titled "Approximation of Pi" and "Transcendental Instruction Accuracy" in Chapter 8 of the Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1, for a discussion of the proper value to use for PI in performing such reductions.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fdecstp=Decrement Stack-Top Pointer
	forms

	description
		Subtracts one from the TOP field of the FPU status word (decrements the top-of-stack pointer). If the TOP field
		contains a 0, it is set to 7. The effect of this instruction is to rotate the stack by one position. The contents of the
		FPU data registers and tag register are not affected.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fdiv/fdivp/fidiv=Divide 
	forms

	description
		Divides the destination operand by the source operand and stores the result in the destination location.
		The destination operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory
		location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.
		
		The no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0)
		register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location
		(either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by
		the contents of the ST(i) register or vice versa.
		
		The FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result.
		To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
		by 1. The no-operand version of the floating-point divide instructions always results in the register stack being
		popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.
		
		The FIDIV instructions convert an integer source operand to double extended-precision floating-point format
		before performing the division. When the source operand is an integer 0, it is treated as a +0.
		
		If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an infinity of
		the appropriate sign is stored in the destination operand.
		
		The following table shows the results obtained when dividing various classes of numbers, assuming that neither
		overflow nor underflow occurs.

	exceptions

	flags

	operation

	meta


fdivr/fdivrp/fidivr=Reverse Divide 
	forms

	description
		Divides the source operand by the destination operand and stores the result in the destination location.
		The destination operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory
		location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.
		
		These instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to
		support more efficient coding.
		
		The no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1)
		register. The one-operand version divides the contents of a memory location (either a floating-point or an integer
		value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by
		the contents of the ST(0) register or vice versa.
		
		The FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result.
		To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
		by 1. The no-operand version of the floating-point divide instructions always results in the register stack being
		popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.
		
		The FIDIVR instructions convert an integer source operand to double extended-precision floating-point format
		before performing the division.
		
		If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an infinity of
		the appropriate sign is stored in the destination operand.
		
		The following table shows the results obtained when dividing various classes of numbers, assuming that neither
		overflow nor underflow occurs.

	exceptions

	flags

	operation

	meta


ffree=Free Floating-Point Register 
	forms

	description
		Sets the tag in the FPU tag register associated with register ST(i) to empty (11B). The contents of ST(i) and the FPU
		stack-top pointer (TOP) are not affected.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


ficom/ficomp=Compare Integer
	forms

	description
		Compares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in
		the FPU status word according to the results. 
		The integer value is converted to double extended-precision floating-point format before the comparison is made.
		
		These instructions perform an "unordered comparison." An unordered comparison also checks the class of the
		numbers being compared. If either operand is a NaN or is in an undefined format, the condition flags are set to "unordered."
		The sign of zero is ignored, so that -0.0 to +0.0.
		
		The FICOMP instructions pop the register stack following the comparison. To pop the register stack, the processor
		marks the ST(0) register empty and increments the stack pointer (TOP) by 1.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.


	exceptions

	flags

	operation

	meta


fild=Load Integer 
	forms

	description
		Converts the signed-integer source operand into double extended-precision floating-point format and pushes the
		value onto the FPU register stack. The source operand can be a word, doubleword, or quadword integer. It is loaded
		without rounding errors. The sign of the source operand is preserved.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fincstp=Increment Stack-Top Pointer 
	forms

	description
		Adds one to the TOP field of the FPU status word (increments the top-of-stack pointer). If the TOP field contains a
		7, it is set to 0. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data
		registers and tag register are not affected. This operation is not equivalent to popping the stack, because the tag
		for the previous top-of-stack register is not marked empty.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


finit/fninit=Initialize Floating-Point Unit 
	forms

	description
		Sets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU
		control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared
		(no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all
		tagged as empty (11B). Both the instruction and data pointers are cleared.
		
		The FINIT instruction checks for and handles any pending unmasked floating-point exceptions before performing the initialization; the FNINIT instruction does not.
		
		The assembler issues two instructions for the FINIT instruction (an FWAIT instruction followed by an FNINIT instruction),
		and the processor executes each of these instructions in separately. If an exception is generated for
		either of these instructions, the save EIP points to the instruction that caused the exception.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.
		
		When operating a Pentium or Intel 486 processor in MS-DOS compatibility mode, it is possible (under unusual
		circumstances) for an FNINIT instruction to be interrupted prior to being executed to handle a pending FPU exception. 
		See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the Intel
		64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a description of these circumstances. An
		FNINIT instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.
		In the Intel 387 math co-processor, the FINIT/FNINIT instruction does not clear the instruction and data pointers.
		This instruction affects only the x87 FPU. It does not affect the XMM and MXCSR registers.

	exceptions

	flags

	operation

	meta


fist/fistp=Store Integer 
	forms

	description
		The FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the destination operand.
		Values can be stored in word or doubleword integer format.
		The destination operand specifies the address where the first byte of the destination value is to be stored.
		
		The FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop
		the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
		The FISTP instruction also stores values in quadword integer format.
		
		If the source value is a non-integral value, it is rounded to an integer value, according to the rounding mode spec-
		ified by the RC field of the FPU control word.
		
		If the converted value is too large for the destination format, or if the source operand is an infinity, SNaN, QNAN, or is in
		an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is
		not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination
		operand. If the invalid-operation exception is masked, the integer indefinite value is stored in memory.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fisttp=Store Integer with Truncation 
	forms

	description
		FISTTP converts the value in ST into a signed integer using truncation (chop) as rounding mode, transfers the
		result to the destination, and pop ST. FISTTP accepts word, short integer, and long integer destinations.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fld=Load Floating Point Value
	forms

	description
		Pushes the source operand onto the FPU register stack. The source operand can be in single-precision, double-
		precision, or double extended-precision floating-point format. If the source operand is in single-precision or
		double-precision floating-point format, it is automatically converted to the double extended-precision floating-
		point format before being pushed on the stack.
		
		The FLD instruction can also push the value in a selected FPU register [ST(i)] onto the stack. Here, pushing register ST(0) duplicates the stack top.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fld1=Push +1.0 onto the FPU register stack
fldl2t=Push log2(10) onto the FPU register stack
fldl2e=Push log2(e) onto the FPU register stack
fldpi=Push PI onto the FPU register stack
fldlg2=Push log10(2) onto the FPU register stack
fldln2=Push ln(2) onto the FPU register stack
fldz=Push +0.0 onto the FPU register stack
	forms

	description
		Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU
		register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log2(10), log2(e), PI, log10(2),
		and ln(2). For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control
		word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a
		result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.
		
		When the RC field is set to round-to-nearest, the FPU produces the same constants that is produced by the Intel 8087 and Intel 287 math co-processors.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fldcw=Load x87 FPU Control Word 
	forms

	description
		Loads the 16-bit source operand into the FPU control word. The source operand is a memory location. This instruc-
		tion is typically used to establish or change the FPU's mode of operation.
		
		If one or more exception flags are set in the FPU status word prior to loading a new FPU control word and the new
		control word unmasks one or more of those exceptions, a floating-point exception will be generated upon execution
		of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled "Soft-
		ware Exception Handling" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Developer's Manual,
		Volume 1). To avoid raising exceptions when changing FPU operating modes, clear any pending exceptions (using
		the FCLEX or FNCLEX instruction) before loading the new control word.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fldenv=Load x87 FPU Environment
	forms

	description
		Loads the complete x87 FPU operating environment from memory into the FPU registers. The source operand spec-
		ifies the first byte of the operating-environment data in memory. This data is typically written to the specified
		memory location by a FSTENV or FNSTENV instruction.
		
		The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data
		pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and IA-32 Architectures Software Developer's
		Manual, Volume 1, show the layout in memory of the loaded environment, depending on the operating mode of the
		processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the
		real mode layouts are used.
		
		The FLDENV instruction should be executed in the same operating mode as the corresponding FSTENV/FNSTENV instruction.
		
		If one or more unmasked exception flags are set in the new FPU status word, a floating-point exception will be
		generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions,
		see the section titled "Software Exception Handling" in Chapter 8 of the Intel 64 and IA-32 Architectures Soft-
		ware Developer's Manual, Volume 1). To avoid generating exceptions when loading a new environment, clear all
		the exception flags in the FPU status word that is being loaded.
		
		If a page or limit fault occurs during the execution of this instruction, the state of the x87 FPU registers as seen by
		the fault handler may be different than the state being loaded from memory. In such situations, the fault handler
		should ignore the status of the x87 FPU registers, handle the fault, and return. The FLDENV instruction will then
		complete the loading of the x87 FPU registers with no resulting context inconsistency.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fmul/fmulp/fimul=Multiply
	forms

	description
		Multiplies the destination and source operands and stores the product in the destination location. The destination
		operand is always an FPU data register; the source operand can be an FPU data register or a memory location.
		Source operands in memory can be in single-precision or double-precision floating-point format or in word or
		doubleword integer format.
		
		The no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0)
		register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0)
		register by the contents of a memory location (either a floating point or an integer value) and stores the product in
		the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the
		ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the desti-
		nation operand).
		
		The FMULP instructions perform the additional operation of popping the FPU register stack after storing the
		product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack
		pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register
		stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP.
		
		The FIMUL instructions convert an integer source operand to double extended- precision floating-point format before performing the multiplication.
		The sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multi-
		plied is 0 or infinity. When the source operand is an integer 0, it is treated as a +0.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fnop=No Operation
	forms

	description
		Performs no FPU operation. This instruction takes up space in the instruction stream but does not affect the FPU or
		machine context, except the EIP register and the FPU Instruction Pointer.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fpatan=Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack
	forms

	description
		Computes the arctangent of the source operand in register ST(1) divided by the source operand in register ST(0),
		stores the result in ST(1), and pops the FPU register stack. The result in register ST(0) has the same sign as the
		source operand ST(1) and a magnitude less than +PI.
		
		The FPATAN instruction returns the angle between the X axis and the line from the origin to the point (X,Y), where
		Y (the ordinate) is ST(1) and X (the abscissa) is ST(0). The angle depends on the sign of X and Y independently,
		not just on the sign of the ratio Y/X. This is because a point (-X,Y) is in the second quadrant, resulting in an angle
		between PI/2 and PI, while a point (X,-Y) is in the fourth quadrant, resulting in an angle between 0 and -PI/2. A point
		(-X,-Y) is in the third quadrant, giving an angle between -PI/2 and -PI.
		There is no restriction on the range of source operands that FPATAN can accept (except as listed below).
		
		The source operands for this instruction are restricted for the 80287 math co-processor to the following range: 0 <= |ST(1)| < |ST(0)| < +infinity
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fprem=Partial Remainder 
	forms

	description
		Computes the remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the
		ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value:
		
		Remainder = ST(0) - (Q * ST(1))
		
		Here, Q is an integer value that is obtained by truncating the floating-point number quotient of [ST(0) / ST(1)]
		toward zero. The sign of the remainder is the same as the sign of the dividend. The magnitude of the remainder is
		less than that of the modulus, unless a partial remainder was computed (as described below).
		This instruction produces an exact result; the inexact-result exception does not occur and the rounding control has
		no effect.
		
		When the result is 0, its sign is the same as that of the dividend. When the modulus is infinity, the result is equal to the value in ST(0).
		
		The FPREM instruction does not compute the remainder specified in IEEE Std 754. The IEEE specified remainder
		can be computed with the FPREM1 instruction. The FPREM instruction is provided for compatibility with the Intel
		8087 and Intel 287 math co-processors.
		
		The FPREM instruction gets its name "partial remainder" because of the way it computes the remainder. This
		instruction arrives at a remainder through iterative subtraction. It can, however, reduce the exponent of ST(0) by
		no more than 63 in one execution of the instruction. If the instruction succeeds in producing a remainder that is
		less than the modulus, the operation is complete and the C2 flag in the FPU status word is cleared. Otherwise, C2
		is set, and the result in ST(0) is called the partial remainder. The exponent of the partial remainder will be less
		than the exponent of the original dividend by at least 32. Software can re-execute the instruction (using the partial
		remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing such a remainder-computation
		loop, a higher-priority interrupting routine that needs the FPU can force a context switch in-between the instructions in the loop.)
		
		An important use of the FPREM instruction is to reduce the arguments of periodic functions. When reduction is
		complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU
		status word. This information is important in argument reduction for the tangent function (using a modulus of PI/4),
		because it locates the original angle in the correct one of eight sectors of the unit circle.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fprem1=Partial Remainder
	forms

	description
		Computes the IEEE remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in
		the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value:
		
		Remainder = ST(0) - (Q * ST(1))
		
		Here, Q is an integer value that is obtained by rounding the floating-point number quotient of [ST(0) / ST(1)]
		toward the nearest integer value. The magnitude of the remainder is less than or equal to half the magnitude of the
		modulus, unless a partial remainder was computed (as described below).
		
		This instruction produces an exact result; the precision (inexact) exception does not occur and the rounding control
		has no effect.
		
		When the result is 0, its sign is the same as that of the dividend. When the modulus is infinity, the result is equal to the
		value in ST(0).
		
		The FPREM1 instruction computes the remainder specified in IEEE Standard 754. This instruction operates differ-
		ently from the FPREM instruction in the way that it rounds the quotient of ST(0) divided by ST(1) to an integer (see
		the "Operation" section below).
		
		Like the FPREM instruction, FPREM1 computes the remainder through iterative subtraction, but can reduce the
		exponent of ST(0) by no more than 63 in one execution of the instruction. If the instruction succeeds in producing
		a remainder that is less than one half the modulus, the operation is complete and the C2 flag in the FPU status word
		is cleared. Otherwise, C2 is set, and the result in ST(0) is called the partial remainder. The exponent of the partial
		remainder will be less than the exponent of the original dividend by at least 32. Software can re-execute the
		instruction (using the partial remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing
		such a remainder-computation loop, a higher-priority interrupting routine that needs the FPU can force a context
		switch in-between the instructions in the loop.)
		
		An important use of the FPREM1 instruction is to reduce the arguments of periodic functions. When reduction is
		complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU
		status word. This information is important in argument reduction for the tangent function (using a modulus of PI/4),
		because it locates the original angle in the correct one of eight sectors of the unit circle.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fptan=Partial Tangent 
	forms

	description
		Computes the approximate tangent of the source operand in register ST(0), stores the result in ST(0), and pushes
		a 1.0 onto the FPU register stack. The source operand must be given in radians and must be less than +-2^^63.
		
		If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in
		register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of
		range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the 
		range -2^^63 to +2^^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2*PI.
		However, even within the range -2^^63 to +2^^63, inaccurate results can occur because the finite approximation of PI
		used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply
		FPTAN only to arguments reduced accurately in software, to a value smaller in absolute value than 3*PI/8. See the
		sections titled "Approximation of Pi" and "Transcendental Instruction Accuracy" in Chapter 8 of the Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1, for a discussion of the proper value to use for PI in performing such reductions.
		
		The value 1.0 is pushed onto the register stack after the tangent has been computed to maintain compatibility with
		the Intel 8087 and Intel 287 math co-processors. This operation also simplifies the calculation of other trigonometric
		functions. For instance, the cotangent (which is the reciprocal of the tangent) can be computed by executing a
		FDIVR instruction after the FPTAN instruction.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


frndint=Round to Integer 
	forms

	description
		Rounds the source value in the ST(0) register to the nearest integral value, depending on the current rounding
		mode (setting of the RC field of the FPU control word), and stores the result in ST(0).
		If the source value is infinity, the value is not changed. If the source value is not an integral value, the floating-point
		inexact-result exception (#P) is generated.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


frstor=Restore x87 FPU State
	forms

	description
		Loads the FPU state (operating environment and register stack) from the memory area specified with the source
		operand. This state data is typically written to the specified memory location by a previous FSAVE/FNSAVE instruction.
		
		The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data
		pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and IA-32 Architectures Software Developer's
		Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the
		processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the
		real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately following
		the operating environment image.
		
		The FRSTOR instruction should be executed in the same operating mode as the corresponding FSAVE/FNSAVE
		instruction.
		
		If one or more unmasked exception bits are set in the new FPU status word, a floating-point exception will be
		generated. To avoid raising exceptions when loading a new operating environment, clear all the exception flags in
		the FPU status word that is being loaded.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fsave/fnsave=Store x87 FPU State
	forms

	description
		Stores the current FPU state (operating environment and register stack) at the specified destination in memory,
		and then re-initializes the FPU. The FSAVE instruction checks for and handles pending unmasked floating-point
		exceptions before storing the FPU state; the FNSAVE instruction does not.
		
		The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data
		pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and IA-32 Architectures Software Developer's
		Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the
		processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the
		real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately follow
		the operating environment image.
		
		The saved image reflects the state of the FPU after all floating-point instructions preceding the FSAVE/FNSAVE
		instruction in the instruction stream have been executed.
		
		After the FPU state has been saved, the FPU is reset to the same default values it is set to with the FINIT/FNINIT
		instructions (see "FINIT/FNINIT-Initialize Floating-Point Unit" in this chapter).
		The FSAVE/FNSAVE instructions are typically used when the operating system needs to perform a context switch,
		an exception handler needs to use the FPU, or an application program needs to pass a "clean" FPU to a procedure.
		The assembler issues two instructions for the FSAVE instruction (an FWAIT instruction followed by an FNSAVE
		instruction), and the processor executes each of these instructions separately. If an exception is generated for
		either of these instructions, the save EIP points to the instruction that caused the exception.
		
		For Intel math coprocessors and FPUs prior to the Intel Pentium processor, an FWAIT instruction should be
		executed before attempting to read from the memory image stored with a prior FSAVE/FNSAVE instruction. This
		FWAIT instruction helps ensure that the storage operation has been completed.
		When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual
		circumstances) for an FNSAVE instruction to be interrupted prior to being executed to handle a pending FPU excep-
		tion. See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the Intel
		64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a description of these circumstances. An
		FNSAVE instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fscale=Floating-point scale ST(0) by ST(1) 
	forms

	description
		Truncates the value in the source operand (toward 0) to an integral value and adds that value to the exponent of
		the destination operand. The destination and source operands are floating-point values located in registers ST(0)
		and ST(1), respectively. This instruction provides rapid multiplication or division by integral powers of 2.
		In most cases, only the exponent is changed and the mantissa (significand) remains unchanged. However, when
		the value being scaled in ST(0) is a denormal value, the mantissa is also changed and the result may turn out to be
		a normalized number. Similarly, if overflow or underflow results from a scale operation, the resulting mantissa will
		differ from the source's mantissa.
		
		The FSCALE instruction can also be used to reverse the action of the FXTRACT instruction, as shown in the following example:
		
		FXTRACT;
		FSCALE;
		FSTP ST(1);
		
		In this example, the FXTRACT instruction extracts the significand and exponent from the value in ST(0) and stores
		them in ST(0) and ST(1) respectively. The FSCALE then scales the significand in ST(0) by the exponent in ST(1),
		recreating the original value before the FXTRACT operation was performed. The FSTP ST(1) instruction overwrites
		the exponent (extracted by the FXTRACT instruction) with the recreated value, which returns the stack to its orig-
		inal state with only one register [ST(0)] occupied.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fsin=Sine 
	forms

	description
		Computes an approximation of the sine of the source operand in register ST(0) and stores the result in ST(0). The
		source operand must be given in radians and must be within the range -2^^63 to +2^^63.
		
		If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in
		register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of
		range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range -
		263 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2*PI.
		However, even within the range -2^^63 to +2^^63, inaccurate results can occur because the finite approximation of PI
		used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply
		FSIN only to arguments reduced accurately in software, to a value smaller in absolute value than 3*PI/4. See the
		sections titled "Approximation of Pi" and "Transcendental Instruction Accuracy" in Chapter 8 of the Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1, for a discussion of the proper value to use for PI in performing such reductions.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fsincos=Sine and Cosine 
	forms

	description
		Computes both the approximate sine and the cosine of the source operand in register ST(0), stores the sine in
		ST(0), and pushes the cosine onto the top of the FPU register stack. (This instruction is faster than executing the FSIN and FCOS instructions in succession.)
		The source operand must be given in radians and must be within the range -2^^63 to +2^^63.
		If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in
		register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of
		range. It is up to the program to check the C2 flag for out-of-range conditions. 
		Source values outside the range -2^^63 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2*PI.
		However, even within the range -2^^63 to +2^^63, inaccurate results can occur because the finite approximation of PI
		used internally for argument reduction is not sufficient in all cases. Therefore, for accurate results it is safe to apply
		FSINCOS only to arguments reduced accurately in software, to a value smaller in absolute value than 3*PI/8. See the
		sections titled "Approximation of Pi" and "Transcendental Instruction Accuracy" in Chapter 8 of the Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1, for a discussion of the proper value to use for PI in performing such reductions.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fsqrt=Square Root 
	forms

	description
		Computes the square root of the source value in the ST(0) register and stores the result in ST(0).
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fst/fstp=Store Floating Point Value 
	forms

	description
		The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory location 
		or another register in the FPU register stack. When storing the value in memory, the value is converted to
		single-precision or double-precision floating-point format.
		
		The FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop
		the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
		The FSTP instruction can also store values in memory in double extended-precision floating-point format.
		If the destination operand is a memory location, the operand specifies the address where the first byte of the destination value is to be stored. 
		If the destination operand is a register, the operand specifies a register in the register stack relative to the top of the stack.
		
		If the destination size is single-precision or double-precision, the significand of the value being stored is rounded
		to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word),
		and the exponent is converted to the width and bias of the destination format. If the value being stored is too large
		for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no
		value is stored in the destination operand. If the value being stored is a denormal value, the denormal exception
		(#D) is not generated. This condition is simply signaled as a numeric underflow exception (#U) condition.
		If the value being stored is +-0, +-infinity, or a NaN, the least-significant bits of the significand and the exponent are truncated 
		to fit the destination format. This operation preserves the value's identity as a 0, infinity, or NaN.
		If the destination operand is a non-empty register, the invalid-operation exception is not generated.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fstcw/fnstcw=Store x87 FPU Control Word 
	forms

	description
		Stores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction
		checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW
		instruction does not.
		The assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW
		instruction), and the processor executes each of these instructions in separately. If an exception is generated for
		either of these instructions, the save EIP points to the instruction that caused the exception.
		
		When operating a Pentium or Intel 486 processor in MS-DOS compatibility mode, it is possible (under unusual
		circumstances) for an FNSTCW instruction to be interrupted prior to being executed to handle a pending FPU
		exception. See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the
		Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a description of these circumstances.
		An FNSTCW instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family
		processor.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fstenv/fnstenv=Store x87 FPU Environment 
	forms

	description
		Saves the current FPU operating environment at the memory location specified with the destination operand, and
		then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status
		word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and
		IA-32 Architectures Software Developer's Manual, Volume 1, show the layout in memory of the stored environment,
		depending on the operating mode of the processor (protected or real) and the current operand-size attribute
		(16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.
		
		The FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing
		the FPU environment; the FNSTENV instruction does not. The saved image reflects the state of the FPU after all
		floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been
		executed.
		
		These instructions are often used by exception handlers because they provide access to the FPU instruction and
		data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment
		prevents floating-point exceptions from interrupting the exception handler.
		
		The assembler issues two instructions for the FSTENV instruction (an FWAIT instruction followed by an FNSTENV
		instruction), and the processor executes each of these instructions separately. If an exception is generated for
		either of these instructions, the save EIP points to the instruction that caused the exception.
		
		When operating a Pentium or Intel 486 processor in MS-DOS compatibility mode, it is possible (under unusual
		circumstances) for an FNSTENV instruction to be interrupted prior to being executed to handle a pending FPU
		exception. See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the
		Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a description of these circumstances.
		An FNSTENV instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fstsw/fnstsw=Store x87 FPU Status Word 
	forms

	description
		Stores the current value of the x87 FPU status word in the destination location. The destination operand can be
		either a two-byte memory location or the AX register. The FSTSW instruction checks for and handles pending
		unmasked floating-point exceptions before storing the status word; the FNSTSW instruction does not.
		
		The FNSTSW AX form of the instruction is used primarily in conditional branching (for instance, after an FPU
		comparison instruction or an FPREM, FPREM1, or FXAM instruction), where the direction of the branch depends on
		the state of the FPU condition code flags. (See the section titled "Branching and Conditional Moves on FPU Condi-
		tion Codes" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1.) This
		instruction can also be used to invoke exception handlers (by examining the exception flags) in environments that
		do not use interrupts. When the FNSTSW AX instruction is executed, the AX register is updated before the
		processor executes any further instructions. The status stored in the AX register is thus guaranteed to be from the
		completion of the prior FPU instruction.
		
		The assembler issues two instructions for the FSTSW instruction (an FWAIT instruction followed by an FNSTSW
		instruction), and the processor executes each of these instructions separately. If an exception is generated for
		either of these instructions, the save EIP points to the instruction that caused the exception.
		When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual
		circumstances) for an FNSTSW instruction to be interrupted prior to being executed to handle a pending FPU
		exception. See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the
		Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for a description of these circumstances.
		An FNSTSW instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fsub/fsubp/fisub=Subtract 
	forms

	description
		Subtracts the source operand from the destination operand and stores the difference in the destination location.
		The destination operand is always an FPU data register; the source operand can be a register or a memory location.
		Source operands in memory can be in single-precision or double-precision floating-point format or in word or
		doubleword integer format.
		
		The no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and
		stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-
		point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand
		version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.
		
		The FSUBP instructions perform the additional operation of popping the FPU register stack following the subtraction.
		To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer
		(TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack
		being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.
		The FISUB instructions convert an integer source operand to double extended-precision floating-point format
		before performing the subtraction.
		
		When the difference between two operands of like sign is 0, the result is +0, except for the round toward -infinity mode,
		in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the
		source operand is an integer 0, it is treated as a +0.
		When one operand is infinity, the result is infinity of the expected sign. If both operands are infinity of the same sign,
		an invalid-operation exception is generated.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.
	exceptions

	flags

	operation

	meta


fsubr/fsubrp/fisubr=Reverse Subtract
	forms

	description
		Subtracts the destination operand from the source operand and stores the difference in the destination location.
		The destination operand is always an FPU register; the source operand can be a register or a memory location.
		Source operands in memory can be in single-precision or double-precision floating-point format or in word or
		doubleword integer format.
		
		These instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided
		to support more efficient coding.
		
		The no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and
		stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents
		of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand
		version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.
		The FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtrac-
		tion. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer
		(TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register
		stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.
		The FISUBR instructions convert an integer source operand to double extended-precision floating-point format
		before performing the subtraction.
		
		When the difference between two operands of like sign is 0, the result is +0, except for the round toward -infinity mode,
		in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the
		source operand is an integer 0, it is treated as a +0.
		When one operand is infinity, the result is infinity of the expected sign. If both operands are infinity of the same sign, an invalid-
		operation exception is generated.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


ftst=Compare ST(0) with 0.0
	forms

	description
		Compares the value in the ST(0) register with 0.0 and sets the condition code flags C0, C2, and C3 in the FPU
		status word according to the results.
		
		This instruction performs an "unordered comparison." An unordered comparison also checks the class of the
		numbers being compared. If the value in register ST(0) is a NaN or is in an undefined format, 
		the condition flags are set to "unordered" and the invalid operation exception is generated.
		The sign of zero is ignored, so that (-0.0 == +0.0).
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fucom/fucomp/fucompp=Unordered Compare Floating Point Values 
	forms

	description
		Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2,
		and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the
		contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that -0.0 is equal to +0.0.
		
		An unordered comparison checks the class of the numbers being compared.
		The FUCOM/FUCOMP/FUCOMPP instructions perform the same operations as the FCOM/FCOMP/FCOMPP instructions. 
		The only difference is that the FUCOM/FUCOMP/FUCOMPP instructions raise the invalid-arithmetic-
		operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format; QNaNs
		cause the condition code flags to be set to unordered, but do not cause an exception to be generated. The
		FCOM/FCOMP/FCOMPP instructions raise an invalid-operation exception when either or both of the operands are a
		NaN value of any kind or are in an unsupported format.
		
		As with the FCOM/FCOMP/FCOMPP instructions, if the operation results in an invalid-arithmetic-operand exception
		being raised, the condition code flags are set only if the exception is masked.
		
		The FUCOMP instruction pops the register stack following the comparison operation and the FUCOMPP instruction
		pops the register stack twice following the comparison operation. To pop the register stack, the processor marks
		the ST(0) register as empty and increments the stack pointer (TOP) by 1.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fxam=Examine ModR/M 
	forms

	description
		Examines the contents of the ST(0) register and sets the condition code flags C0, C2, and C3 in the FPU status word
		to indicate the class of value or number in the register.
		
		The C1 flag is set to the sign of the value in ST(0), regardless of whether the register is empty or full.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fxch=Exchange Register Contents 
	forms

	description
		Exchanges the contents of registers ST(0) and ST(i). If no source operand is specified, the contents of ST(0) and ST(1) are exchanged.
		
		This instruction provides a simple means of moving values in the FPU register stack to the top of the stack [ST(0)],
		so that they can be operated on by those floating-point instructions that can only operate on values in ST(0). For
		example, the following instruction sequence takes the square root of the third register from the top of the register stack:
		
		FXCH ST(3);
		FSQRT;
		FXCH ST(3);
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fxrstor=Restore x87 FPU, MMX, XMM, and MXCSR State 
	forms

	description
		Reloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in
		the source operand. This data should have been written to memory previously using the FXSAVE instruction, and
		in the same format as required by the operating modes. The first byte of the data should be located on a 16-byte
		boundary. There are three distinct layouts of the FXSAVE state map: one for legacy and compatibility mode, a
		second format for 64-bit mode FXSAVE/FXRSTOR with REX.W=0, and the third format is for 64-bit mode with
		FXSAVE64/FXRSTOR64.
		
		The state image referenced with an FXRSTOR instruction must have been saved using an FXSAVE instruction or be
		in the same format.
		Referencing a state image saved with an FSAVE, FNSAVE instruction or incompatible field layout will result in an incorrect state restoration.
		
		The FXRSTOR instruction does not flush pending x87 FPU exceptions. To check and raise exceptions when loading
		x87 FPU state information with the FXRSTOR instruction, use an FWAIT instruction after the FXRSTOR instruction.
		If the OSFXSR bit in control register CR4 is not set, the FXRSTOR instruction may not restore the states of the XMM
		and MXCSR registers. This behavior is implementation dependent.
		
		If the MXCSR state contains an unmasked exception with a corresponding status flag also set, loading the register
		with the FXRSTOR instruction will not result in a SIMD floating-point error condition being generated. Only the next
		occurrence of this unmasked exception will result in the exception being generated.
		
		Bits 16 through 32 of the MXCSR register are defined as reserved and should be set to 0. Attempting to write a 1
		in any of these bits from the saved state image will result in a general protection exception (#GP) being generated.
		Bytes 464:511 of an FXSAVE image are available for software use. FXRSTOR ignores the content of bytes 464:511
		in an FXSAVE state image.

	exceptions

	flags

	operation

	meta


fxsave=Save x87 FPU, MMX Technology, and SSE State 
	forms

	description
		Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory location 
		specified in the destination operand. The content layout of the 512 byte region depends on whether the
		processor is operating in non-64-bit operating modes or 64-bit sub-mode of IA-32e mode.

	exceptions

	flags

	operation

	meta


fxtract=Extract Exponent and Significand 
	forms

	description
		Separates the source value in the ST(0) register into its exponent and significand, stores the exponent in ST(0),
		and pushes the significand onto the register stack. Following this operation, the new top-of-stack register ST(0)
		contains the value of the original significand expressed as a floating-point value. The sign and significand of this
		value are the same as those found in the source operand, and the exponent is 3FFFH (biased value for a true exponent of zero).
		The ST(1) register contains the value of the original operand's true (unbiased) exponent expressed as a floating-point value.
		(The operation performed by this instruction is a superset of the IEEE-recommended logb(x) function.)
		
		This instruction and the F2XM1 instruction are useful for performing power and range scaling operations. The
		FXTRACT instruction is also useful for converting numbers in double extended-precision floating-point format to
		decimal representations (e.g., for printing or displaying).
		
		If the floating-point zero-divide exception (#Z) is masked and the source operand is zero, 
		an exponent value of -infinity is stored in register ST(1) and 0 with the sign of the source operand is stored in register ST(0).
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fyl2x=Compute y * log2(x )
	forms

	description
		Computes (ST(1) * log2 (ST(0))), stores the result in resister ST(1), and pops the FPU register stack. The source
		operand in ST(0) must be a non-zero positive number.
		If the divide-by-zero exception is masked and register ST(0) contains +-0, the instruction returns infinity with a sign that
		is the opposite of the sign of the source operand in register ST(1).
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


fyl2xp1=Compute y * log2(x + 1) 
	forms

	description
		Computes (ST(1) * log2(ST(0) + 1.0)), stores the result in register ST(1), and pops the FPU register stack. The
		source operand in ST(0) must be in the range -( 1 - sqrt(2) / 2 ) ) to ( 1 - sqrt(2) / 2 )
		The source operand in ST(1) can range from -infinity to +infinity. If the ST(0) operand is outside of its acceptable range, the
		result is undefined and software should not rely on an exception being generated. Under some circumstances
		exceptions may be generated when ST(0) is out of range, but this behavior is implementation specific and not guaranteed.
		
		This instruction provides optimal accuracy for values of epsilon [the value in register ST(0)] that are close to 0. For
		small epsilon values, more significant digits can be retained by using the FYL2XP1 instruction than by using
		(epsilon+1) as an argument to the FYL2X instruction. The (epsilon+1) expression is commonly found in compound interest and
		annuity calculations. The result can be simply converted into a value in another logarithm base by including a scale
		factor in the ST(1) source operand.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


haddpd/vhaddpd=Packed Double-FP Horizontal Add 
	forms

	description
		Adds the double-precision floating-point values in the high and low quadwords of the destination operand and
		stores the result in the low quadword of the destination operand.
		
		Then adds the double-precision floating-point values in the high and low quadwords of the source operand and stores the
		result in the high quadword of the destination operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


haddps/vhaddps=Packed Single-FP Horizontal Add 
	forms

	description
		Adds the single-precision floating-point values in the first and second dwords of the destination operand and stores
		the result in the first dword of the destination operand.
		
		Adds single-precision floating-point values in the third and fourth dword of the destination operand and stores the
		result in the second dword of the destination operand.
		
		Adds single-precision floating-point values in the first and second dword of the source operand and stores the
		result in the third dword of the destination operand.
		
		Adds single-precision floating-point values in the third and fourth dword of the source operand and stores the
		result in the fourth dword of the destination operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


hlt=Halt 
	forms

	description
		Stops instruction execution and places the processor in a HALT state. An enabled interrupt (including NMI and
		SMI), a debug exception, the BINIT# signal, the INIT# signal, or the RESET# signal will resume execution. If an
		interrupt (including NMI) is used to resume execution after a HLT instruction, the saved instruction pointer
		(CS:EIP) points to the instruction following the HLT instruction.
		
		When a HLT instruction is executed on an Intel 64 or IA-32 processor supporting Intel Hyper-Threading Technology,
		only the logical processor that executes the instruction is halted. The other logical processors in the physical
		processor remain active, unless they are each individually halted by executing a HLT instruction.
		
		The HLT instruction is a privileged instruction. When the processor is running in protected or virtual-8086 mode,
		the privilege level of a program or procedure must be 0 to execute the HLT instruction.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


hsubpd/vhsubpd=Packed Double-FP Horizontal Subtract 
	forms

	description
		The HSUBPD instruction subtracts horizontally the packed double-precision FP numbers of both operands.
		Subtracts the double-precision floating-point value in the high quadword of the destination operand from the low
		quadword of the destination operand and stores the result in the low quadword of the destination operand.
		Subtracts the double-precision floating-point value in the high quadword of the source operand from the low quad-
		word of the source operand and stores the result in the high quadword of the destination operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


hsubps/vhsubps=Packed Single-FP Horizontal Subtract 
	forms

	description
		Subtracts the single-precision floating-point value in the second dword of the destination operand from the first
		dword of the destination operand and stores the result in the first dword of the destination operand.
		
		Subtracts the single-precision floating-point value in the fourth dword of the destination operand from the third
		dword of the destination operand and stores the result in the second dword of the destination operand.
		
		Subtracts the single-precision floating-point value in the second dword of the source operand from the first dword
		of the source operand and stores the result in the third dword of the destination operand.
		
		Subtracts the single-precision floating-point value in the fourth dword of the source operand from the third dword
		of the source operand and stores the result in the fourth dword of the destination operand.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		
		128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
		nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
		YMM register destination are unmodified.
		
		VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
		operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
		zeroed.
		
		VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
		register or a 256-bit memory location. The destination operand is a YMM register.

	exceptions

	flags

	operation

	meta


idiv=Signed Divide 
	forms

	description
		Divides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by the source operand (divisor) and stores the
		result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a
		memory location. The action of this instruction depends on the operand size (dividend/divisor).
		
		Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magni-
		tude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15).
		Use of the REX.W prefix promotes operation to 64 bits.
		In 64-bit mode when REX.W is applied, the instruction divides the signed value in RDX:RAX by the source operand.
		RAX contains a 64-bit quotient; RDX contains a 64-bit remainder.

	exceptions

	flags

	operation

	meta


imul=Signed Multiply 
	forms

	description
		Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of operands.
		
		~One-operand form
			This form is identical to that used by the MUL instruction. Here, the source operand (in
			a general-purpose register or memory location) is multiplied by the value in the AL, AX, EAX, or RAX register
			(depending on the operand size) and the product (twice the size of the input operand) is stored in the AX,
			DX:AX, EDX:EAX, or RDX:RAX registers, respectively.
		
		~Two-operand form
			With this form the destination operand (the first operand) is multiplied by the source
			operand (second operand). The destination operand is a general-purpose register and the source operand is an
			immediate value, a general-purpose register, or a memory location. The intermediate product (twice the size of
			the input operand) is truncated and stored in the destination operand location.
		
		~Three-operand form
			This form requires a destination operand (the first operand) and two source operands
			(the second and the third operands). Here, the first source operand (which can be a general-purpose register
			or a memory location) is multiplied by the second source operand (an immediate value). The intermediate
			product (twice the size of the first source operand) is truncated and stored in the destination operand (a general-purpose register).
		
		When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.
		The CF and OF flags are set when the signed integer value of the intermediate product differs from the sign
		extended operand-size-truncated product, otherwise the CF and OF flags are cleared.
		The three forms of the IMUL instruction are similar in that the length of the product is calculated to twice the length
		of the operands. With the one-operand form, the product is stored exactly in the destination. With the two- and
		three- operand forms, however, the result is truncated to the length of the destination before it is stored in the
		destination register. Because of this truncation, the CF or OF flag should be tested to ensure that no significant bits
		are lost.
		The two- and three-operand forms may also be used with unsigned operands because the lower half of the product
		is the same regardless if the operands are signed or unsigned. The CF and OF flags, however, cannot be used to
		determine if the upper half of the result is non-zero.
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
		tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. Use of REX.W modifies the three
		forms of the instruction as follows:
		
		~One-operand form
			The source operand (in a 64-bit general-purpose register or memory location) is
			multiplied by the value in the RAX register and the product is stored in the RDX:RAX registers.
		
		~Two-operand form
			The source operand is promoted to 64 bits if it is a register or a memory location. The
			destination operand is promoted to 64 bits.
		
		~Three-operand form
			The first source operand (either a register or a memory location) and destination
			operand are promoted to 64 bits. If the source operand is an immediate, it is sign extended to 64 bits.

	exceptions

	flags

	operation

	meta


in=Input from Port 
	forms

	description
		Copies the value from the I/O port specified with the second operand (source operand) to the destination operand
		(first operand). The source operand can be a byte-immediate or the DX register; the destination operand can be
		register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively).
		Using the DX register as a source operand allows I/O port addresses from 0 to 65,535 to be accessed; 
		using a byte immediate allows I/O port addresses 0 to 255 to be accessed.
		
		When accessing an 8-bit I/O port, the opcode determines the port size; when accessing a 16- and 32-bit I/O port,
		the operand-size attribute determines the port size. At the machine code level, I/O instructions are shorter when
		accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.
		
		This instruction is only useful for accessing I/O ports located in the processor's I/O address space.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta
		see
			Chapter 1 - "Input/Output", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


inc=Increment by 1 
	forms

	description
		Adds 1 to the destination operand, while preserving the state of the CF flag. The destination operand can be a
		register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag.
		(Use a ADD instruction with an immediate operand of 1 to perform an increment operation that does updates the CF flag.)
		
		This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
		In 64-bit mode, INC r16 and INC r32 are not encodable (because opcodes 40H through 47H are REX prefixes).
		Otherwise, the instruction's 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to
		additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.

	exceptions

	flags

	operation

	meta


ins/insb/insw/insd=Input from Port to String 
	forms

	description
		Copies the data from the I/O port specified with the source operand (second operand) to the destination operand
		(first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The
		destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI
		registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment
		cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of
		the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute 
		of the instruction for a 16- or 32-bit I/O port.
		
		At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
		operands" form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination
		operands to be specified explicitly. Here, the source operand must be "DX," and the destination operand should be
		a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided
		to allow documentation; however, note that the documentation provided by this form can be misleading. That is,
		the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword),
		but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers,
		which must be loaded correctly before the INS instruction is executed.
		
		The no-operands form provides "short forms" of the byte, word, and doubleword versions of the INS instructions.
		Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination
		operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD (doubleword).
		
		After the byte, word, or doubleword is transfer from the I/O port to the memory location, the DI/EDI/RDI register
		is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the
		DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI
		register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword
		operations.
		
		The INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words,
		or doublewords. See "REP/REPE/REPZ /REPNE/REPNZ-Repeat String Operation Prefix" in Chapter 4 of the Intel
		64 and IA-32 Architectures Software Developer's Manual, Volume 2B, for a description of the REP prefix.
		These instructions are only useful for accessing I/O ports located in the processor's I/O address space.
		In 64-bit mode, default address size is 64 bits, 32 bit address size is supported using the prefix 67H. The address
		of the memory destination is specified by RDI or EDI. 16-bit address size is not supported in 64-bit mode. The
		operand size is not promoted.

	exceptions

	flags

	operation

	meta
		see
			Chapter 16 - "Input/Output", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1

insertps/vinsertps=Insert Packed Single Precision Floating-Point Value 
	forms

	description
		~Register source form
			Select a single precision floating-point element from second source as indicated by Count_S bits of the immediate
			operand and insert it into the first source at the location indicated by the Count_D bits of the immediate operand.
			Store in the destination and zero out destination elements based on the ZMask bits of the immediate operand.
		
		~Memory source form
			Load a floating-point element from a 32-bit memory location and insert it into the first source at the location indi-
			cated by the Count_D bits of the immediate operand. Store in the destination and zero out destination elements
			based on the ZMask bits of the immediate operand.
			
			128-bit Legacy SSE version: The first source register is an XMM register. The second source operand is either an
			XMM register or a 32-bit memory location. The destination is not distinct from the first source XMM register and the
			upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.
			VEX.128 encoded version. The destination and first source register is an XMM register. The second source operand
			is either an XMM register or a 32-bit memory location. The upper bits (VLMAX-1:128) of the corresponding YMM
			register destination are zeroed.
			
			If VINSERTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause
			an #UD exception.

	exceptions

	flags

	operation

	meta


int n/into/int 3=Call to Interrupt Procedure 
	forms

	description
		The INT n instruction generates a call to the interrupt or exception handler specified with the destination operand.
		The destination operand specifies a vector from 0 to 255, encoded as an 8-bit
		unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vectors are
		reserved by Intel for system use. Some of these vectors are used for internally generated exceptions.
		
		The INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The
		INTO instruction is a special mnemonic for calling overflow exception (#OF), exception 4. The overflow interrupt
		checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The
		INTO instruction cannot be used in 64-bit mode.)
		
		The INT 3 instruction generates a special one byte opcode (CC) that is intended for calling the debug exception
		handler. (This one byte form is valuable because it can be used to replace the first byte of any instruction with a
		breakpoint, including other one byte instructions, without over-writing other code). To further support its function
		as a debug breakpoint, the interrupt generated with the CC opcode also differs from the regular software interrupts
		as follows:
		
		- Interrupt redirection does not happen when in VME mode; the interrupt is handled by a protected-mode handler.
		- The virtual-8086 mode IOPL checks do not occur. The interrupt is taken without faulting at any IOPL level.
		
		Note that the "normal" 2-byte opcode for INT 3 (CD03) does not have these special features. Intel and Microsoft
		assemblers will not generate the CD03 opcode from any mnemonic, but this opcode can be created by direct
		numeric code definition or by self-modifying code.
		
		The action of the INT n instruction (including the INTO and INT 3 instructions) is similar to that of a far call made
		with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed
		onto the stack before the return address. (The return address is a far address consisting of the current values of
		the CS and EIP registers.) Returns from interrupt procedures are handled with the IRET instruction, which pops the
		EFLAGS information and return address from the stack.
		
		The vector specifies an interrupt descriptor in the interrupt descriptor table (IDT); that is, it provides index into the
		IDT. The selected interrupt descriptor in turn contains a pointer to an interrupt or exception handler procedure.
		In protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate,
		or task gate. In real-address mode, the IDT is an array of 4-byte far pointers (2-byte code segment selector and
		a 2-byte instruction pointer), each of which point directly to a procedure in the selected segment. (Note that in
		real-address mode, the IDT is called the interrupt vector table, and its pointers are called interrupt vectors.)
		
		When the processor is executing in virtual-8086 mode, the IOPL determines the action of the INT n instruction. If
		the IOPL is less than 3, the processor generates a #GP(selector) exception; if the IOPL is 3, the processor executes
		a protected mode interrupt to privilege level 0. The interrupt gate's DPL must be set to 3 and the target CPL of the
		interrupt handler procedure must be 0 to execute the protected mode interrupt to privilege level 0.
		
		The interrupt descriptor table register (IDTR) specifies the base linear address and limit of the IDT. The initial base
		address value of the IDTR after the processor is powered up or reset is 0.

	exceptions

	flags

	operation

	meta
		see
			Chapter 6 - "Interrupts and Exceptions", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


invd=Invalidate Internal Caches 
	forms

	description
		Invalidates (flushes) the processor's internal caches and issues a special-function bus cycle that directs external
		caches to also flush themselves. Data held in internal caches is not written back to main memory.
		After executing this instruction, the processor does not wait for the external caches to complete their flushing operation
		before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache flush signal.
		
		The INVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a
		program or procedure must be 0 to execute this instruction.
		
		The INVD instruction may be used when the cache is used as temporary memory and the cache contents need to
		be invalidated rather than written back to memory. When the cache is used as temporary memory, no external
		device should be actively writing data to main memory.
		
		Use this instruction with care. Data cached internally and not written back to main memory will be lost. Note that
		any data from an external device to main memory (for example, via a PCIWrite) can be temporarily stored in the
		caches; these data can be lost when an INVD instruction is executed. Unless there is a specific requirement or
		benefit to flushing caches without writing back modified cache lines (for example, temporary memory, testing, or
		fault recovery where cache coherency with main memory is not a concern), software should instead use the WBINVD instruction.
		
		The INVD instruction is implementation dependent; it may be implemented differently on different families of Intel
		64 or IA-32 processors. This instruction is not supported on IA-32 processors earlier than the Intel 486 processor.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta


invlpg=Invalidate TLB Entries 
	forms

	description
		Invalidates any translation lookaside buffer (TLB) entries specified with the source operand. The source operand is
		a memory address. The processor determines the page that contains that address and flushes all TLB entries for that page.
		
		The INVLPG instruction is a privileged instruction. When the processor is running in protected mode, the CPL must
		be 0 to execute this instruction.
		
		The INVLPG instruction normally flushes TLB entries only for the specified page; however, in some cases, it may
		flush more entries, even the entire TLB. The instruction is guaranteed to invalidates only TLB entries associated
		with the current PCID. (If PCIDs are disabled - CR4.PCIDE = 0 - the current PCID is 000H.) The instruction also
		invalidates any global TLB entries for the specified page, regardless of PCID.
		
		This instruction's operation is the same in all non-64-bit modes. It also operates the same in 64-bit mode, except
		if the memory address is in non-canonical form. In this case, INVLPG is the same as a NOP.

	exceptions

	flags

	operation

	meta


invpcid=Invalidate Process-Context Identifier 
	forms

	description
		Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on process-
		context identifier (PCID). (See Section 4.10, "Caching Translation Information," in Intel 64 and IA-32 Architecture
		Software Developer's Manual, Volume 3A.) Invalidation is based on the INVPCID type specified in the register
		operand and the INVPCID descriptor specified in the memory operand.
		Outside 64-bit mode, the register operand is always 32 bits, regardless of the value of CS.D.
		In 64-bit mode the register operand has 64 bits.
		
		There are four INVPCID types currently defined:
		
		- Individual-address invalidation: If the INVPCID type is 0, the logical processor invalidates mappings, except
		global translations, for the linear address and PCID specified in the INVPCID descriptor. 1 In some cases, the
		instruction may invalidate global translations or mappings for other linear addresses (or other PCIDs) as well.
		
		- Single-context invalidation: If the INVPCID type is 1, the logical processor invalidates all mappings, except
		global translations, associated with the PCID specified in the INVPCID descriptor. In some cases, the
		instruction may invalidate global translations or mappings for other PCIDs as well.
		
		- All-context invalidation, including global translations: If the INVPCID type is 2, the logical processor invalidates
		all mappings, including global translations, associated with any PCID.
		
		- All-context invalidation: If the INVPCID type is 3, the logical processor invalidates all mappings, except global
		translations, associated with any PCID. In some case, the instruction may invalidate global translations as
		well.
		
		For INVPCID type 0, the processor uses the full 64 bits of the linear address even outside 64-bit mode; the linear
		address is not used for other INVPCID types.

	exceptions

	flags

	operation

	meta


iret/iretd/iretq=Interrupt Return
	forms

	description
		Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by
		an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform
		a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or
		when an interrupt or exception causes a task switch to an interrupt or exception handler.)
		
		IRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended
		for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the
		IRET mnemonic interchangeably for both operand sizes.
		
		In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During
		this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image
		from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted
		program or procedure.
		
		In Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags
		in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting
		of these flags, the processor performs the following types of interrupt returns:
		
		- Return from virtual-8086 mode.
		- Return to virtual-8086 mode.
		- Intra-privilege level return.
		- Inter-privilege level return.
		- Return from nested task (task switch).
		
		If the NT flag (EFLAGS register) is cleared, the IRET instruction performs a far return from the interrupt procedure,
		without a task switch. The code segment being returned to must be equally or less privileged than the interrupt
		handler routine (as indicated by the RPL field of the code segment selector popped from the stack).
		
		As with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code
		segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then
		resumes execution of the interrupted program or procedure. If the return is to another privilege level, the IRET
		instruction also pops the stack pointer and SS from the stack, before resuming program execution. If the return is
		to virtual-8086 mode, the processor also pops the data segment registers from the stack.
		
		If the NT flag is set, the IRET instruction performs a task switch (return) from a nested task (a task called with a
		CALL instruction, an interrupt, or an exception) back to the calling or interrupted task. The updated state of the
		task executing the IRET instruction is saved in its TSS. If the task is re-entered later, the code that follows the IRET
		instruction is executed.
		
		If the NT flag is set and the processor is in IA-32e mode, the IRET instruction causes a general protection exception.
		If nonmaskable interrupts (NMIs) are blocked, execution of the IRET instruction unblocks NMIs.
		This unblocking occurs even if the instruction causes a fault. In such a case, NMIs are unmasked before the exception handler is invoked.
		In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.W prefix promotes operation to 64-bits (IRETQ).

	exceptions

	flags

	operation

	meta
		see
			Chapter 7 - "Task Linking", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A
			Section 6.7.1 - "Handling Multiple NMIs", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A
			Chapter 25 - "Changes to Instruction Behavior in VMX Non-Root Operation", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3C


ja=Jump if above (CF = 0 and ZF = 0)
jae=Jump if above or equal (CF = 0)
jb=Jump if below (CF = 1)
jbe=Jump if below or equal (CF = 1 or ZF = 1)
jc=Jump if carry (CF = 1)
jcxz=Jump if CX register is 0
jecxz=Jump if the ECX register is 0
jrcxz=Jump if the RCX register is 0
je=Jump if equal (ZF = 1)
jg=Jump if greater (ZF = 0 and SF = OF)
jge=Jump if greater or equal (SF = OF)
jl=Jump if less (SF != OF)
jle=Jump if less or equal (ZF = 1 or SF != OF)
jna=Jump if not above(CF = 1 or ZF = 1)
jnae=Jump if not above or equal (CF = 1)
jnb=Jump if not below (CF = 0)
jnbe=Jump if not below or equal (CF = 0 and ZF = 0)
jnc=Jump if not carry (CF = 0)
jne=Jump if not equal (ZF = 0)
jng=Jump if not greater (ZF = 1 or SF != OF)
jnge=Jump if not greater or equal (SF != OF)
jnl=Jump if not less (SF = 0F)
jnle=Jump if not less or equal (ZF = 0 and SF = OF)
jno=Jump if not overflow (OF = 0)
jnp=Jump if not parity (PF = 0)
jns=Jump if not sign (SF = 0)
jnz=Jump if not zero (ZF = 0)
jo=Jump if overflow (OF = 1)
jp=Jump if parity (PF = 1)
jpe=Jump if parity even (PF = 1)
jpo=Jump if parity odd (PF = 0)
js=Jump if sign (SF = 1)
jz=Jump if zero (ZF = 1)
jcc=Conditional jumps (group)
	forms

	description
		Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
		are in the specified state (condition), performs a jump to the target instruction specified by the destination
		operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
		condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.
		The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). 
		A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
		
		code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
		the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
		is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
		The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
		terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for unsigned integers.
		
		Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
		defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
		equal) instruction are alternate mnemonics for the opcode 77H.
		
		The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
		jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
		and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
		following conditional far jump is illegal:
		
		JZ FARLABEL;
		
		To accomplish this far jump, use the following two instructions:
		
		JNZ BEYOND;
		JMP FARLABEL;
		BEYOND:
		
		The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
		Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
		instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
		(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
		is 0. This would cause the loop to execute 2^^64 , 2^^32 or 2^^16 times (not zero times).
		
		All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cacheability.
		
		In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits.
		JMP Near is RIP = RIP + 32-bit offset sign extended to 64-bits.

	exceptions

	flags

	operation

	meta


jmp=Unconditional jump 
	forms

	description
		Transfers program control to a different point in the instruction stream without recording return information. The
		destination (target) operand specifies the address of the instruction being jumped to. This operand can be an
		immediate value, a general-purpose register, or a memory location.
		This instruction can be used to execute four different types of jumps:
		
		- Near jump: A jump to an instruction within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment jump.
		
		- Short jump: A near jump where the jump range is limited to -128 to +127 from the current EIP value.
		
		- Far jump: A jump to an instruction located in a different segment than the current code segment but at the same privilege level, sometimes referred to as an intersegment jump.
		
		- Task switch: A jump to an instruction located in a different task.
		
		A task switch can only be executed in protected mode (see Chapter 7, in the Intel 64 and IA-32 Architectures
		Software Developer's Manual, Volume 3A, for information on performing task switches with the JMP instruction).
		
		~Near and Short Jumps
			When executing a near jump, the processor jumps to the address (within the current code
			segment) that is specified with the target operand. The target operand specifies either an absolute offset (that is
			an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current
			value of the instruction pointer in the EIP register). A near jump to a relative offset of 8-bits (rel8) is referred to as
			a short jump. The CS register is not changed on near and short jumps.
			An absolute offset is specified indirectly in a general-purpose register or a memory location (r/m16 or r/m32). The
			operand-size attribute determines the size of the target operand (16 or 32 bits). Absolute offsets are loaded
			directly into the EIP register. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared,
			resulting in a maximum instruction pointer size of 16 bits.
			A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code
			level, it is encoded as a signed 8-, 16-, or 32-bit immediate value. This value is added to the value in the EIP
			register. (Here, the EIP register contains the address of the instruction following the JMP instruction). When using
			relative offsets, the opcode (for short vs. near jumps) and the operand-size attribute (for near relative jumps)
			determines the size of the target operand (8, 16, or 32 bits).
		
		~Far Jumps in Real-Address or Virtual-8086 Mode
			When executing a far jump in real-address or virtual-8086 mode, the processor jumps to the code segment and offset specified with the target operand.
			Here the target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory
			location (m16:16 or m16:32). With the pointer method, the segment and address of the called procedure is
			encoded in the instruction, using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate. 
			With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size)
			or 6-byte (32-bit operand size) far address. The far address is loaded directly into the CS and EIP registers.
			If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.
		
		~Far Jumps in Protected Mode
			When the processor is operating in protected mode, the JMP instruction can be used to perform the following three types of far jumps:
			
			- A far jump to a conforming or non-conforming code segment.
			- A far jump through a call gate.
			- A task switch.
			
			(The JMP instruction cannot be used to perform inter-privilege-level far jumps.)
			In protected mode, the processor always uses the segment selector part of the far address to access the corre-
			sponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access
			rights determine the type of jump to be performed.
			
			If the selected descriptor is for a code segment, a far jump to a code segment at the same privilege level is
			performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming,
			a general-protection exception is generated.) A far jump to the same privilege level in protected mode is very
			similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far
			address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or
			m16:32). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new
			code segment selector and its descriptor are loaded into CS register, and the offset from the instruction is loaded
			into the EIP register. Note that a call gate (described in the next paragraph) can also be used to perform far call to
			a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the
			preferred method of making jumps between 16-bit and 32-bit code segments.
			
			When executing a far jump through a call gate, the segment selector specified by the target operand identifies the
			call gate. (The offset part of the target operand is ignored.) The processor then jumps to the code segment speci-
			fied in the call gate descriptor and begins executing the instruction at the offset specified in the call gate. No stack
			switch occurs. Here again, the target operand can specify the far address of the call gate either directly with a
			pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32).
			
			Executing a task switch with the JMP instruction is somewhat similar to executing a jump through a call gate. Here
			the target operand specifies the segment selector of the task gate for the task being switched to (and the offset
			part of the target operand is ignored). The task gate in turn points to the TSS for the task, which contains the
			segment selectors for the task's code and stack segments. The TSS also contains the EIP value for the next instruc-
			tion that was to be executed before the task was suspended. This instruction pointer value is loaded into the EIP
			register so that the task begins executing again at this next instruction.
			
			The JMP instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the
			task gate.
			
			Note that when you execute at task switch with a JMP instruction, the nested task flag (NT) is not set in the EFLAGS
			register and the new TSS's previous task link field is not loaded with the old task's TSS selector. A return to the
			previous task can thus not be carried out by executing the IRET instruction. Switching tasks with the JMP instruc-
			tion differs in this regard from the CALL instruction which does set the NT flag and save the previous task link infor-
			mation, allowing a return to the calling task with an IRET instruction.
		
		In 64-Bit Mode the instruction's operation size is fixed at 64 bits. If a selector points to a gate, then RIP equals
		the 64-bit displacement taken from gate; else RIP equals the zero-extended offset from the far pointer referenced
		in the instruction.

	exceptions

	flags

	operation

	meta
		see
			Chapter 7 - "Task Switching", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A


lahf=Load Status Flags into AH Register 
	forms

	description
		Load: AH = EFLAGS(SF:ZF:0:AF:0:PF:1:CF)
		
		This instruction executes as described in compatibility mode and legacy mode. It is valid in 64-bit mode only
		if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1.

	exceptions

	flags

	operation

	meta


lar=Load Access Rights Byte 
	forms

	description
		Loads the access rights from the segment descriptor specified by the second operand (source operand) into the
		first operand (destination operand) and sets the ZF flag in the flag register. The source operand (which can be a
		register or a memory location) contains the segment selector for the segment descriptor being accessed. If the
		source operand is a memory address, only 16 bits of data are accessed. The destination operand is a general-
		purpose register.
		
		The processor performs access checks as part of the loading process. Once loaded in the destination register, soft-
		ware can perform additional checks on the access rights information.
		
		The access rights for a segment descriptor include fields located in the second doubleword (bytes 4-7) of the
		segment descriptor. The following fields are loaded by the LAR instruction:
		
		-Bits 7:0 are returned as 0
		-Bits 11:8 return the segment type.
		-Bit 12 returns the S flag.
		-Bits 14:13 return the DPL.
		-Bit 15 returns the P flag.
		-The following fields are returned only if the operand size is greater than 16 bits:
		-- Bits 19:16 are undefined.
		-- Bit 20 returns the software-available bit in the descriptor.
		-- Bit 21 returns the L flag.
		-- Bit 22 returns the D/B flag.
		-- Bit 23 returns the G flag.
		-- Bits 31:24 are returned as 0.
		
		This instruction performs the following checks before it loads the access rights in the destination register:
		
		- Checks that the segment selector is not NULL.
		- Checks that the segment selector points to a descriptor that is within the limits of the GDT or LDT being accessed
		- Checks that the descriptor type is valid for this instruction. All code and data segment descriptors are valid for
		(can be accessed with) the LAR instruction.
		- If the segment is not a conforming code segment, it checks that the specified segment descriptor is visible at
		the CPL (that is, if the CPL and the RPL of the segment selector are less than or equal to the DPL of the segment
		selector).
		
		If the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no
		access rights are loaded in the destination operand.
		
		The LAR instruction can only be executed in protected mode and IA-32e mode.

	exceptions

	flags

	operation

	meta


lddqu/vlddqu=Load Unaligned Integer 128 Bits
	forms

	description
		The instruction is functionally similar to (V)MOVDQU ymm/xmm, m256/m128 for loading from memory. That is:
		32/16 bytes of data starting at an address specified by the source memory operand (second operand) are fetched
		from memory and placed in a destination register (first operand). The source operand need not be aligned on a
		32/16-byte boundary. Up to 64/32 bytes may be loaded from memory; this is implementation dependent.
		This instruction may improve performance relative to (V)MOVDQU if the source operand crosses a cache line
		boundary. In situations that require the data loaded by (V)LDDQU be modified and stored to the same location, use
		(V)MOVDQU or (V)MOVDQA instead of (V)LDDQU. To move a double quadword to or from memory locations that
		are known to be aligned on 16-byte boundaries, use the (V)MOVDQA instruction.
		
		If the source is aligned to a 32/16-byte boundary, based on the implementation, the 32/16 bytes may be
		loaded more than once. For that reason, the usage of (V)LDDQU should be avoided when using uncached or
		write-combining (WC) memory regions. For uncached or WC memory regions, keep using (V)MOVDQU.
		
		This instruction is a replacement for (V)MOVDQU (load) in situations where cache line splits significantly affect
		performance. It should not be used in situations where store-load forwarding is performance critical. If
		performance of store-load forwarding is critical to the application, use (V)MOVDQA store-load pairs when data
		is 256/128-bit aligned or (V)MOVDQU store-load pairs when data is 256/128-bit unaligned.
		
		If the memory address is not aligned on 32/16-byte boundary, some implementations may load up to 64/32
		bytes and return 32/16 bytes in the destination. Some processor implementations may issue multiple loads to
		access the appropriate 32/16 bytes. Developers of multi-threaded or multi-processor software should be aware
		that on these processors the loads will be performed in a non-atomic way.
		
		If alignment checking is enabled (CR0.AM = 1, RFLAGS.AC = 1, and CPL = 3), an alignment-check exception
		(#AC) may or may not be generated (depending on processor implementation) when the memory address is
		not aligned on an 8-byte boundary.
		
		In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.

	exceptions

	flags

	operation

	meta


ldmxcsr/vldmxcsr=Load MXCSR Register 
	forms

	description
		Loads the source operand into the MXCSR control/status register. The source operand is a 32-bit memory location.
		The LDMXCSR instruction is typically used in conjunction with the (V)STMXCSR instruction, which stores the contents of the MXCSR register in memory.
		
		The default MXCSR value at reset is 1F80H.
		
		If a (V)LDMXCSR instruction clears a SIMD floating-point exception mask bit and sets the corresponding exception
		flag bit, a SIMD floating-point exception will not be immediately generated. The exception will be generated only
		upon the execution of the next instruction that meets both conditions below:
		
		- the instruction must operate on an XMM or YMM register operand,
		- the instruction causes that particular SIMD floating-point exception to be reported.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.
		If VLDMXCSR is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.
		
		Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.

	exceptions

	flags

	operation
		MXCSR = m32

	meta
		see
			Chapter 10 - "MXCSR Control and Status Register", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1


lds/les/lfs/lgs/lss=Load Far Pointer 
	forms

	description
		Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment
		register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in
		memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The
		instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-
		bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS,
		SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.
		If one of these instructions is executed in protected mode, additional information from the segment descriptor
		pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment register.
		
		Also in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers
		without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment
		register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to
		the segment occurs.)
		
		In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes
		operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory.
		Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15).

	exceptions

	flags

	operation

	meta


lea=Load Effective Address 
	forms

	description
		Computes the effective address of the second operand (the source operand) and stores it in the first operand
		(destination operand). The source operand is a memory address (offset part) specified with one of the processors
		addressing modes; the destination operand is a general-purpose register. The address-size and operand-size attributes 
		affect the action performed by this instruction. The operand-size attribute of the instruction is determined by the chosen register; 
		the address-size attribute is determined by the attribute of the code segment.
		
		Different assemblers may use different algorithms based on the size attribute and symbolic reference of the source
		operand.
		
		In 64-bit mode, the instruction's destination operand is governed by operand size attribute, the default operand
		size is 32 bits. Address calculation is governed by address size attribute, the default address size is 64-bits. In 64-
		bit mode, address size of 16 bits is not encodable.

	exceptions

	flags

	operation

	meta


leave=High Level Procedure Exit 
	forms

	description
		Releases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction copies the frame pointer (in
		the EBP register) into the stack pointer register (ESP), which releases the stack space allocated to the stack frame.
		The old frame pointer (the frame pointer for the calling procedure that was saved by the ENTER instruction) is then
		popped from the stack into the EBP register, restoring the calling procedure's stack frame.
		
		A RET instruction is commonly executed following a LEAVE instruction to return program control to the calling
		procedure.
		
		In 64-bit mode, the instruction's default operation size is 64 bits; 32-bit operation cannot be encoded.

	exceptions

	flags

	operation

	meta
		see
			Chapter 7 - "Procedure Calls for Block-Structured Languages", Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1

lfence=Serializes load operations
	forms

	description
		Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruc-
		tion. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruc-
		tion begins execution until LFENCE completes. In particular, an instruction that loads from memory and that
		precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an
		instruction that stores to memory might complete before the data being stored have become globally visible.)
		Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute until
		the LFENCE completes.
		
		Weakly ordered memory types can be used to achieve higher processor performance through such techniques as
		out-of-order issue and speculative reads. The degree to which a consumer of data recognizes or knows that the
		data is weakly ordered varies among applications and may be unknown to the producer of this data. The LFENCE
		instruction provides a performance-efficient way of ensuring load ordering between routines that produce weakly-
		ordered results and routines that consume that data.
		
		Processors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and
		WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution. 
		Thus, it is not ordered with respect to executions of the LFENCE instruction; 
		
		data can be brought into the caches speculatively just before, during, or after the execution of an LFENCE instruction.
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.
		
		Specification of the instruction's opcode above indicates a ModR/M byte of E8. For this instruction, the processor
		ignores the r/m field of the ModR/M byte. Thus, LFENCE is encoded by any opcode of the form 0F AE Ex, where x is
		in the range 8-F.

	exceptions

	flags

	operation

	meta


lgdt=Load Global Descriptor Table Register
lidt=Load Interrupt Descriptor Table Register
	forms

	description
		Loads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor
		table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a
		linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor
		table (IDT). If operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-
		bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute
		is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here,
		the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is
		filled with zeros.
		
		The LGDT and LIDT instructions are used only in operating-system software; they are not used in application
		programs. They are the only instructions that directly load a linear address (that is, not a segment-relative
		address) and a limit in protected mode. They are commonly executed in real-address mode to allow processor
		initialization prior to switching to protected mode.
		
		In 64-bit mode, the instruction's operand size is fixed at 8+2 bytes (an 8-byte base and a 2-byte limit). See the
		summary chart at the beginning of this section for encoding data and limits.

	exceptions

	flags

	operation

	meta
		linked
			sgdt


lldt=Load Local Descriptor Table Register 
	forms

	description
		Loads the source operand into the segment selector field of the local descriptor table register (LDTR). The source
		operand (a general-purpose register or a memory location) contains a segment selector that points to a local
		descriptor table (LDT). After the segment selector is loaded in the LDTR, the processor uses the segment selector
		to locate the segment descriptor for the LDT in the global descriptor table (GDT). It then loads the segment limit
		and base address for the LDT from the segment descriptor into the LDTR. The segment registers DS, ES, SS, FS, GS, and CS
		are not affected by this instruction, nor is the LDTR field in the task state segment (TSS) for the current task.
		
		If bits 2-15 of the source operand are 0, LDTR is marked invalid and the LLDT instruction completes silently.
		However, all subsequent references to descriptors in the LDT (except by the LAR, VERR, VERW or LSL instructions)
		cause a general protection exception (#GP).
		
		The operand-size attribute has no effect on this instruction.
		
		The LLDT instruction is provided for use in operating-system software; it should not be used in application
		programs. This instruction can only be executed in protected mode or 64-bit mode.
		
		In 64-bit mode, the operand size is fixed at 16 bits.

	exceptions

	flags

	operation

	meta


lmsw=Load Machine Status Word 
	forms

	description
		Loads the source operand into the machine status word, bits 0 through 15 of register CR0. The source operand can
		be a 16-bit general-purpose register or a memory location. Only the low-order 4 bits of the source operand (which
		contains the PE, MP, EM, and TS flags) are loaded into CR0. The PG, CD, NW, AM, WP, NE, and ET flags of CR0 are
		not affected. The operand-size attribute has no effect on this instruction.
		
		If the PE flag of the source operand (bit 0) is set to 1, the instruction causes the processor to switch to protected
		mode. While in protected mode, the LMSW instruction cannot be used to clear the PE flag and force a switch back
		to real-address mode.
		
		The LMSW instruction is provided for use in operating-system software; it should not be used in application
		programs. In protected or virtual-8086 mode, it can only be executed at CPL 0.
		
		This instruction is provided for compatibility with the Intel 286 processor; programs and procedures intended to
		run on the Pentium 4, Intel Xeon, P6 family, Pentium, Intel 486, and Intel 386 processors should use the MOV
		(control registers) instruction to load the whole CR0 register. The MOV CR0 instruction can be used to set and clear
		the PE flag in CR0, allowing a procedure or program to switch between protected and real-address modes.
		This instruction is a serializing instruction.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode. Note that the operand size is fixed at 16 bits.

	exceptions

	flags

	operation

	meta


lock=Instruction prefix: assert the LOCK# signal
	forms

	description
		Causes the processor's LOCK# signal to be asserted during execution of the accompanying instruction (turns the
		instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal ensures that the
		processor has exclusive use of any shared memory while the signal is asserted.
		
		Note that, in later Intel 64 and IA-32 processors (including the Pentium 4, Intel Xeon, and P6 family processors),
		locking may occur without the LOCK# signal being asserted.
		
		The LOCK prefix can be prepended only to the following instructions and only to those forms of the instructions
		where the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B,
		CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. If the LOCK prefix is used with one of
		these instructions and the source operand is a memory operand, an undefined opcode exception (#UD) may be
		generated. An undefined opcode exception will also be generated if the LOCK prefix is used with any instruction not
		in the above list. The XCHG instruction always asserts the LOCK# signal regardless of the presence or absence of
		the LOCK prefix.
		
		The LOCK prefix is typically used with the BTS instruction to perform a read-modify-write operation on a memory
		location in shared memory environment.
		
		The integrity of the LOCK prefix is not affected by the alignment of the memory field. Memory locking is observed
		for arbitrarily misaligned fields.
		
		This instruction's operation is the same in non-64-bit modes and 64-bit mode.

	exceptions

	flags

	operation

	meta
		linked
			add,adc,and,btc,btr,bts,cmpxchg,cmpxchg8b,cmpxchg16b,dec,inc,neg,not,or,sbb,sub,xor,xadd,xchg


lods/lodsb/lodsw/lodsd/lodsq=Load String 
	forms

	description

	exceptions

	flags

	operation

	meta


loop/loopcc=Loop According to ECX Counter 
	forms

	description

	exceptions

	flags

	operation

	meta


lsl=Load Segment Limit 
	forms

	description

	exceptions

	flags

	operation

	meta


ltr=Load Task Register 
	forms

	description

	exceptions

	flags

	operation

	meta


lzcnt=Count the Number of Leading Zero Bits 
	forms

	description

	exceptions

	flags

	operation

	meta


maskmovdqu=Store Selected Bytes of Double Quadword 
	forms

	description

	exceptions

	flags

	operation

	meta


maskmovq=Store Selected Bytes of Quadword 
	forms

	description

	exceptions

	flags

	operation

	meta


maxpd=Return Maximum Packed Double-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


maxps=Return Maximum Packed Single-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


maxsd=Return Maximum Scalar Double-Precision Floating-Point Value 
	forms

	description

	exceptions

	flags

	operation

	meta


maxss=Return Maximum Scalar Single-Precision Floating-Point Value 
	forms

	description

	exceptions

	flags

	operation

	meta


mfence=Memory Fence 
	forms

	description

	exceptions

	flags

	operation

	meta


minpd=Return Minimum Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


minps=Return Minimum Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


minsd=Return Minimum Scalar Double-Precision Floating-Point Value 
	forms

	description

	exceptions

	flags

	operation

	meta


minss=Return Minimum Scalar Single-Precision Floating-Point Value 
	forms

	description

	exceptions

	flags

	operation

	meta


monitor=Set Up Monitor Address 
	forms

	description

	exceptions

	flags

	operation

	meta


mov=Move
mov=Move to/from Control Registers
mov=Move to/from Debug Registers
	forms

	description

	exceptions

	flags

	operation

	meta


movapd=Move Aligned Packed Double-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


movaps=Move Aligned Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


movbe=Move Data After Swapping Bytes
	forms

	description

	exceptions

	flags

	operation

	meta


movd=Move Doubleword
movq=Move Quadword 
	forms

	description

	exceptions

	flags

	operation

	meta


movddup=Move One Double-FP and Duplicate 
	forms

	description

	exceptions

	flags

	operation

	meta


movdqa=Move Aligned Double Quadword 
	forms

	description

	exceptions

	flags

	operation

	meta


movdqu=Move Unaligned Double Quadword 
	forms

	description

	exceptions

	flags

	operation

	meta


movdq2q=Move Quadword from XMM to MMX Technology Register 
	forms

	description

	exceptions

	flags

	operation

	meta


movhlps=Move Packed Single-Precision Floating-Point Values High to Low
	forms

	description

	exceptions

	flags

	operation

	meta


movhpd=Move High Packed Double-Precision Floating-Point Value
	forms

	description

	exceptions

	flags

	operation

	meta


movhps=Move High Packed Single-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


movlhps=Move Packed Single-Precision Floating-Point Values Low to High 
	forms

	description

	exceptions

	flags

	operation

	meta


movlpd=Move Low Packed Double-Precision Floating-Point Value 
	forms

	description

	exceptions

	flags

	operation

	meta


movlps=Move Low Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


movmskpd=Extract Packed Double-Precision Floating-Point Sign Mask 
	forms

	description

	exceptions

	flags

	operation

	meta


movmskps=Extract Packed Single-Precision Floating-Point Sign Mask 
	forms

	description

	exceptions

	flags

	operation

	meta


movntdqa=Load Double Quadword Non-Temporal Aligned Hint 
	forms

	description

	exceptions

	flags

	operation

	meta


movntdq=Store Double Quadword Using Non-Temporal Hint
	forms

	description

	exceptions

	flags

	operation

	meta


movnti=Store Doubleword Using Non-Temporal Hint
	forms

	description

	exceptions

	flags

	operation

	meta


movntpd=Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint 
	forms

	description

	exceptions

	flags

	operation

	meta


movntps=Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint 
	forms

	description

	exceptions

	flags

	operation

	meta


movntq=Store of Quadword Using Non-Temporal Hint 
	forms

	description

	exceptions

	flags

	operation

	meta


movq=Move Quadword 
	forms

	description

	exceptions

	flags

	operation

	meta


movq2dq=Move Quadword from MMX Technology to XMM Register 
	forms

	description

	exceptions

	flags

	operation

	meta


movs/movsb/movsw/movsd/movsq=Move Data from String to String 
	forms

	description

	exceptions

	flags

	operation

	meta


movsd=Move Scalar Double-Precision Floating-Point Value 
	forms

	description

	exceptions

	flags

	operation

	meta


movshdup=Move Packed Single-FP High and Duplicate
	forms

	description

	exceptions

	flags

	operation

	meta


movsldup=Move Packed Single-FP Low and Duplicate 
	forms

	description

	exceptions

	flags

	operation

	meta


movss=Move Scalar Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


movsx/movsxd=Move with Sign-Extension 
	forms

	description

	exceptions

	flags

	operation

	meta


movupd=Move Unaligned Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


movups=Move Unaligned Packed Single-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


movzx=Move with Zero-Extend 
	forms

	description

	exceptions

	flags

	operation

	meta


mpsadbw=Compute Multiple Packed Sums of Absolute Difference 
	forms

	description

	exceptions

	flags

	operation

	meta


mul=Unsigned Multiply
	forms

	description

	exceptions

	flags

	operation

	meta


mulpd=Multiply Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


mulps=Multiply Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


mulsd=Multiply Scalar Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


mulss=Multiply Scalar Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


mulx=Unsigned Multiply Without Affecting Flags
	forms

	description

	exceptions

	flags

	operation

	meta


mwait=Monitor Wait 
	forms

	description

	exceptions

	flags

	operation

	meta


neg=Two's Complement Negation 
	forms

	description

	exceptions

	flags

	operation

	meta


nop=No Operation
	forms

	description

	exceptions

	flags

	operation

	meta


not=One's Complement Negation 
	forms

	description

	exceptions

	flags

	operation

	meta


or=Logical Inclusive OR 
	forms

	description

	exceptions

	flags

	operation

	meta


orpd=Bitwise Logical OR of Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


orps=Bitwise Logical OR of Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


out=Output to Port 
	forms

	description

	exceptions

	flags

	operation

	meta


outs/outsb/outsw/outsd=Output String to Port 
	forms

	description

	exceptions

	flags

	operation

	meta


pabsb/pabsw/pabsd=Packed Absolute Value 
	forms

	description

	exceptions

	flags

	operation

	meta


packsswb/packssdw=Pack with Signed Saturation 
	forms

	description

	exceptions

	flags

	operation

	meta


packusdw=Pack with Unsigned Saturation 
	forms

	description

	exceptions

	flags

	operation

	meta


packuswb=Pack with Unsigned Saturation 
	forms

	description

	exceptions

	flags

	operation

	meta


paddb/paddw/paddd=Add Packed Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


paddq=Add Packed Quadword Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


paddsb/paddsw=Add Packed Signed Integers with Signed Saturation
	forms

	description

	exceptions

	flags

	operation

	meta


paddusb/paddusw=Add Packed Unsigned Integers with Unsigned Saturation 
	forms

	description

	exceptions

	flags

	operation

	meta


palignr=Packed Align Right 
	forms

	description

	exceptions

	flags

	operation

	meta


pand=Logical AND
	forms

	description

	exceptions

	flags

	operation

	meta


pandn=Logical AND NOT 
	forms

	description

	exceptions

	flags

	operation

	meta


pause=Spin Loop Hint 
	forms

	description

	exceptions

	flags

	operation

	meta


pavgb/pavgw=Average Packed Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


pblendvb=Variable Blend Packed Bytes 
	forms

	description

	exceptions

	flags

	operation

	meta


pblendw=Blend Packed Words 
	forms

	description

	exceptions

	flags

	operation

	meta


pclmulqdq=Carry-Less Multiplication Quadword 
	forms

	description

	exceptions

	flags

	operation

	meta


pcmpeqb/pcmpeqw/pcmpeqd=Compare Packed Data for Equal 
	forms

	description

	exceptions

	flags

	operation

	meta


pcmpeqq=Compare Packed Qword Data for Equal
	forms

	description

	exceptions

	flags

	operation

	meta


pcmpestri=Packed Compare Explicit Length Strings, Return Index
	forms

	description

	exceptions

	flags

	operation

	meta


pcmpestrm=Packed Compare Explicit Length Strings, Return Mask 
	forms

	description

	exceptions

	flags

	operation

	meta


pcmpgtb/pcmpgtw/pcmpgtd=Compare Packed Signed Integers for Greater Than
	forms

	description

	exceptions

	flags

	operation

	meta


pcmpgtq=Compare Packed Data for Greater Than 
	forms

	description

	exceptions

	flags

	operation

	meta


pcmpistri=Packed Compare Implicit Length Strings, Return Index 
	forms

	description

	exceptions

	flags

	operation

	meta


pcmpistrm=Packed Compare Implicit Length Strings, Return Mask
	forms

	description

	exceptions

	flags

	operation

	meta


pdep=Parallel Bits Deposit 
	forms

	description

	exceptions

	flags

	operation

	meta


pext=Parallel Bits Extract 
	forms

	description

	exceptions

	flags

	operation

	meta


pextrb=Extract Byte
pextrd=Extract Dword
pextrq=Extract Qword 
	forms

	description

	exceptions

	flags

	operation

	meta


pextrw=Extract Word
	forms

	description

	exceptions

	flags

	operation

	meta


phaddw/phaddd=Packed Horizontal Add
	forms

	description

	exceptions

	flags

	operation

	meta


phaddsw=Packed Horizontal Add and Saturate
	forms

	description

	exceptions

	flags

	operation

	meta


phminposuw=Packed Horizontal Word Minimum
	forms

	description

	exceptions

	flags

	operation

	meta


phsubw/phsubd=Packed Horizontal Subtract
	forms

	description

	exceptions

	flags

	operation

	meta


phsubsw=Packed Horizontal Subtract and Saturate 
	forms

	description

	exceptions

	flags

	operation

	meta


pinsrb=Insert Byte
pinsrd=Insert Dword
pinsrq=Insert Qword 
	forms

	description

	exceptions

	flags

	operation

	meta


pinsrw=Insert Word
	forms

	description

	exceptions

	flags

	operation

	meta


pmaddubsw=Multiply and Add Packed Signed and Unsigned Bytes 
	forms

	description

	exceptions

	flags

	operation

	meta


pmaddwd=Multiply and Add Packed Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


pmaxsb=Maximum of Packed Signed Byte Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


pmaxsd=Maximum of Packed Signed Dword Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


pmaxsw=Maximum of Packed Signed Word Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


pmaxub=Maximum of Packed Unsigned Byte Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


pmaxud=Maximum of Packed Unsigned Dword Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


pmaxuw=Maximum of Packed Word Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


pminsb=Minimum of Packed Signed Byte Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


pminsd=Minimum of Packed Dword Integers
	forms

	description

	exceptions

	flags

	operation

	meta


pminsw=Minimum of Packed Signed Word Integers
	forms

	description

	exceptions

	flags

	operation

	meta


pminub=Minimum of Packed Unsigned Byte Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


pminud=Minimum of Packed Dword Integers
	forms

	description

	exceptions

	flags

	operation

	meta


pminuw=Minimum of Packed Word Integers
	forms

	description

	exceptions

	flags

	operation

	meta


pmovmskb=Move Byte Mask
	forms

	description

	exceptions

	flags

	operation

	meta


pmovsx=Packed Move with Sign Extend
	forms

	description

	exceptions

	flags

	operation

	meta


pmovzx=Packed Move with Zero Extend 
	forms

	description

	exceptions

	flags

	operation

	meta


pmuldq=Multiply Packed Signed Dword Integers
	forms

	description

	exceptions

	flags

	operation

	meta


pmulhrsw=Packed Multiply High with Round and Scale 
	forms

	description

	exceptions

	flags

	operation

	meta


pmulhuw=Multiply Packed Unsigned Integers and Store High Result 
	forms

	description

	exceptions

	flags

	operation

	meta


pmulhw=Multiply Packed Signed Integers and Store High Result
	forms

	description

	exceptions

	flags

	operation

	meta


pmulld=Multiply Packed Signed Dword Integers and Store Low Result
	forms

	description

	exceptions

	flags

	operation

	meta


pmullw=Multiply Packed Signed Integers and Store Low Result 
	forms

	description

	exceptions

	flags

	operation

	meta


pmuludq=Multiply Packed Unsigned Doubleword Integers
	forms

	description

	exceptions

	flags

	operation

	meta


pop=Pop a Value from the Stack
	forms

	description

	exceptions

	flags

	operation

	meta


popa/popad=Pop All General-Purpose Registers
	forms

	description

	exceptions

	flags

	operation

	meta


popcnt=Return the Count of Number of Bits Set to 1 
	forms

	description

	exceptions

	flags

	operation

	meta


popf/popfd/popfq=Pop Stack into EFLAGS Register 
	forms

	description

	exceptions

	flags

	operation

	meta


por=Bitwise Logical OR 
	forms

	description

	exceptions

	flags

	operation

	meta


prefetchh=Prefetch Data Into Caches 
	forms

	description

	exceptions

	flags

	operation

	meta


prefetchw=Prefetch Data into Caches in Anticipation of a Write 
	forms

	description

	exceptions

	flags

	operation

	meta


prefetchwt1=Prefetch Vector Data Into Caches with Intent to Write and T1 Hint 
	forms

	description

	exceptions

	flags

	operation

	meta


psadbw=Compute Sum of Absolute Differences 
	forms

	description

	exceptions

	flags

	operation

	meta


pshufb=Packed Shuffle Bytes 
	forms

	description

	exceptions

	flags

	operation

	meta


pshufd=Shuffle Packed Doublewords 
	forms

	description

	exceptions

	flags

	operation

	meta


pshufhw=Shuffle Packed High Words 
	forms

	description

	exceptions

	flags

	operation

	meta


pshuflw=Shuffle Packed Low Words 
	forms

	description

	exceptions

	flags

	operation

	meta


pshufw=Shuffle Packed Words 
	forms

	description

	exceptions

	flags

	operation

	meta


psignb/psignw/psignd=Packed SIGN 
	forms

	description

	exceptions

	flags

	operation

	meta


pslldq=Shift Double Quadword Left Logical 
	forms

	description

	exceptions

	flags

	operation

	meta


psllw/pslld/psllq=Shift Packed Data Left Logical 
	forms

	description

	exceptions

	flags

	operation

	meta


psraw/psrad=Shift Packed Data Right Arithmetic
	forms

	description

	exceptions

	flags

	operation

	meta


psrldq=Shift Double Quadword Right Logical
	forms

	description

	exceptions

	flags

	operation

	meta


psrlw/psrld/psrlq=Shift Packed Data Right Logical 
	forms

	description

	exceptions

	flags

	operation

	meta


psubb/psubw/psubd=Subtract Packed Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


psubq=Subtract Packed Quadword Integers 
	forms

	description

	exceptions

	flags

	operation

	meta


psubsb/psubsw=Subtract Packed Signed Integers with Signed Saturation 
	forms

	description

	exceptions

	flags

	operation

	meta


psubusb/psubusw=Subtract Packed Unsigned Integers with Unsigned Saturation 
	forms

	description

	exceptions

	flags

	operation

	meta


ptest=Logical Compare 
	forms

	description

	exceptions

	flags

	operation

	meta


punpckhbw/punpckhwd/punpckhdq/punpckhqdq=Unpack High Data 
	forms

	description

	exceptions

	flags

	operation

	meta


punpcklbw/punpcklwd/punpckldq/punpcklqdq=Unpack Low Data 
	forms

	description

	exceptions

	flags

	operation

	meta


push=Push Word, Doubleword or Quadword Onto the Stack 
	forms

	description

	exceptions

	flags

	operation

	meta


pusha/pushad=Push All General-Purpose Registers 
	forms

	description

	exceptions

	flags

	operation

	meta


pushf/pushfd=Push EFLAGS Register onto the Stack 
	forms

	description

	exceptions

	flags

	operation

	meta


pxor=Logical Exclusive OR 
	forms

	description

	exceptions

	flags

	operation

	meta


rcl/rcr/rol/ror=-Rotate 
	forms

	description

	exceptions

	flags

	operation

	meta


rcpps=Compute Reciprocals of Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


rcpss=Compute Reciprocal of Scalar Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


rdfsbase=Read FS Segment Base
rdgsbase=Read GS Segment Base
	forms

	description

	exceptions

	flags

	operation

	meta


rdmsr=Read from Model Specific Register 
	forms

	description

	exceptions

	flags

	operation

	meta


rdpkru=Read Protection Key Rights for User Pages 
	forms

	description

	exceptions

	flags

	operation

	meta


rdpmc=Read Performance-Monitoring Counters
	forms

	description

	exceptions

	flags

	operation

	meta


rdrand=Read Random Number 
	forms

	description

	exceptions

	flags

	operation

	meta


rdseed=Read Random SEED 
	forms

	description

	exceptions

	flags

	operation

	meta


rdtsc=Read Time-Stamp Counter 
	forms

	description

	exceptions

	flags

	operation

	meta


rdtscp=Read Time-Stamp Counter and Processor ID 
	forms

	description

	exceptions

	flags

	operation

	meta


rep/repe/repz/repne/repnz=Repeat String Operation Prefix 
	forms

	description

	exceptions

	flags

	operation

	meta


ret=Return from Procedure
	forms

	description

	exceptions

	flags

	operation

	meta


rorx=Rotate Right Logical Without Affecting Flags 
	forms

	description

	exceptions

	flags

	operation

	meta


roundpd=Round Packed Double Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


roundps=Round Packed Single Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


roundsd=Round Scalar Double Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


roundss=Round Scalar Single Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


rsm=Resume from System Management Mode
	forms

	description

	exceptions

	flags

	operation

	meta


rsqrtps=Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


rsqrtss=Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value 
	forms

	description

	exceptions

	flags

	operation

	meta


sahf=Store AH into Flags
	forms

	description

	exceptions

	flags

	operation

	meta


sal/sar/shl/shr=Shift 
	forms

	description

	exceptions

	flags

	operation

	meta


sarx/shlx/shrx=Shift Without Affecting Flags
	forms

	description

	exceptions

	flags

	operation

	meta


sbb=Integer Subtraction with Borrow 
	forms

	description

	exceptions

	flags

	operation

	meta


scas/scasb/scasw/scasd=Scan String 
	forms

	description

	exceptions

	flags

	operation

	meta


setcc=Set Byte on Condition 
	forms

	description

	exceptions

	flags

	operation

	meta


sfence=Store Fence
	forms

	description

	exceptions

	flags

	operation

	meta


sgdt=Store Global Descriptor Table Register
	forms

	description

	exceptions

	flags

	operation

	meta


shld=Double Precision Shift Left
	forms

	description

	exceptions

	flags

	operation

	meta


shrd=Double Precision Shift Right 
	forms

	description

	exceptions

	flags

	operation

	meta


shufpd=Shuffle Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


shufps=Shuffle Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


sidt=Store Interrupt Descriptor Table Register 
	forms

	description

	exceptions

	flags

	operation

	meta


sldt=Store Local Descriptor Table Register
	forms

	description

	exceptions

	flags

	operation

	meta


smsw=Store Machine Status Word 
	forms

	description

	exceptions

	flags

	operation

	meta


sqrtpd=Compute Square Roots of Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


sqrtps=Compute Square Roots of Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


sqrtsd=Compute Square Root of Scalar Double-Precision Floating-Point Value
	forms

	description

	exceptions

	flags

	operation

	meta


sqrtss=Compute Square Root of Scalar Single-Precision Floating-Point Value
	forms

	description

	exceptions

	flags

	operation

	meta


stac=Set AC Flag in EFLAGS Register 
	forms

	description

	exceptions

	flags

	operation

	meta


stc=Set Carry Flag 
	forms

	description

	exceptions

	flags

	operation

	meta


std=Set Direction Flag
	forms

	description

	exceptions

	flags

	operation

	meta


sti=Set Interrupt Flag
	forms

	description

	exceptions

	flags

	operation

	meta


stmxcsr=Store MXCSR Register State 
	forms

	description

	exceptions

	flags

	operation

	meta


stos/stosb/stosw/stosd/stosq=Store String 
	forms

	description

	exceptions

	flags

	operation

	meta


str=Store Task Register
	forms

	description

	exceptions

	flags

	operation

	meta


sub=Subtract 
	forms

	description

	exceptions

	flags

	operation

	meta


subpd=Subtract Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


subps=Subtract Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


subsd=Subtract Scalar Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


subss=Subtract Scalar Single-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


swapgs=Swap GS Base Register 
	forms

	description

	exceptions

	flags

	operation

	meta


syscall=Fast System Call 
	forms

	description

	exceptions

	flags

	operation

	meta


sysenter=Fast System Call
	forms

	description

	exceptions

	flags

	operation

	meta


sysexit=Fast Return from Fast System Call 
	forms

	description

	exceptions

	flags

	operation

	meta


sysret=Return From Fast System Call 
	forms

	description

	exceptions

	flags

	operation

	meta


test=Logical Compare 
	forms

	description

	exceptions

	flags

	operation

	meta


tzcnt=Count the Number of Trailing Zero Bits 
	forms

	description

	exceptions

	flags

	operation

	meta


ucomisd=Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS 
	forms

	description

	exceptions

	flags

	operation

	meta


ucomiss=Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS 
	forms

	description

	exceptions

	flags

	operation

	meta


ud2=Undefined Instruction
	forms

	description

	exceptions

	flags

	operation

	meta


unpckhpd=Unpack and Interleave High Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


unpckhps=Unpack and Interleave High Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


unpcklpd=Unpack and Interleave Low Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


unpcklps=Unpack and Interleave Low Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vbroadcast=Broadcast Floating-Point Data 
	forms

	description

	exceptions

	flags

	operation

	meta


vcvtph2ps=Convert 16-bit FP Values to Single-Precision FP Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vcvtps2ph=Convert Single-Precision FP value to 16-bit FP value 
	forms

	description

	exceptions

	flags

	operation

	meta


verr/verw=Verify a Segment for Reading or Writing 
	forms

	description

	exceptions

	flags

	operation

	meta


vextractf128=Extract Packed Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vextracti128=Extract packed Integer Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmadd132pd/vfnmadd213pd/vfnmadd231pd=Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmadd132ps/vfnmadd213ps/vfnmadd231ps=Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmadd132sd/vfnmadd213sd/vfnmadd231sd=Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmadd132ss/vfnmadd213ss/vfnmadd231ss=Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmsub132pd/vfnmsub213pd/vfnmsub231pd=Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmsub132ps/vfnmsub213ps/vfnmsub231ps=Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmsub132sd/vfnmsub213sd/vfnmsub231sd=Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vfnmsub132ss/vfnmsub213ss/vfnmsub231ss=Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vgatherdpd=Gather Packed DP FP Values Using Signed Dword Indices
vgatherqpd=Gather Packed DP FP Values Using Signed Qword Indices
	forms

	description

	exceptions

	flags

	operation

	meta


vgatherdps=Gather Packed SP FP values Using Signed Dword Indices
vgatherqps=Gather Packed SP FP values Using Signed Qword Indices
	forms

	description

	exceptions

	flags

	operation

	meta


vpgatherdd=Gather Packed Dword Values Using Signed Dword Indices 
vpgatherqd=Gather Packed Dword Values Using Signed Qword Indices 
	forms

	description

	exceptions

	flags

	operation

	meta


vpgatherdq=Gather Packed Qword Values Using Signed Dword Indices
vpgatherqq=Gather Packed Qword Values Using Signed Qword Indices 
	forms

	description

	exceptions

	flags

	operation

	meta


vinsertf128=Insert Packed Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


vinserti128=Insert Packed Integer Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vmaskmov=Conditional SIMD Packed Loads and Stores 
	forms

	description

	exceptions

	flags

	operation

	meta


vpblendd=Blend Packed Dwords 
	forms

	description

	exceptions

	flags

	operation

	meta


vpbroadcast=Broadcast Integer Data
	forms

	description

	exceptions

	flags

	operation

	meta


vpermd=Full Doublewords Element Permutation
	forms

	description

	exceptions

	flags

	operation

	meta


vpermpd=Permute Double-Precision Floating-Point Elements 
	forms

	description

	exceptions

	flags

	operation

	meta


vpermps=Permute Single-Precision Floating-Point Elements 
	forms

	description

	exceptions

	flags

	operation

	meta


vpermq=Qwords Element Permutation 
	forms

	description

	exceptions

	flags

	operation

	meta


vperm2i128=Permute Integer Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vpermilpd=Permute Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vpermilps=Permute Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


vperm2f128=Permute Floating-Point Values
	forms

	description

	exceptions

	flags

	operation

	meta


vpmaskmov=Conditional SIMD Integer Packed Loads and Stores 
	forms

	description

	exceptions

	flags

	operation

	meta


vpsllvd/vpsllvq=Variable Bit Shift Left Logical
	forms

	description

	exceptions

	flags

	operation

	meta


vpsravd=Variable Bit Shift Right Arithmetic 
	forms

	description

	exceptions

	flags

	operation

	meta


vpsrlvd/vpsrlvq=Variable Bit Shift Right Logical 
	forms

	description

	exceptions

	flags

	operation

	meta


vtestpd/vtestps=Packed Bit Test
	forms

	description

	exceptions

	flags

	operation

	meta


vzeroall=Zero All YMM Registers 
	forms

	description

	exceptions

	flags

	operation

	meta


vzeroupper=Zero Upper Bits of YMM Registers 
	forms

	description

	exceptions

	flags

	operation

	meta


wait/fwait=Wait 
	forms

	description

	exceptions

	flags

	operation

	meta


wbinvd=Write Back and Invalidate Cache 
	forms

	description

	exceptions

	flags

	operation

	meta


wrfsbase=Write FS Segment Base 
wrgsbase=Write GS Segment Base 
	forms

	description

	exceptions

	flags

	operation

	meta


wrmsr=Write to Model Specific Register 
	forms

	description

	exceptions

	flags

	operation

	meta


wrpkru=Write Data to User Page Key Register
	forms

	description

	exceptions

	flags

	operation

	meta


xacquire/xrelease=Hardware Lock Elision Prefix Hints 
	forms

	description

	exceptions

	flags

	operation

	meta


xabort=Transactional Abort 
	forms

	description

	exceptions

	flags

	operation

	meta


xadd=Exchange and Add 
	forms

	description

	exceptions

	flags

	operation

	meta


xbegin=Transactional Begin 
	forms

	description

	exceptions

	flags

	operation

	meta


xchg=Exchange Register/Memory with Register 
	forms

	description

	exceptions

	flags

	operation

	meta


xend=Transactional End 
	forms

	description

	exceptions

	flags

	operation

	meta


xgetbv=Get Value of Extended Control Register 
	forms

	description

	exceptions

	flags

	operation

	meta


xlat/xlatb=Table Look-up Translation 
	forms

	description

	exceptions

	flags

	operation

	meta


xor=Logical Exclusive OR 
	forms

	description

	exceptions

	flags

	operation

	meta


xorpd=Bitwise Logical XOR for Double-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


xorps=Bitwise Logical XOR for Single-Precision Floating-Point Values 
	forms

	description

	exceptions

	flags

	operation

	meta


xrstor=Restore Processor Extended States 
	forms

	description

	exceptions

	flags

	operation

	meta


xrstors=Restore Processor Extended States Supervisor 
	forms

	description

	exceptions

	flags

	operation

	meta


xsave=Save Processor Extended States 
	forms

	description

	exceptions

	flags

	operation

	meta


xsavec=Save Processor Extended States with Compaction
	forms

	description

	exceptions

	flags

	operation

	meta


xsaveopt=Save Processor Extended States Optimized 
	forms

	description

	exceptions

	flags

	operation

	meta


xsaves=Save Processor Extended States Supervisor 
	forms

	description

	exceptions

	flags

	operation

	meta


xsetbv=Set Extended Control Register 
	forms

	description

	exceptions

	flags

	operation

	meta


xtest=Test If In Transactional Execution
	forms

	description

	exceptions

	flags

	operation

	meta


